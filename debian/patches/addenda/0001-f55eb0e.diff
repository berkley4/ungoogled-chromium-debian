From f55eb0eac78106ecf055b3361a94efbd18172fdd Mon Sep 17 00:00:00 2001
From: Thibaud Michaud <thibaudm@chromium.org>
Date: Tue, 10 Sep 2024 19:14:11 +0200
Subject: [PATCH] Merged: [wasm][jspi] Fix stack unwinding at stack boundary

When an exception is not caught by the current stack and is forwarded to
the parent stack, treat it as a return stack-switch: retire the current
stack and mark the parent as the new active stack.

R=clemensb@chromium.org,ishell@chromium.org

Fixed: 363051803
(cherry picked from commit 6508440f449d58890be2e4c885c8a2b57efccf15)

Change-Id: Ic8a67fe20561a5ce4ba260f705335649a3b09461
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/5851772
Commit-Queue: Thibaud Michaud <thibaudm@chromium.org>
Reviewed-by: Shu-yu Guo <syg@chromium.org>
Cr-Commit-Position: refs/branch-heads/12.8@{#63}
Cr-Branched-From: 70cbb397b153166027e34c75adf8e7993858222e-refs/heads/12.8.374@{#1}
Cr-Branched-From: 451b63ed4251c2b21c56144d8428f8be3331539b-refs/heads/main@{#95151}
---

--- a/v8/src/execution/isolate.cc
+++ b/v8/src/execution/isolate.cc
@@ -2125,10 +2125,16 @@
         // We reached the base of the wasm stack. Follow the chain of
         // continuations to find the parent stack and reset the iterator.
         DCHECK(!continuation.is_null());
-        continuation = Cast<WasmContinuationObject>(continuation->parent());
         wasm::StackMemory* stack =
             reinterpret_cast<wasm::StackMemory*>(continuation->stack());
-        iter.Reset(thread_local_top(), stack);
+        RetireWasmStack(stack);
+        continuation = Cast<WasmContinuationObject>(continuation->parent());
+        wasm::StackMemory* parent =
+            reinterpret_cast<wasm::StackMemory*>(continuation->stack());
+        parent->jmpbuf()->state = wasm::JumpBuffer::Active;
+        roots_table().slot(RootIndex::kActiveContinuation).store(continuation);
+        SyncStackLimit();
+        iter.Reset(thread_local_top(), parent);
       }
     }
 #endif
@@ -3642,6 +3648,25 @@
   }
 }
 
+void Isolate::RetireWasmStack(wasm::StackMemory* stack) {
+  stack->jmpbuf()->state = wasm::JumpBuffer::Retired;
+  size_t index = stack->index();
+  // We can only return from a stack that was still in the global list.
+  DCHECK_LT(index, wasm_stacks().size());
+  std::unique_ptr<wasm::StackMemory> stack_ptr =
+      std::move(wasm_stacks()[index]);
+  DCHECK_EQ(stack_ptr.get(), stack);
+  if (index != wasm_stacks().size() - 1) {
+    wasm_stacks()[index] = std::move(wasm_stacks().back());
+    wasm_stacks()[index]->set_index(index);
+  }
+  wasm_stacks().pop_back();
+  for (size_t i = 0; i < wasm_stacks().size(); ++i) {
+    SLOW_DCHECK(wasm_stacks()[i]->index() == i);
+  }
+  stack_pool().Add(std::move(stack_ptr));
+}
+
 wasm::WasmOrphanedGlobalHandle* Isolate::NewWasmOrphanedGlobalHandle() {
   return wasm::WasmEngine::NewOrphanedGlobalHandle(&wasm_orphaned_handle_);
 }
--- a/v8/src/execution/isolate.h
+++ b/v8/src/execution/isolate.h
@@ -2173,6 +2173,12 @@
   void UpdateCentralStackInfo();
 
   void SyncStackLimit();
+
+  // To be called when returning from {stack}, or when an exception crosses the
+  // stack boundary. This updates the {StackMemory} object and the global
+  // {wasm_stacks_} list. This does *not* update the ActiveContinuation root and
+  // the stack limit.
+  void RetireWasmStack(wasm::StackMemory* stack);
 #else
   bool IsOnCentralStack() { return true; }
 #endif
--- a/v8/src/wasm/stacks.cc
+++ b/v8/src/wasm/stacks.cc
@@ -65,10 +65,6 @@
     return;
   }
   size_ += stack->size_;
-#if DEBUG
-  constexpr uint8_t kZapValue = 0xab;
-  memset(stack->limit_, kZapValue, stack->size_);
-#endif
   freelist_.push_back(std::move(stack));
 }
 
--- a/v8/src/wasm/wasm-external-refs.cc
+++ b/v8/src/wasm/wasm-external-refs.cc
@@ -675,19 +675,9 @@
 
   Tagged<WasmContinuationObject> continuation =
       Cast<WasmContinuationObject>(Tagged<Object>{raw_continuation});
-  size_t index = reinterpret_cast<StackMemory*>(continuation->stack())->index();
-  // We can only return from a stack that was still in the global list.
-  DCHECK_LT(index, isolate->wasm_stacks().size());
-  std::unique_ptr<StackMemory> stack = std::move(isolate->wasm_stacks()[index]);
-  if (index != isolate->wasm_stacks().size() - 1) {
-    isolate->wasm_stacks()[index] = std::move(isolate->wasm_stacks().back());
-    isolate->wasm_stacks()[index]->set_index(index);
-  }
-  isolate->wasm_stacks().pop_back();
-  for (size_t i = 0; i < isolate->wasm_stacks().size(); ++i) {
-    SLOW_DCHECK(isolate->wasm_stacks()[i]->index() == i);
-  }
-  isolate->stack_pool().Add(std::move(stack));
+  wasm::StackMemory* stack =
+      reinterpret_cast<StackMemory*>(continuation->stack());
+  isolate->RetireWasmStack(stack);
   isolate->SyncStackLimit();
 }
 
