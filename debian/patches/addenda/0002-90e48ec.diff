From 90e48ecc4ed9feeba36f49065c738d620d6f0780 Mon Sep 17 00:00:00 2001
From: mark a. foltz <mfoltz@chromium.org>
Date: Fri, 22 Mar 2024 16:33:58 -0700
Subject: [PATCH] [Open Screen] Fix crash in Sender::EnqueueFrame()

Senders insist on providing frames with invalid reference times that are
non-montonically increasing.  This is a client bug, but the main
consequence is inaccurate sender reports that are used by the receiver
for A/V sync, so we carry on instead of crashing.

NOTE: Attempts to write a fine gained unit test were unsuccessful, as
various layers of the stack make timestamp conversions that actually
change underlying sender report values, making it hard to write
easy-to-understand expectations on the sender reports.  This would be
worth further investigation.

Bug: 330810255
Change-Id: Ib2db10ed5a470f4e31a4a206e09cc9d5d772c614
Reviewed-on: https://chromium-review.googlesource.com/c/openscreen/+/5388978
Commit-Queue: Mark Foltz <mfoltz@chromium.org>
Reviewed-by: Jordan Bayles <jophba@chromium.org>
---

--- a/third_party/openscreen/src/cast/streaming/sender.cc
+++ b/third_party/openscreen/src/cast/streaming/sender.cc
@@ -233,7 +233,12 @@
   OSP_CHECK_GE(frame.referenced_frame_id, FrameId::first());
   if (frame.frame_id != FrameId::first()) {
     OSP_CHECK_GT(frame.rtp_timestamp, pending_sender_report_.rtp_timestamp);
-    OSP_CHECK_GT(frame.reference_time, pending_sender_report_.reference_time);
+    if (frame.reference_time <= pending_sender_report_.reference_time) {
+      OSP_DLOG_WARN << "Frame " << frame.frame_id
+                    << " has non-monotonic reference_time: "
+                    << frame.reference_time
+                    << " <= " << pending_sender_report_.reference_time;
+    }
   }
   OSP_CHECK(frame.data.data());
 
@@ -278,8 +283,13 @@
     playout_delay_change_at_frame_id_ = slot->frame->frame_id;
   }
 
-  // Update the lip-sync information for the next Sender Report.
-  pending_sender_report_.reference_time = slot->frame->reference_time;
+  // Update the lip-sync information for the next Sender Report, ensuring that
+  // the reference time is monotonically increasing.
+  pending_sender_report_.reference_time =
+      frame.frame_id == FrameId::first()
+          ? slot->frame->reference_time
+          : std::max(slot->frame->reference_time,
+                     pending_sender_report_.reference_time);
   pending_sender_report_.rtp_timestamp = slot->frame->rtp_timestamp;
 
   // If the round trip time hasn't been computed yet, immediately send a RTCP
--- a/third_party/openscreen/src/cast/streaming/sender_unittest.cc
+++ b/third_party/openscreen/src/cast/streaming/sender_unittest.cc
@@ -975,6 +975,27 @@
   EXPECT_EQ(uint32_t{kFrameDataSize}, sender_reports.back().send_octet_count);
 }
 
+TEST_F(SenderTest, ReferenceTimesCanBeNonMonotonic) {
+  // This tests that the sender is robust to encoded frames with non-monotonic
+  // reference times.  This situation does not prevent frames from being
+  // transmitted in correct order; however, lip sync will suffer if reference
+  // times do not correspond to RTP timestamps.
+  EXPECT_CALL(*receiver(), OnRtpPacket(_)).Times(AtLeast(1));
+  EXPECT_CALL(*receiver(), OnSenderReport(_)).Times(AtLeast(1));
+
+  // Send the 10 frames with non-monotonic reference times.
+  Clock::time_point reference_time = FakeClock::now();
+  for (int i = 0; i < 10; ++i) {
+    EncodedFrameWithBuffer frame;
+    PopulateFrameWithDefaults(sender()->GetNextFrameId(), reference_time, 0,
+                              13 /* bytes */, &frame);
+    // OverrideRtpTimestamp(i, &frame, 1000 /* fps */);
+    ASSERT_EQ(Sender::OK, sender()->EnqueueFrame(frame));
+    SimulateExecution(kFrameDuration);
+    reference_time -= microseconds(10);
+  }
+}
+
 // Tests that the Sender provides Kickstart packets whenever the Receiver may
 // not know about new frames.
 TEST_F(SenderTest, ProvidesKickstartPacketsIfReceiverDoesNotACK) {
