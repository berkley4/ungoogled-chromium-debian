From feffd473d9ce287bfff9bbb218db7f65a983d28d Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olv@google.com>
Date: Mon, 15 Apr 2024 19:41:05 +0000
Subject: [PATCH] Vulkan: Fix kYV12 support

kYV12 has plane config kY_V_U.  ToVkFormatExternalSampler, however,
treats it as kY_U_V because Vulkan only has
VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM.  We should apply swizzles in
GrVkYcbcrConversionInfo.

BUG=b:329151784
TEST=exo client with DRM_FORMAT_YVU420

(cherry picked from commit 714bde1fc26e8776af23b14ab6793536eb65c15d)

Change-Id: Icf3f87d55f7279ee82a3e6c721e8faeee8cb03e1
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5411403
Reviewed-by: Vasiliy Telezhnikov <vasilyt@chromium.org>
Commit-Queue: Chia-I Wu <olv@google.com>
Reviewed-by: Peng Huang <penghuang@chromium.org>
Cr-Original-Commit-Position: refs/heads/main@{#1284849}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5444210
Reviewed-by: Peter McNeeley <petermcneeley@chromium.org>
Commit-Queue: Peter McNeeley <petermcneeley@chromium.org>
Cr-Commit-Position: refs/branch-heads/6367@{#867}
Cr-Branched-From: d158c6dc6e3604e6f899041972edf26087a49740-refs/heads/main@{#1274542}
---

--- a/components/viz/service/display_embedder/skia_output_surface_impl.cc
+++ b/components/viz/service/display_embedder/skia_output_surface_impl.cc
@@ -1521,11 +1521,12 @@
                          ? gpu::ToVkFormatExternalSampler(si_format)
                          : gpu::ToVkFormatSinglePlanar(si_format);
     // Assume optimal tiling.
-    GrVkYcbcrConversionInfo gr_ycbcr_info = CreateGrVkYcbcrConversionInfo(
-        dependency_->GetVulkanContextProvider()
-            ->GetDeviceQueue()
-            ->GetVulkanPhysicalDevice(),
-        VK_IMAGE_TILING_OPTIMAL, vk_format, yuv_color_space, ycbcr_info);
+    GrVkYcbcrConversionInfo gr_ycbcr_info =
+        CreateGrVkYcbcrConversionInfo(dependency_->GetVulkanContextProvider()
+                                          ->GetDeviceQueue()
+                                          ->GetVulkanPhysicalDevice(),
+                                      VK_IMAGE_TILING_OPTIMAL, vk_format,
+                                      si_format, yuv_color_space, ycbcr_info);
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
     // Textures that were allocated _on linux_ with ycbcr info came from
     // VaapiVideoDecoder, which exports using DRM format modifiers.
--- a/gpu/command_buffer/service/shared_image/ahardwarebuffer_image_backing_factory.cc
+++ b/gpu/command_buffer/service/shared_image/ahardwarebuffer_image_backing_factory.cc
@@ -283,7 +283,7 @@
     // if the vk_info stays the same on subsequent calls.
     promise_texture_ = GrPromiseImageTexture::Make(GrBackendTextures::MakeVk(
         size().width(), size().height(),
-        CreateGrVkImageInfo(vulkan_image_.get(), color_space())));
+        CreateGrVkImageInfo(vulkan_image_.get(), format(), color_space())));
     DCHECK(promise_texture_);
   }
 };
--- a/gpu/command_buffer/service/shared_image/angle_vulkan_image_backing.cc
+++ b/gpu/command_buffer/service/shared_image/angle_vulkan_image_backing.cc
@@ -314,7 +314,7 @@
       return false;
     }
 
-    vk_textures_.emplace_back(std::move(vulkan_image), color_space());
+    vk_textures_.emplace_back(std::move(vulkan_image), format(), color_space());
   }
 
   if (!data.empty()) {
@@ -352,7 +352,7 @@
     return false;
   }
 
-  vk_textures_.emplace_back(std::move(vulkan_image), color_space());
+  vk_textures_.emplace_back(std::move(vulkan_image), format(), color_space());
 
   SetCleared();
 
--- a/gpu/command_buffer/service/shared_image/external_vk_image_backing.cc
+++ b/gpu/command_buffer/service/shared_image/external_vk_image_backing.cc
@@ -226,7 +226,7 @@
     }
 
     estimated_size += image->device_size();
-    textures.emplace_back(std::move(image), color_space);
+    textures.emplace_back(std::move(image), format, color_space);
   }
 
   bool use_separate_gl_texture =
@@ -296,7 +296,7 @@
 
   std::vector<TextureHolderVk> textures;
   textures.reserve(1);
-  textures.emplace_back(std::move(image), color_space);
+  textures.emplace_back(std::move(image), format, color_space);
 
   bool use_separate_gl_texture =
       UseSeparateGLTexture(context_state.get(), format);
--- a/gpu/command_buffer/service/shared_image/skia_vk_ozone_image_representation.cc
+++ b/gpu/command_buffer/service/shared_image/skia_vk_ozone_image_representation.cc
@@ -59,7 +59,7 @@
     auto promise_texture =
         GrPromiseImageTexture::Make(GrBackendTextures::MakeVk(
             vulkan_image->size().width(), vulkan_image->size().height(),
-            CreateGrVkImageInfo(vulkan_image.get(), color_space())));
+            CreateGrVkImageInfo(vulkan_image.get(), format(), color_space())));
     if (!promise_texture) {
       LOG(ERROR) << "Unable to create GrPromiseImageTexture";
       promise_textures_.clear();
--- a/gpu/command_buffer/service/shared_image/texture_holder_vk.cc
+++ b/gpu/command_buffer/service/shared_image/texture_holder_vk.cc
@@ -12,11 +12,12 @@
 namespace gpu {
 
 TextureHolderVk::TextureHolderVk(std::unique_ptr<VulkanImage> image,
+                                 const viz::SharedImageFormat& si_format,
                                  const gfx::ColorSpace& color_space)
     : vulkan_image(std::move(image)) {
   gfx::Size size = vulkan_image->size();
   GrVkImageInfo vk_image_info =
-      CreateGrVkImageInfo(vulkan_image.get(), color_space);
+      CreateGrVkImageInfo(vulkan_image.get(), si_format, color_space);
   backend_texture =
       GrBackendTextures::MakeVk(size.width(), size.height(), vk_image_info);
   promise_texture = GrPromiseImageTexture::Make(backend_texture);
--- a/gpu/command_buffer/service/shared_image/texture_holder_vk.h
+++ b/gpu/command_buffer/service/shared_image/texture_holder_vk.h
@@ -15,6 +15,10 @@
 class ColorSpace;
 }  // namespace gfx
 
+namespace viz {
+class SharedImageFormat;
+}  // namespace viz
+
 namespace gpu {
 
 class VulkanImage;
@@ -22,6 +26,7 @@
 // Holds VulkanImage + skia representations of it.
 struct TextureHolderVk {
   explicit TextureHolderVk(std::unique_ptr<VulkanImage> image,
+                           const viz::SharedImageFormat& si_format,
                            const gfx::ColorSpace& color_space);
   TextureHolderVk(TextureHolderVk&& other);
   TextureHolderVk& operator=(TextureHolderVk&& other);
--- a/gpu/command_buffer/service/shared_image/video_image_reader_image_backing.cc
+++ b/gpu/command_buffer/service/shared_image/video_image_reader_image_backing.cc
@@ -385,7 +385,7 @@
       // this if the vk_info stays the same on subsequent calls.
       promise_texture_ = GrPromiseImageTexture::Make(GrBackendTextures::MakeVk(
           size().width(), size().height(),
-          CreateGrVkImageInfo(vulkan_image_.get(), color_space())));
+          CreateGrVkImageInfo(vulkan_image_.get(), format(), color_space())));
       DCHECK(promise_texture_);
     }
 
--- a/gpu/command_buffer/service/skia_utils.cc
+++ b/gpu/command_buffer/service/skia_utils.cc
@@ -32,6 +32,7 @@
 
 #if BUILDFLAG(ENABLE_VULKAN)
 #include "components/viz/common/gpu/vulkan_context_provider.h"
+#include "components/viz/common/resources/shared_image_format.h"
 #include "gpu/vulkan/vulkan_device_queue.h"
 #include "gpu/vulkan/vulkan_fence_helper.h"
 #include "gpu/vulkan/vulkan_function_pointers.h"
@@ -294,13 +295,14 @@
 
 #if BUILDFLAG(ENABLE_VULKAN)
 GrVkImageInfo CreateGrVkImageInfo(VulkanImage* image,
+                                  const viz::SharedImageFormat& si_format,
                                   const gfx::ColorSpace& color_space) {
   DCHECK(image);
   VkPhysicalDevice physical_device =
       image->device_queue()->GetVulkanPhysicalDevice();
   GrVkYcbcrConversionInfo gr_ycbcr_info = CreateGrVkYcbcrConversionInfo(
-      physical_device, image->image_tiling(), image->format(), color_space,
-      image->ycbcr_info());
+      physical_device, image->image_tiling(), image->format(), si_format,
+      color_space, image->ycbcr_info());
   GrVkAlloc alloc;
   alloc.fMemory = image->device_memory();
   alloc.fOffset = 0;
@@ -351,6 +353,7 @@
     VkPhysicalDevice physical_device,
     VkImageTiling tiling,
     VkFormat format,
+    const viz::SharedImageFormat& si_format,
     const gfx::ColorSpace& color_space,
     const std::optional<VulkanYCbCrInfo>& ycbcr_info) {
   auto valid_ycbcr_info = ycbcr_info;
@@ -419,6 +422,24 @@
   gr_ycbcr_info.fForceExplicitReconstruction = false;
   gr_ycbcr_info.fFormatFeatures = format_features;
 
+  if (!gr_ycbcr_info.fExternalFormat &&
+      (si_format == viz::LegacyMultiPlaneFormat::kYV12 ||
+       (si_format.is_multi_plane() &&
+        si_format.plane_config() ==
+            viz::SharedImageFormat::PlaneConfig::kY_V_U))) {
+    switch (vk_format) {
+      case VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:
+      case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:
+      case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
+      case VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM:
+        gr_ycbcr_info.fComponents.r = VK_COMPONENT_SWIZZLE_B;
+        gr_ycbcr_info.fComponents.b = VK_COMPONENT_SWIZZLE_R;
+        break;
+      default:
+        break;
+    }
+  }
+
   return gr_ycbcr_info;
 }
 
--- a/gpu/command_buffer/service/skia_utils.h
+++ b/gpu/command_buffer/service/skia_utils.h
@@ -38,6 +38,7 @@
 }  // namespace gfx
 
 namespace viz {
+class SharedImageFormat;
 class VulkanContextProvider;
 }  // namespace viz
 
@@ -107,12 +108,15 @@
 
 #if BUILDFLAG(ENABLE_VULKAN)
 GPU_GLES2_EXPORT GrVkImageInfo
-CreateGrVkImageInfo(VulkanImage* image, const gfx::ColorSpace& color_space);
+CreateGrVkImageInfo(VulkanImage* image,
+                    const viz::SharedImageFormat& si_format,
+                    const gfx::ColorSpace& color_space);
 
 GPU_GLES2_EXPORT GrVkYcbcrConversionInfo
 CreateGrVkYcbcrConversionInfo(VkPhysicalDevice physical_device,
                               VkImageTiling tiling,
                               VkFormat format,
+                              const viz::SharedImageFormat& si_format,
                               const gfx::ColorSpace& color_space,
                               const std::optional<VulkanYCbCrInfo>& ycbcr_info);
 #endif  // BUILDFLAG(ENABLE_VULKAN)
