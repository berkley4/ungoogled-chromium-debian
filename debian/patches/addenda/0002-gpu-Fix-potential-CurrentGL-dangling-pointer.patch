From 02192f2ef00110141c17f1255198f60b01f64d1d Mon Sep 17 00:00:00 2001
From: Sunny Sachanandani <sunnyps@chromium.org>
Date: Sat, 9 Sep 2023 01:55:34 +0000
Subject: [PATCH] gpu: Fix potential CurrentGL dangling pointer

There's a potential issue with GLContextEGL::ReleaseBackpressureFences
leaving the thread local CurrentGL pointer set if there was no previous
current context. This means that the pointer will be dangling when the
context is destroyed. This ordinarily doesn't happen with Ganesh/GL
since there's almost always a current GL context, but it's possible with
Graphite when SharedContext won't ever make its context current.

This CL also cleans up the code related to setting the thread local
CurrentGL pointer:

- GetGlContextForCurrentThread returns a reference to the thread local
  CurrentGL pointer so it's renamed to ThreadLocalCurrentGL and is
  not exposed via gl_bindings.h (see below).
- GetThreadLocalCurrentGL returns the CurrentGL pointer and is exported
  in gl_bindings.h. It does not return a mutable reference though.
- SetCurrentGL sets the thread local CurrentGL pointer so it's renamed
  to SetThreadLocalCurrentGL to distinguish it from GetCurrentGL which
  is an accessor on the GLContext class.

Bug: 1478112
Change-Id: Idd489ba129b2a59f8fcf5dd4edf379c3e9fe05aa
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4846817
Reviewed-by: Zhenyao Mo <zmo@chromium.org>
Commit-Queue: Sunny Sachanandani <sunnyps@chromium.org>
Auto-Submit: Sunny Sachanandani <sunnyps@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1194415}
---
 .../service/external_semaphore.cc             |  6 +++---
 ui/gl/gl_bindings.h                           |  8 +++----
 ui/gl/gl_context.cc                           |  9 ++++----
 ui/gl/gl_context_egl.cc                       | 12 ++++++-----
 ui/gl/gl_gl_api_implementation.cc             | 21 +++++++++++++------
 ui/gl/gl_gl_api_implementation.h              |  6 +++++-
 ui/gl/gl_implementation.cc                    |  5 -----
 7 files changed, 39 insertions(+), 28 deletions(-)

--- a/gpu/command_buffer/service/external_semaphore.cc
+++ b/gpu/command_buffer/service/external_semaphore.cc
@@ -152,13 +152,13 @@
   }
 
   if (gl_semaphore_ != 0) {
-    auto* current_gl = gl::GetGlContextForCurrentThread();
-    auto* api = current_gl->Driver ? current_gl->Api.get() : nullptr;
     // We assume there is always one GL context current. If there isn't a
     // GL context current, we assume the last GL context is destroyed, in that
     // case, we will skip glDeleteSemaphoresEXT().
-    if (api)
+    if (gl::g_current_gl_driver) {
+      gl::GLApi* const api = gl::g_current_gl_context;
       api->glDeleteSemaphoresEXTFn(1, &gl_semaphore_);
+    }
   }
 
   context_provider_ = nullptr;
--- a/ui/gl/gl_bindings.h
+++ b/ui/gl/gl_bindings.h
@@ -559,10 +559,10 @@
 #endif
 
 // This #define is here to support autogenerated code.
-#define g_current_gl_context GetGlContextForCurrentThread()->Api.get()
-#define g_current_gl_driver GetGlContextForCurrentThread()->Driver
-#define g_current_gl_version GetGlContextForCurrentThread()->Version.get()
-GL_EXPORT CurrentGL*& GetGlContextForCurrentThread();
+#define g_current_gl_context GetThreadLocalCurrentGL()->Api.get()
+#define g_current_gl_driver GetThreadLocalCurrentGL()->Driver
+#define g_current_gl_version GetThreadLocalCurrentGL()->Version.get()
+GL_EXPORT CurrentGL* GetThreadLocalCurrentGL();
 
 #if defined(USE_EGL)
 GL_EXPORT extern EGLApi* g_current_egl_context;
--- a/ui/gl/gl_context.cc
+++ b/ui/gl/gl_context.cc
@@ -79,7 +79,7 @@
   share_group_->RemoveContext(this);
   if (GetCurrent() == this) {
     SetCurrent(nullptr);
-    SetCurrentGL(nullptr);
+    SetThreadLocalCurrentGL(nullptr);
   }
   base::subtle::Atomic32 after_value =
       base::subtle::NoBarrier_AtomicIncrement(&total_gl_contexts_, -1);
@@ -362,8 +362,9 @@
   // TODO(sievers): Remove this, but needs all gpu_unittest classes
   // to create and make current a context.
   if (!surface && GetGLImplementation() != kGLImplementationMockGL &&
-      GetGLImplementation() != kGLImplementationStubGL)
-    SetCurrentGL(nullptr);
+      GetGLImplementation() != kGLImplementationStubGL) {
+    SetThreadLocalCurrentGL(nullptr);
+  }
 }
 
 void GLContext::SetGLWorkarounds(const GLWorkarounds& workarounds) {
@@ -485,7 +486,7 @@
 }
 
 void GLContext::BindGLApi() {
-  SetCurrentGL(GetCurrentGL());
+  SetThreadLocalCurrentGL(GetCurrentGL());
 }
 
 GLContextReal::GLContextReal(GLShareGroup* share_group)
--- a/ui/gl/gl_context_egl.cc
+++ b/ui/gl/gl_context_egl.cc
@@ -433,9 +433,9 @@
   if (has_backpressure_fences) {
     // If this context is not current, bind this context's API so that the YUV
     // converter can safely destruct
-    GLContext* current_context = GetRealCurrent();
-    if (current_context != this) {
-      SetCurrentGL(GetCurrentGL());
+    GLContext* prev_current_context = GetRealCurrent();
+    if (prev_current_context != this) {
+      SetThreadLocalCurrentGL(GetCurrentGL());
     }
 
     EGLContext current_egl_context = eglGetCurrentContext();
@@ -456,8 +456,10 @@
 #endif
 
     // Rebind the current context's API if needed.
-    if (current_context && current_context != this) {
-      SetCurrentGL(current_context->GetCurrentGL());
+    if (prev_current_context != this) {
+      SetThreadLocalCurrentGL(prev_current_context
+                                  ? prev_current_context->GetCurrentGL()
+                                  : nullptr);
     }
 
     if (context_ != current_egl_context) {
--- a/ui/gl/gl_gl_api_implementation.cc
+++ b/ui/gl/gl_gl_api_implementation.cc
@@ -211,6 +211,20 @@
   g_no_context_current_gl->Api = new NoContextGLApi;
 }
 
+CurrentGL*& ThreadLocalCurrentGL() {
+  thread_local CurrentGL* current_gl = nullptr;
+  return current_gl;
+}
+
+CurrentGL* GetThreadLocalCurrentGL() {
+  // This prevents mutation of the thread local CurrentGL pointer.
+  return ThreadLocalCurrentGL();
+}
+
+void SetThreadLocalCurrentGL(CurrentGL* current) {
+  ThreadLocalCurrentGL() = current ? current : g_no_context_current_gl;
+}
+
 void ClearBindingsGL() {
   if (g_no_context_current_gl) {
     delete g_no_context_current_gl->Api;
@@ -219,8 +233,7 @@
     delete g_no_context_current_gl;
     g_no_context_current_gl = nullptr;
   }
-
-  GetGlContextForCurrentThread() = nullptr;
+  ThreadLocalCurrentGL() = nullptr;
 }
 
 bool SetNullDrawGLBindingsEnabled(bool enabled) {
@@ -233,10 +246,6 @@
   return g_null_draw_bindings_enabled;
 }
 
-void SetCurrentGL(CurrentGL* current) {
-  GetGlContextForCurrentThread() = current ? current : g_no_context_current_gl;
-}
-
 GLApi::GLApi() = default;
 
 GLApi::~GLApi() = default;
--- a/ui/gl/gl_gl_api_implementation.h
+++ b/ui/gl/gl_gl_api_implementation.h
@@ -26,7 +26,11 @@
 bool SetNullDrawGLBindingsEnabled(bool enabled);
 bool GetNullDrawBindingsEnabled();
 
-void SetCurrentGL(CurrentGL* current);
+// This is exported from //ui/gl/gl_bindings.h to retrieve GL bindings.
+GL_EXPORT CurrentGL* GetThreadLocalCurrentGL();
+
+// This is only used internally in //ui/gl to set GL bindings from GLContext.
+void SetThreadLocalCurrentGL(CurrentGL* current);
 
 class GL_EXPORT GLApiBase : public GLApi {
  public:
--- a/ui/gl/gl_implementation.cc
+++ b/ui/gl/gl_implementation.cc
@@ -229,11 +229,6 @@
 
 }  // namespace
 
-CurrentGL*& GetGlContextForCurrentThread() {
-  thread_local CurrentGL* gl_context = nullptr;
-  return gl_context;
-}
-
 #if defined(USE_EGL)
 EGLApi* g_current_egl_context;
 #endif
