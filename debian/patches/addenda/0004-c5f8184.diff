From c5f818404f254453e77be0b0e0eb320fb12c0e4b Mon Sep 17 00:00:00 2001
From: Curtis McMullan <curtismcmullan@chromium.org>
Date: Tue, 19 Dec 2023 21:53:47 +0000
Subject: [PATCH] autocorrect: prevent autocorrect_range being set

This is a chery pick of crrev/c/5124792 into M120.

As noted in the linked bug we are seeing some crashes occurring with the
autocorrect feature in native text fields. The crash is occurring when
the method TextField::GetAutocorrectCharacterBounds is invoked.

Unfortunately, the autocorrect UI is not fully implemented on native
textfields (hence the NOT_IMPLEMENTED in TextField::SetAutocorrectBounds).

This CL mitigates the issue by not setting autocorrect_range_ in
TextField::SetAutocorrectBounds. This prevents the crashy path from
firing in TextField::GetAutocorrectCharacterBounds, and also makes sense
given the TextField::SetAutocorrectBounds is not implemented.

BUG=b:316020486

(cherry picked from commit f20e48b660eb3e561f197301b96de59a71a6da6c)

Change-Id: Ibf25ed9956b4ad9900ef437633b5f740a85f95ec
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5124792
Commit-Queue: Curtis McMullan <curtismcmullan@chromium.org>
Reviewed-by: Scott Violet <sky@chromium.org>
Cr-Original-Commit-Position: refs/heads/main@{#1238757}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5133869
Reviewed-by: Mehrab N <mehrab@chromium.org>
Commit-Queue: Chuong Ho <hdchuong@chromium.org>
Cr-Commit-Position: refs/branch-heads/6099@{#1557}
Cr-Branched-From: e6ee4500f7d6549a9ac1354f8d056da49ef406be-refs/heads/main@{#1217362}
---

--- a/ui/views/controls/textfield/textfield.cc
+++ b/ui/views/controls/textfield/textfield.cc
@@ -1959,42 +1959,25 @@
 
 #if BUILDFLAG(IS_CHROMEOS)
 gfx::Range Textfield::GetAutocorrectRange() const {
-  return model_->autocorrect_range();
+  // TODO(b/316461955): Implement autocorrect UI for native fields.
+  NOTIMPLEMENTED_LOG_ONCE();
+  return gfx::Range();
 }
 
 gfx::Rect Textfield::GetAutocorrectCharacterBounds() const {
-  gfx::Range autocorrect_range = model_->autocorrect_range();
-  if (autocorrect_range.is_empty())
-    return gfx::Rect();
-
-  gfx::RenderText* render_text = GetRenderText();
-  const gfx::SelectionModel caret(autocorrect_range, gfx::CURSOR_BACKWARD);
-  gfx::Rect rect;
-  rect = render_text->GetCursorBounds(caret, false);
-
-  ConvertRectToScreen(this, &rect);
-  return rect;
+  // TODO(b/316461955): Implement autocorrect UI for native fields.
+  NOTIMPLEMENTED_LOG_ONCE();
+  return gfx::Rect();
 }
 
 bool Textfield::SetAutocorrectRange(const gfx::Range& range) {
   if (!range.is_empty()) {
     base::UmaHistogramEnumeration("InputMethod.Assistive.Autocorrect.Count",
                                   TextInputClient::SubClass::kTextField);
-
-#if BUILDFLAG(IS_CHROMEOS_ASH)
-    auto* input_method_manager = ash::input_method::InputMethodManager::Get();
-    if (input_method_manager &&
-        ash::extension_ime_util::IsExperimentalMultilingual(
-            input_method_manager->GetActiveIMEState()
-                ->GetCurrentInputMethod()
-                .id())) {
-      base::UmaHistogramEnumeration(
-          "InputMethod.MultilingualExperiment.Autocorrect.Count",
-          TextInputClient::SubClass::kTextField);
-    }
-#endif
   }
-  return model_->SetAutocorrectRange(range);
+  // TODO(b/316461955): Implement autocorrect UI for native fields.
+  NOTIMPLEMENTED_LOG_ONCE();
+  return false;
 }
 
 bool Textfield::AddGrammarFragments(
--- a/ui/views/controls/textfield/textfield_model.cc
+++ b/ui/views/controls/textfield/textfield_model.cc
@@ -762,21 +762,6 @@
   }
 }
 
-#if BUILDFLAG(IS_CHROMEOS)
-bool TextfieldModel::SetAutocorrectRange(const gfx::Range& range) {
-  if (range.GetMax() > render_text()->text().length()) {
-    return false;
-  }
-  autocorrect_range_ = range;
-
-  // TODO(b/161490813): Update |autocorrect_range_| and show underline.
-  //  Autocorrect range needs to be updated based on user text inputs and an
-  //  underline should be shown for the range.
-  NOTIMPLEMENTED_LOG_ONCE();
-  return false;
-}
-#endif
-
 void TextfieldModel::SetCompositionFromExistingText(const gfx::Range& range) {
   if (range.is_empty() || !gfx::Range(0, text().length()).Contains(range)) {
     ClearComposition();
--- a/ui/views/controls/textfield/textfield_model.h
+++ b/ui/views/controls/textfield/textfield_model.h
@@ -239,16 +239,6 @@
   // composition text.
   void SetCompositionText(const ui::CompositionText& composition);
 
-#if BUILDFLAG(IS_CHROMEOS)
-  // Return the text range corresponding to the autocorrected text.
-  const gfx::Range& autocorrect_range() const { return autocorrect_range_; }
-
-  // Sets the autocorrect range to |range|. If |range| is empty, then the
-  // autocorrect range is cleared. Returns true if the range was set or cleared
-  // successfully.
-  bool SetAutocorrectRange(const gfx::Range& range);
-#endif
-
   // Puts the text in the specified range into composition mode.
   // This method should not be called with composition text or an invalid range.
   // The provided range is checked against the string's length, if |range| is
@@ -340,10 +330,6 @@
 
   gfx::Range composition_range_;
 
-#if BUILDFLAG(IS_CHROMEOS)
-  gfx::Range autocorrect_range_;
-#endif
-
   // The list of Edits. The oldest Edits are at the front of the list, and the
   // newest ones are at the back of the list.
   using EditHistory = std::list<std::unique_ptr<internal::Edit>>;
--- a/ui/views/controls/textfield/textfield_unittest.cc
+++ b/ui/views/controls/textfield/textfield_unittest.cc
@@ -3360,75 +3360,6 @@
   // - rects[6] == rects[7]
 }
 
-#if BUILDFLAG(IS_CHROMEOS_ASH)
-TEST_F(TextfieldTest, SetAutocorrectRange) {
-  InitTextfield();
-
-  textfield_->SetText(u"abc def ghi");
-  textfield_->SetAutocorrectRange(gfx::Range(4, 7));
-
-  gfx::Range autocorrect_range = textfield_->GetAutocorrectRange();
-  EXPECT_EQ(autocorrect_range, gfx::Range(4, 7));
-}
-
-TEST_F(TextfieldTest, DoesNotSetAutocorrectRangeWhenRangeGivenIsInvalid) {
-  InitTextfield();
-
-  textfield_->SetText(u"abc");
-
-  EXPECT_FALSE(textfield_->SetAutocorrectRange(gfx::Range(8, 11)));
-  EXPECT_TRUE(textfield_->GetAutocorrectRange().is_empty());
-}
-
-TEST_F(TextfieldTest,
-       ClearsAutocorrectRangeWhenSetAutocorrectRangeWithEmptyRange) {
-  InitTextfield();
-
-  textfield_->SetText(u"abc");
-
-  // TODO(b/161490813): Change to EXPECT_TRUE after fixing set range.
-  EXPECT_FALSE(textfield_->SetAutocorrectRange(gfx::Range()));
-  EXPECT_TRUE(textfield_->GetAutocorrectRange().is_empty());
-}
-
-TEST_F(TextfieldTest, GetAutocorrectCharacterBoundsTest) {
-  InitTextfield();
-
-  textfield_->InsertText(
-      u"hello placeholder text",
-      ui::TextInputClient::InsertTextCursorBehavior::kMoveCursorAfterText);
-  textfield_->SetAutocorrectRange(gfx::Range(3, 10));
-
-  EXPECT_EQ(textfield_->GetAutocorrectRange(), gfx::Range(3, 10));
-
-  gfx::Rect rect_for_long_text = textfield_->GetAutocorrectCharacterBounds();
-
-  textfield_->clear();
-
-  textfield_->InsertText(
-      u"hello placeholder text",
-      ui::TextInputClient::InsertTextCursorBehavior::kMoveCursorAfterText);
-  textfield_->SetAutocorrectRange(gfx::Range(3, 8));
-
-  EXPECT_EQ(textfield_->GetAutocorrectRange(), gfx::Range(3, 8));
-
-  gfx::Rect rect_for_short_text = textfield_->GetAutocorrectCharacterBounds();
-
-  EXPECT_LT(rect_for_short_text.x(), rect_for_long_text.x());
-  EXPECT_EQ(rect_for_short_text.y(), rect_for_long_text.y());
-  EXPECT_EQ(rect_for_short_text.height(), rect_for_long_text.height());
-  // TODO(crbug.com/1108170): Investigate why the rectangle width is wrong.
-  // The value seems to be wrong due to the incorrect value being returned from
-  // RenderText::GetCursorBounds(). Unfortuantly, that is tricky to fix, since
-  // RenderText is used in other parts of the codebase.
-  // When fixed, the following EXPECT statement should pass.
-  // EXPECT_LT(rect_for_short_text.width(), rect_for_long_text.width());
-}
-
-// TODO(crbug.com/1108170): Add a test to check that when the composition /
-// surrounding text is updated, the AutocorrectRange is updated accordingly.
-#endif  // BUILDFLAG(IS_CHROMEOS_ASH)
-
 // The word we select by double clicking should remain selected regardless of
 // where we drag the mouse afterwards without releasing the left button.
 TEST_F(TextfieldTest, KeepInitiallySelectedWord) {
