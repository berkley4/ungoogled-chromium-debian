From d913e7e91ef61714f7bf36222de2cbd4a5ab36a0 Mon Sep 17 00:00:00 2001
From: Aaron Leventhal <aleventhal@google.com>
Date: Wed, 20 Dec 2023 22:42:45 +0000
Subject: [PATCH] M120: [A11y] Speculative fix for crashes in BlinkAXTreeSource::Freeze()

ProcessDeferredAccessibilityEvents() ensures tha a root object is
created, however there was none after a call. Therefore, it must
have exited early. This adds a new |force| parameter to
ProcessDeferredAccessibilitEvents() to make sure it does the
processing.

Also removes redundant calls to ProcessDeferredAccessibilityEvents().

(cherry picked from commit d2b2cc1ed2702a93f915df1a2fe79b83b63ebc00)

Fixed: 1504555
Change-Id: I8c4ebf71a087e608b03c005cca8976096c1226f5
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5053248
Commit-Queue: Aaron Leventhal <aleventhal@chromium.org>
Reviewed-by: Jacques Newman <janewman@microsoft.com>
Reviewed-by: Chris Harrelson <chrishtr@chromium.org>
Cr-Original-Commit-Position: refs/heads/main@{#1229485}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5141606
Auto-Submit: Aaron Leventhal <aleventhal@chromium.org>
Commit-Queue: Chris Harrelson <chrishtr@chromium.org>
Cr-Commit-Position: refs/branch-heads/6099@{#1573}
Cr-Branched-From: e6ee4500f7d6549a9ac1354f8d056da49ef406be-refs/heads/main@{#1217362}
---

--- a/third_party/blink/renderer/core/accessibility/ax_object_cache.h
+++ b/third_party/blink/renderer/core/accessibility/ax_object_cache.h
@@ -155,7 +155,9 @@
                                           const AtomicString& event_type) = 0;
 
   // Handle any notifications which arrived while layout was dirty.
-  virtual void ProcessDeferredAccessibilityEvents(Document&) = 0;
+  // If |force|, then process regardless of any active batching or pauses.
+  virtual void ProcessDeferredAccessibilityEvents(Document&,
+                                                  bool force = false) = 0;
 
   // Changes to virtual Accessibility Object Model nodes.
   virtual void HandleAttributeChanged(const QualifiedName& attr_name,
--- a/third_party/blink/renderer/core/dom/element.cc
+++ b/third_party/blink/renderer/core/dom/element.cc
@@ -2175,7 +2175,6 @@
   AXContext ax_context(document, ui::kAXModeBasic);
   document.View()->UpdateAllLifecyclePhasesExceptPaint(
       DocumentUpdateReason::kJavaScript);
-  ax_context.GetAXObjectCache().ProcessDeferredAccessibilityEvents(document);
   return ax_context.GetAXObjectCache().ComputedRoleForNode(this);
 }
 
@@ -2194,7 +2193,6 @@
   // Allocating the AXContext needs to not change lifecycle states.
   DCHECK_GE(document.Lifecycle().GetState(), DocumentLifecycle::kPrePaintClean)
       << " State was: " << document.Lifecycle().GetState();
-  ax_context.GetAXObjectCache().ProcessDeferredAccessibilityEvents(document);
   return ax_context.GetAXObjectCache().ComputedRoleForNode(this);
 }
 
@@ -2206,7 +2204,6 @@
   AXContext ax_context(document, ui::kAXModeBasic);
   document.View()->UpdateAllLifecyclePhasesExceptPaint(
       DocumentUpdateReason::kJavaScript);
-  ax_context.GetAXObjectCache().ProcessDeferredAccessibilityEvents(document);
   return ax_context.GetAXObjectCache().ComputedNameForNode(this);
 }
 
@@ -2225,7 +2222,6 @@
   // Allocating the AXContext needs to not change lifecycle states.
   DCHECK_GE(document.Lifecycle().GetState(), DocumentLifecycle::kPrePaintClean)
       << " State was: " << document.Lifecycle().GetState();
-  ax_context.GetAXObjectCache().ProcessDeferredAccessibilityEvents(document);
   return ax_context.GetAXObjectCache().ComputedNameForNode(this);
 }
 
--- a/third_party/blink/renderer/modules/accessibility/ax_object_cache_impl.cc
+++ b/third_party/blink/renderer/modules/accessibility/ax_object_cache_impl.cc
@@ -795,7 +795,7 @@
   if (AXObject* root = SafeGet(document_))
     return root;
 
-  ProcessDeferredAccessibilityEvents(GetDocument());
+  ProcessDeferredAccessibilityEvents(GetDocument(), /*force*/ true);
   return SafeGet(document_.Get());
 }
 
@@ -846,8 +846,7 @@
   // Next flush all accessibility events and dirty objects, for both the main
   // and popup document, and update tree if needed.
   if (IsDirty() || HasDirtyObjects()) {
-    pause_tree_updates_until_more_loaded_content_ = false;
-    ProcessDeferredAccessibilityEvents(GetDocument());
+    ProcessDeferredAccessibilityEvents(GetDocument(), /*force*/ true);
   }
 }
 
@@ -2720,7 +2719,8 @@
 #endif
 }
 
-void AXObjectCacheImpl::ProcessDeferredAccessibilityEvents(Document& document) {
+void AXObjectCacheImpl::ProcessDeferredAccessibilityEvents(Document& document,
+                                                           bool force) {
   if (IsPopup(document)) {
     // Only process popup document together with main document.
     DCHECK_EQ(&document, GetPopupDocumentIfShowing());
@@ -2736,17 +2736,20 @@
   CHECK(!processing_deferred_events_);
 
   if (tree_updates_paused_) {
-    LOG(INFO) << "Accessibility tree updates will be resumed after rebuilding "
-                 "the tree from root";
-    MarkDocumentDirty();
     tree_updates_paused_ = false;
-    return;
+    if (!force) {
+      LOG(INFO)
+          << "Accessibility tree updates will be resumed after rebuilding "
+             "the tree from root";
+      MarkDocumentDirty();
+      return;
+    }
   }
 
   // Don't update the tree at an awkward time during page load.
   // Example: when the last node is whitespace, there is not yet enough context
   // to determine the relevance of the whitespace.
-  if (pause_tree_updates_until_more_loaded_content_) {
+  if (pause_tree_updates_until_more_loaded_content_ && !force) {
     if (IsParsingMainDocument()) {
       return;
     }
@@ -4928,7 +4931,8 @@
 const AtomicString& AXObjectCacheImpl::ComputedRoleForNode(Node* node) {
   // Accessibility tree must be updated before getting an object.
   SCOPED_DISALLOW_LIFECYCLE_TRANSITION();
-  ProcessDeferredAccessibilityEvents(GetDocument());
+  ProcessDeferredAccessibilityEvents(GetDocument(), /*force*/ true);
+  ScopedFreezeAXCache scoped_freeze_cache(*this);
   AXObject* obj = SafeGet(node);
   return AXObject::ARIARoleName(obj ? obj->RoleValue()
                                     : ax::mojom::blink::Role::kUnknown);
@@ -4937,7 +4941,8 @@
 String AXObjectCacheImpl::ComputedNameForNode(Node* node) {
   // Accessibility tree must be updated before getting an object.
   SCOPED_DISALLOW_LIFECYCLE_TRANSITION();
-  ProcessDeferredAccessibilityEvents(GetDocument());
+  ProcessDeferredAccessibilityEvents(GetDocument(), /*force*/ true);
+  ScopedFreezeAXCache scoped_freeze_cache(*this);
   AXObject* obj = SafeGet(node);
   return obj ? obj->ComputedName() : "";
 }
--- a/third_party/blink/renderer/modules/accessibility/ax_object_cache_impl.h
+++ b/third_party/blink/renderer/modules/accessibility/ax_object_cache_impl.h
@@ -285,7 +285,7 @@
 
   void InlineTextBoxesUpdated(LayoutObject*) override;
   // Called during the accessibility lifecycle to refresh the AX tree.
-  void ProcessDeferredAccessibilityEvents(Document&) override;
+  void ProcessDeferredAccessibilityEvents(Document&, bool force) override;
   // Remove AXObject subtrees (once flat tree traversal is safe).
   void ProcessSubtreeRemovals() override;
   // Is there work to be done when layout becomes clean?
