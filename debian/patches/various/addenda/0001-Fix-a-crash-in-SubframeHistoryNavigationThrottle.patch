From 374ac30c4225ab2b8564ac45d6c5612c18b7399f Mon Sep 17 00:00:00 2001
From: Nate Chapin <japhet@chromium.org>
Date: Mon, 15 May 2023 18:24:12 +0000
Subject: [PATCH] [M113] Fix a crash in SubframeHistoryNavigationThrottle

This happens when multiple frames traverse simultaneously, and the main
frame has a navigate event handler that might cancel the navigation.
If an iframe is navigating cross-document and has a slow beforeunload
event handler, it may not attempt to create throttles until after the
main frame traversal has completed. In that case, it will try to get the
main frame NavigationRequest that no longer exists and crash.

(cherry picked from commit 17e648f21a62027df421a63da5add8301b07344f)

Fixed: 1443312
Change-Id: I79b26361128026bf13cbe86c26d4f33749c043d9
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4515156
Reviewed-by: Charlie Reis <creis@chromium.org>
Commit-Queue: Nate Chapin <japhet@chromium.org>
Cr-Original-Commit-Position: refs/heads/main@{#1141473}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4533596
Commit-Queue: Charlie Reis <creis@chromium.org>
Auto-Submit: Nate Chapin <japhet@chromium.org>
Cr-Commit-Position: refs/branch-heads/5672@{#1209}
Cr-Branched-From: 5f2a72468eda1eb945b3b5a2298b5d1cd678521e-refs/heads/main@{#1121455}
---

--- a/content/browser/renderer_host/navigation_request.h
+++ b/content/browser/renderer_host/navigation_request.h
@@ -1117,7 +1117,10 @@
 
   // For subframe NavigationRequests, these set and return the main frame's
   // NavigationRequest token, in the case that the main frame returns it from
-  // GetNavigationTokenForDeferringSubframes().
+  // GetNavigationTokenForDeferringSubframes(). Note that by the time
+  // `main_frame_same_document_history_token()` is called, the NavigationRequest
+  // represented by that token may have already finished and been deleted, so
+  // any attempt to lookup based on this token must null-check the request.
   void set_main_frame_same_document_history_token(
       absl::optional<base::UnguessableToken> token) {
     main_frame_same_document_navigation_token_ = token;
--- a/content/browser/renderer_host/subframe_history_navigation_throttle.cc
+++ b/content/browser/renderer_host/subframe_history_navigation_throttle.cc
@@ -63,7 +63,12 @@
       request->frame_tree_node()->frame_tree().root()->current_frame_host();
   NavigationRequest* root_frame_navigation_request =
       root_frame_host->GetSameDocumentNavigationRequest(*main_frame_token);
-  DCHECK(root_frame_navigation_request);
+  // If the main-frame same-document history navigation already completed, the
+  // throttle is no longer necessary. This can happen when `request` is
+  // cross-document and had to wait on a slow beforeunload handler.
+  if (!root_frame_navigation_request) {
+    return nullptr;
+  }
   auto throttle = std::make_unique<SubframeHistoryNavigationThrottle>(request);
   root_frame_navigation_request->AddDeferredSubframeNavigationThrottle(
       throttle->weak_factory_.GetWeakPtr());
--- /dev/null
+++ b/third_party/blink/web_tests/fast/loader/slow-back-beforeunload-in-iframe.html
@@ -0,0 +1,35 @@
+<!DOCTYPE html>
+<script src="../../resources/testharness.js"></script>
+<script src="../../resources/testharnessreport.js"></script>
+<iframe id="i" src="resources/empty.html"></iframe>
+<script>
+promise_test(async t => {
+  // Wait for onload so push navigations don't get converted to replace.
+  await new Promise(r => window.onload = () => t.step_timeout(r, 0));
+
+  await navigation.navigate("#forward").finished;
+  i.contentWindow.navigation.navigate("empty.html?forward");
+  await new Promise(r => i.onload = r);
+
+  navigation.onnavigate = () => {
+    // Dummy so that the browser process knows there's a navigate event handler.
+  }
+  // Now navigate both windows back. The main frame will navigate
+  // same-document quickly, but the cross-document iframe navigation will
+  // stall on this slow beforeunload handler. The browser process shouldn't
+  // crash when the iframe cross-document navigation returns to the browser
+  // when beforeunload completes.
+  i.contentWindow.onbeforeunload = () => {
+    let end = performance.now() + 20;
+    let dummy = 0;
+    while (performance.now() < end) {
+      dummy++;
+    }
+  }
+  let main_frame_finished_promise = navigation.back().finished;
+
+  // Both windows should successfully navigate.
+  await new Promise(r => i.onload = r);
+  await main_frame_finished_promise;
+});
+</script>
