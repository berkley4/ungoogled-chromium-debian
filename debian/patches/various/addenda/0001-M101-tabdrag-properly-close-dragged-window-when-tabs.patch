From 2b286b190a4f9458c65dfd9593cf89660ee773ae Mon Sep 17 00:00:00 2001
From: Nick Diego Yamane <nickdiego@igalia.com>
Date: Mon, 25 Apr 2022 22:03:45 +0000
Subject: [PATCH] [M101] tabdrag: properly close dragged window when tabstrip
 is getting empty
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

As of crrev.com/c/3465738, the browser window closing/destruction is no
longer done using a posted task, instead it is called right away upon
"tab strip empty" event. It turns out that, at that point, Widget::Close
call will no-op due to TabStrip::IsTabstripCloseable() returns false,
cause the drag session is still active, waiting for the nested move loop
to finish.

The side-effect is described in the linked crbug, and probably several
other related subtle issues. This fixes it by adding including the
above described state to the list of conditions that allow the tab strip
to be closed.

R=â€‹sky

(cherry picked from commit 24e8eac41d4067ff2e28c270c3e85ed3446ff36e)

Bug: 1309461, 1297099, 1308968
Test: Interactive UI test 'DetachToBrowserTabDragControllerTest.DeleteTabsWhileDetached'
Change-Id: I7df5fb120e08f8dc0566009dbf89051bd0b769e3
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3578084
Reviewed-by: Scott Violet <sky@chromium.org>
Commit-Queue: Nick Yamane <nickdiego@igalia.com>
Cr-Original-Commit-Position: refs/heads/main@{#991591}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3601759
Auto-Submit: Nick Yamane <nickdiego@igalia.com>
Cr-Commit-Position: refs/branch-heads/4951@{#1043}
Cr-Branched-From: 27de6227ca357da0d57ae2c7b18da170c4651438-refs/heads/main@{#982481}
---
 .../ui/views/tabs/tab_drag_controller.h       |  6 +++
 .../tab_drag_controller_interactive_uitest.cc | 46 +++++++++----------
 chrome/browser/ui/views/tabs/tab_strip.cc     |  5 +-
 3 files changed, 31 insertions(+), 26 deletions(-)

--- a/chrome/browser/ui/views/tabs/tab_drag_controller.h
+++ b/chrome/browser/ui/views/tabs/tab_drag_controller.h
@@ -127,6 +127,12 @@
     return current_state_ == DragState::kDraggingWindow;
   }
 
+  // Returns true if the nested move loop end was requested and we are waiting
+  // it to actually happen.
+  bool is_waiting_to_stop() const {
+    return current_state_ == DragState::kWaitingToStop;
+  }
+
   // Returns the tab group being dragged, if any. Will only return a value if
   // the user is dragging a tab group header, not an individual tab or tabs from
   // a group.
--- a/chrome/browser/ui/views/tabs/tab_drag_controller_interactive_uitest.cc
+++ b/chrome/browser/ui/views/tabs/tab_drag_controller_interactive_uitest.cc
@@ -1930,21 +1930,8 @@
   EXPECT_FALSE(GetIsDragged(browser()));
 }
 
-namespace {
-
-void CloseTabsWhileDetachedStep2(const BrowserList* browser_list) {
-  ASSERT_EQ(2u, browser_list->size());
-  Browser* old_browser = browser_list->get(0);
-  EXPECT_EQ("0 3", IDString(old_browser->tab_strip_model()));
-  Browser* new_browser = browser_list->get(1);
-  EXPECT_EQ("1 2", IDString(new_browser->tab_strip_model()));
-  chrome::CloseTab(new_browser);
-}
-
-}  // namespace
-
-// Selects 2 tabs out of 4, drags them out and closes the new browser window
-// while dragging tabs.
+// Selects 1 tab out of 4, drags it out and closes the new browser window while
+// dragging.
 #if (BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC))
 // TODO(crbug.com/1031801) Test is flaky on Windows and Mac.
 #define MAYBE_DeleteTabsWhileDetached DISABLED_DeleteTabsWhileDetached
@@ -1957,23 +1944,32 @@
   TabStrip* tab_strip = GetTabStripForBrowser(browser());
   EXPECT_EQ("0 1 2 3", IDString(browser()->tab_strip_model()));
 
-  // Click the first tab and select two middle tabs.
-  ASSERT_TRUE(PressInput(GetCenterInScreenCoordinates(tab_strip->tab_at(1))));
-  ASSERT_TRUE(ReleaseInput());
-  browser()->tab_strip_model()->ToggleSelectionAt(2);
-
-  // Press mouse button in the second tab and drag it enough to detach.
+  // Drag the third tab out of its browser window, request to close the detached
+  // tab and verify its owning window gets properly closed.
   DragTabAndNotify(
-      tab_strip, base::BindOnce(&CloseTabsWhileDetachedStep2, browser_list), 2);
+      tab_strip, base::BindLambdaForTesting([&]() {
+        ASSERT_EQ(2u, browser_list->size());
+        Browser* old_browser = browser_list->get(0);
+        EXPECT_EQ("0 1 3", IDString(old_browser->tab_strip_model()));
+        Browser* new_browser = browser_list->get(1);
+        EXPECT_EQ("2", IDString(new_browser->tab_strip_model()));
+        chrome::CloseTab(new_browser);
+        // Ensure that the newly created tab strip is "closeable" just after
+        // requesting to close it, even if we are still waiting for the nested
+        // move loop to exit. Regression test for https://crbug.com/1309461.
+        EXPECT_TRUE(GetTabStripForBrowser(new_browser)->IsTabStripCloseable());
+      }),
+      2);
 
-  // Should not be dragging.
+  // Should no longer be dragging.
   ASSERT_EQ(1u, browser_list->size());
   ASSERT_FALSE(tab_strip->GetDragContext()->IsDragSessionActive());
   ASSERT_FALSE(TabDragController::IsActive());
 
-  // Both tabs "1" and "2" get closed.
-  EXPECT_EQ("0 3", IDString(browser()->tab_strip_model()));
+  // Dragged out tab (and its owning window) should get closed.
+  EXPECT_EQ("0 1 3", IDString(browser()->tab_strip_model()));
 
+  // No longer dragging.
   EXPECT_FALSE(GetIsDragged(browser()));
 }
 
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -258,8 +258,11 @@
     // . The user is not actively dragging the tabstrip.
     // . In the process of reverting the drag, and the last tab is being
     //   removed (so that it can be inserted back into the source tabstrip).
+    // . In the process of ending the drag session's move loop. E.g: the dragged
+    //   window asks to close itself via window.close() JS API.
     return !IsDragSessionActive() ||
-           drag_controller_->IsRemovingLastTabForRevert();
+           drag_controller_->IsRemovingLastTabForRevert() ||
+           drag_controller_->is_waiting_to_stop();
   }
 
   // TabDragContext:
