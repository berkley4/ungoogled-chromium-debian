From e723feee85488cfdce0187deda94f0ea3ff96fbd Mon Sep 17 00:00:00 2001
From: Andrew Rayskiy <greengrape@google.com>
Date: Wed, 16 Mar 2022 01:57:40 +0000
Subject: [PATCH] [M99] Store TCPConnectedSocketOptionsPtr as class member
 instead of moving it through base::Passed.

(cherry picked from commit 959a79957020de6c922ccec240b7f887df253a0e)

Bug: 1305409
Change-Id: Ia856ea437443437500f8719eab1188a00132f7c7
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3525236
Reviewed-by: Matt Menke <mmenke@chromium.org>
Commit-Queue: Andrew Rayskiy <greengrape@google.com>
Commit-Queue: Joel Hockey <joelhockey@chromium.org>
Cr-Commit-Position: refs/branch-heads/4844@{#1073}
Cr-Branched-From: 007241ce2e6c8e5a7b306cc36c730cd07cd38825-refs/heads/main@{#961656}
---
 net/base/address_list.cc                 |   3 +
 net/base/address_list.h                  |   3 +
 net/socket/socket_test_util.cc           | 110 +++++++++++------------
 net/socket/socket_test_util.h            |  20 ++---
 services/network/tcp_connected_socket.cc |   8 +-
 services/network/tcp_connected_socket.h  |   2 +
 services/network/tcp_socket_unittest.cc  |  52 ++++++++++-
 7 files changed, 124 insertions(+), 74 deletions(-)

--- a/net/base/address_list.cc
+++ b/net/base/address_list.cc
@@ -41,6 +41,9 @@
   push_back(endpoint);
 }
 
+AddressList::AddressList(std::vector<IPEndPoint> endpoints)
+    : endpoints_(std::move(endpoints)) {}
+
 // static
 AddressList AddressList::CreateFromIPAddress(const IPAddress& address,
                                              uint16_t port) {
--- a/net/base/address_list.h
+++ b/net/base/address_list.h
@@ -40,6 +40,9 @@
   // Creates an address list for a single IP literal and a list of DNS aliases.
   AddressList(const IPEndPoint& endpoint, std::vector<std::string> aliases);
 
+  // Creates an address list for a list of IP endpoints.
+  explicit AddressList(std::vector<IPEndPoint> endpoints);
+
   static AddressList CreateFromIPAddress(const IPAddress& address,
                                          uint16_t port);
 
--- a/net/socket/socket_test_util.cc
+++ b/net/socket/socket_test_util.cc
@@ -85,47 +85,32 @@
   } else {
     int i;
     for (i = 0; i <= (data_len - 4); i += 4) {
-      DVLOG(1) << pfx
-               << AsciifyHigh(data[i + 0]) << AsciifyLow(data[i + 0])
+      DVLOG(1) << pfx << AsciifyHigh(data[i + 0]) << AsciifyLow(data[i + 0])
                << AsciifyHigh(data[i + 1]) << AsciifyLow(data[i + 1])
                << AsciifyHigh(data[i + 2]) << AsciifyLow(data[i + 2])
-               << AsciifyHigh(data[i + 3]) << AsciifyLow(data[i + 3])
-               << "  '"
-               << Asciify(data[i + 0])
-               << Asciify(data[i + 1])
-               << Asciify(data[i + 2])
-               << Asciify(data[i + 3])
-               << "'";
+               << AsciifyHigh(data[i + 3]) << AsciifyLow(data[i + 3]) << "  '"
+               << Asciify(data[i + 0]) << Asciify(data[i + 1])
+               << Asciify(data[i + 2]) << Asciify(data[i + 3]) << "'";
       pfx = "         ";
     }
     // Take care of any 'trailing' bytes, if data_len was not a multiple of 4.
     switch (data_len - i) {
       case 3:
-        DVLOG(1) << pfx
-                 << AsciifyHigh(data[i + 0]) << AsciifyLow(data[i + 0])
+        DVLOG(1) << pfx << AsciifyHigh(data[i + 0]) << AsciifyLow(data[i + 0])
                  << AsciifyHigh(data[i + 1]) << AsciifyLow(data[i + 1])
                  << AsciifyHigh(data[i + 2]) << AsciifyLow(data[i + 2])
-                 << "    '"
-                 << Asciify(data[i + 0])
-                 << Asciify(data[i + 1])
-                 << Asciify(data[i + 2])
-                 << " '";
+                 << "    '" << Asciify(data[i + 0]) << Asciify(data[i + 1])
+                 << Asciify(data[i + 2]) << " '";
         break;
       case 2:
-        DVLOG(1) << pfx
-                 << AsciifyHigh(data[i + 0]) << AsciifyLow(data[i + 0])
+        DVLOG(1) << pfx << AsciifyHigh(data[i + 0]) << AsciifyLow(data[i + 0])
                  << AsciifyHigh(data[i + 1]) << AsciifyLow(data[i + 1])
-                 << "      '"
-                 << Asciify(data[i + 0])
-                 << Asciify(data[i + 1])
+                 << "      '" << Asciify(data[i + 0]) << Asciify(data[i + 1])
                  << "  '";
         break;
       case 1:
-        DVLOG(1) << pfx
-                 << AsciifyHigh(data[i + 0]) << AsciifyLow(data[i + 0])
-                 << "        '"
-                 << Asciify(data[i + 0])
-                 << "   '";
+        DVLOG(1) << pfx << AsciifyHigh(data[i + 0]) << AsciifyLow(data[i + 0])
+                 << "        '" << Asciify(data[i + 0]) << "   '";
         break;
     }
   }
@@ -135,8 +120,7 @@
 void DumpMockReadWrite(const MockReadWrite<type>& r) {
   if (logging::LOG_INFO < logging::GetMinLogLevel())
     return;
-  DVLOG(1) << "Async:   " << (r.mode == ASYNC)
-           << "\nResult:  " << r.result;
+  DVLOG(1) << "Async:   " << (r.mode == ASYNC) << "\nResult:  " << r.result;
   DumpData(r.data, r.data_len);
   const char* stop = (r.sequence_number & MockRead::STOPLOOP) ? " (STOP)" : "";
   DVLOG(1) << "Stage:   " << (r.sequence_number & ~MockRead::STOPLOOP) << stop;
@@ -158,11 +142,17 @@
   peer_addr = IPEndPoint(IPAddress(192, 0, 2, 33), 0);
 }
 
-MockConnect::MockConnect(IoMode io_mode, int r, IPEndPoint addr) :
-    mode(io_mode),
-    result(r),
-    peer_addr(addr) {
-}
+MockConnect::MockConnect(IoMode io_mode, int r, IPEndPoint addr)
+    : mode(io_mode), result(r), peer_addr(addr) {}
+
+MockConnect::MockConnect(IoMode io_mode,
+                         int r,
+                         IPEndPoint addr,
+                         bool first_attempt_fails)
+    : mode(io_mode),
+      result(r),
+      peer_addr(addr),
+      first_attempt_fails(first_attempt_fails) {}
 
 MockConnect::~MockConnect() = default;
 
@@ -378,8 +368,8 @@
         next_read->sequence_number == next_sequence_number) {
       // Check if this is a pause.
       if (next_read->mode == ASYNC && next_read->result == ERR_IO_PENDING) {
-        CHECK(!last_event_was_pause) << "Two pauses in a row are not allowed: "
-                                     << next_sequence_number;
+        CHECK(!last_event_was_pause)
+            << "Two pauses in a row are not allowed: " << next_sequence_number;
         last_event_was_pause = true;
       } else if (last_event_was_pause) {
         CHECK_EQ(ASYNC, next_read->mode)
@@ -399,8 +389,8 @@
         next_write->sequence_number == next_sequence_number) {
       // Check if this is a pause.
       if (next_write->mode == ASYNC && next_write->result == ERR_IO_PENDING) {
-        CHECK(!last_event_was_pause) << "Two pauses in a row are not allowed: "
-                                     << next_sequence_number;
+        CHECK(!last_event_was_pause)
+            << "Two pauses in a row are not allowed: " << next_sequence_number;
         last_event_was_pause = true;
       } else if (last_event_was_pause) {
         CHECK_EQ(ASYNC, next_write->mode)
@@ -1095,11 +1085,17 @@
   connected_ = true;
 
   if (before_connect_callback_) {
-    int result = before_connect_callback_.Run();
-    DCHECK_NE(result, ERR_IO_PENDING);
-    if (result != net::OK) {
-      connected_ = false;
-      return result;
+    for (size_t index = 0; index < addresses_.size(); index++) {
+      int result = before_connect_callback_.Run();
+      if (data_->connect_data().first_attempt_fails && index == 0) {
+        continue;
+      }
+      DCHECK_NE(result, ERR_IO_PENDING);
+      if (result != net::OK) {
+        connected_ = false;
+        return result;
+      }
+      break;
     }
   }
 
@@ -1148,7 +1144,12 @@
   if (addresses_.empty())
     return MockClientSocket::GetPeerAddress(address);
 
-  *address = addresses_[0];
+  if (data_->connect_data().first_attempt_fails) {
+    DCHECK_GE(addresses_.size(), 2U);
+    *address = addresses_[1];
+  } else {
+    *address = addresses_[0];
+  }
   return OK;
 }
 
@@ -1469,8 +1470,7 @@
     SSLCertRequestInfo* cert_request_info) const {
   DCHECK(cert_request_info);
   if (data_->cert_request_info) {
-    cert_request_info->host_and_port =
-        data_->cert_request_info->host_and_port;
+    cert_request_info->host_and_port = data_->cert_request_info->host_and_port;
     cert_request_info->is_proxy = data_->cert_request_info->is_proxy;
     cert_request_info->cert_authorities =
         data_->cert_request_info->cert_authorities;
@@ -2212,19 +2212,19 @@
 const char kSOCKS5TestHost[] = "host";
 const int kSOCKS5TestPort = 80;
 
-const char kSOCKS5GreetRequest[] = { 0x05, 0x01, 0x00 };
-const int kSOCKS5GreetRequestLength = base::size(kSOCKS5GreetRequest);
+const char kSOCKS5GreetRequest[] = {0x05, 0x01, 0x00};
+const int kSOCKS5GreetRequestLength = std::size(kSOCKS5GreetRequest);
 
-const char kSOCKS5GreetResponse[] = { 0x05, 0x00 };
-const int kSOCKS5GreetResponseLength = base::size(kSOCKS5GreetResponse);
+const char kSOCKS5GreetResponse[] = {0x05, 0x00};
+const int kSOCKS5GreetResponseLength = std::size(kSOCKS5GreetResponse);
 
-const char kSOCKS5OkRequest[] =
-    { 0x05, 0x01, 0x00, 0x03, 0x04, 'h', 'o', 's', 't', 0x00, 0x50 };
-const int kSOCKS5OkRequestLength = base::size(kSOCKS5OkRequest);
-
-const char kSOCKS5OkResponse[] =
-    { 0x05, 0x00, 0x00, 0x01, 127, 0, 0, 1, 0x00, 0x50 };
-const int kSOCKS5OkResponseLength = base::size(kSOCKS5OkResponse);
+const char kSOCKS5OkRequest[] = {0x05, 0x01, 0x00, 0x03, 0x04, 'h',
+                                 'o',  's',  't',  0x00, 0x50};
+const int kSOCKS5OkRequestLength = std::size(kSOCKS5OkRequest);
+
+const char kSOCKS5OkResponse[] = {0x05, 0x00, 0x00, 0x01, 127,
+                                  0,    0,    1,    0x00, 0x50};
+const int kSOCKS5OkResponseLength = std::size(kSOCKS5OkResponse);
 
 int64_t CountReadBytes(base::span<const MockRead> reads) {
   int64_t total = 0;
--- a/net/socket/socket_test_util.h
+++ b/net/socket/socket_test_util.h
@@ -73,10 +73,7 @@
 class SSLClientSocket;
 class StreamSocket;
 
-enum IoMode {
-  ASYNC,
-  SYNCHRONOUS
-};
+enum IoMode { ASYNC, SYNCHRONOUS };
 
 struct MockConnect {
   // Asynchronous connection success.
@@ -87,11 +84,13 @@
   // |peer_addr| 192.0.2.33.
   MockConnect(IoMode io_mode, int r);
   MockConnect(IoMode io_mode, int r, IPEndPoint addr);
+  MockConnect(IoMode io_mode, int r, IPEndPoint addr, bool first_attempt_fails);
   ~MockConnect();
 
   IoMode mode;
   int result;
   IPEndPoint peer_addr;
+  bool first_attempt_fails = false;
 };
 
 struct MockConfirm {
@@ -117,17 +116,12 @@
 // is the data returned from the socket when MockTCPClientSocket::Read() is
 // attempted, while |data| in MockWrite is the expected data that should be
 // given in MockTCPClientSocket::Write().
-enum MockReadWriteType {
-  MOCK_READ,
-  MOCK_WRITE
-};
+enum MockReadWriteType { MOCK_READ, MOCK_WRITE };
 
 template <MockReadWriteType type>
 struct MockReadWrite {
   // Flag to indicate that the message loop should be terminated.
-  enum {
-    STOPLOOP = 1 << 31
-  };
+  enum { STOPLOOP = 1 << 31 };
 
   // Default
   MockReadWrite()
@@ -201,8 +195,8 @@
   // For data providers that only allows reads to occur in a particular
   // sequence.  If a read occurs before the given |sequence_number| is reached,
   // an ERR_IO_PENDING is returned.
-  int sequence_number;    // The sequence number at which a read is allowed
-                          // to occur.
+  int sequence_number;  // The sequence number at which a read is allowed
+                        // to occur.
 };
 
 typedef MockReadWrite<MOCK_READ> MockRead;
--- a/services/network/tcp_connected_socket.cc
+++ b/services/network/tcp_connected_socket.cc
@@ -32,7 +32,7 @@
 // (TCPSocket::SetDefaultOptionsForClient()).
 int ConfigureSocket(
     net::TransportClientSocket* socket,
-    const mojom::TCPConnectedSocketOptionsPtr tcp_connected_socket_options) {
+    const mojom::TCPConnectedSocketOptions* tcp_connected_socket_options) {
   int send_buffer_size =
       ClampTCPBufferSize(tcp_connected_socket_options->send_buffer_size);
   if (send_buffer_size > 0) {
@@ -154,9 +154,9 @@
   connect_callback_ = std::move(callback);
 
   if (tcp_connected_socket_options) {
-    socket_->SetBeforeConnectCallback(
-        base::BindRepeating(&ConfigureSocket, socket_.get(),
-                            base::Passed(&tcp_connected_socket_options)));
+    socket_options_ = std::move(tcp_connected_socket_options);
+    socket_->SetBeforeConnectCallback(base::BindRepeating(
+        &ConfigureSocket, socket_.get(), socket_options_.get()));
   }
   int result = socket_->Connect(base::BindOnce(
       &TCPConnectedSocket::OnConnectCompleted, base::Unretained(this)));
--- a/services/network/tcp_connected_socket.h
+++ b/services/network/tcp_connected_socket.h
@@ -116,6 +116,8 @@
 
   mojom::NetworkContext::CreateTCPConnectedSocketCallback connect_callback_;
 
+  mojom::TCPConnectedSocketOptionsPtr socket_options_;
+
   base::OnceClosure pending_upgrade_to_tls_callback_;
 
   std::unique_ptr<SocketDataPump> socket_data_pump_;
--- a/services/network/tcp_socket_unittest.cc
+++ b/services/network/tcp_socket_unittest.cc
@@ -336,7 +336,21 @@
       mojo::ScopedDataPipeProducerHandle* send_pipe_handle_out,
       mojom::TCPConnectedSocketOptionsPtr tcp_connected_socket_options =
           nullptr) {
-    net::AddressList remote_addr_list(remote_addr);
+    return CreateTCPConnectedSocketSync(
+        std::move(receiver), std::move(observer), local_addr,
+        net::AddressList(remote_addr), receive_pipe_handle_out,
+        send_pipe_handle_out, std::move(tcp_connected_socket_options));
+  }
+
+  int CreateTCPConnectedSocketSync(
+      mojo::PendingReceiver<mojom::TCPConnectedSocket> receiver,
+      mojo::PendingRemote<mojom::SocketObserver> observer,
+      const absl::optional<net::IPEndPoint>& local_addr,
+      const net::AddressList& remote_addr_list,
+      mojo::ScopedDataPipeConsumerHandle* receive_pipe_handle_out,
+      mojo::ScopedDataPipeProducerHandle* send_pipe_handle_out,
+      mojom::TCPConnectedSocketOptionsPtr tcp_connected_socket_options =
+          nullptr) {
     base::RunLoop run_loop;
     int net_error = net::ERR_FAILED;
     factory_->CreateTCPConnectedSocket(
@@ -351,7 +365,9 @@
               net_error = result;
               if (result == net::OK) {
                 EXPECT_NE(0, actual_local_addr.value().port());
-                EXPECT_EQ(remote_addr, peer_addr.value());
+                if (remote_addr_list.size() == 1) {
+                  EXPECT_EQ(remote_addr_list.front(), peer_addr.value());
+                }
               }
               *receive_pipe_handle_out = std::move(receive_pipe_handle);
               *send_pipe_handle_out = std::move(send_pipe_handle);
@@ -1189,6 +1205,38 @@
   }
 }
 
+// Simulates the initial connection attempt failing, followed by another
+// attempt. Used to simulate cases where the BeforeConnectionCallback is
+// invoked multiple times.
+TEST_P(TCPSocketWithMockSocketTest,
+       InitialTCPConnectedSocketSucceedsOnSecondAttempt) {
+  net::IPEndPoint server_addr_a(net::IPAddress::IPv4Localhost(), 1234);
+  net::IPEndPoint server_addr_b(net::IPAddress::IPv4Localhost(), 1235);
+
+  mojo::ScopedDataPipeConsumerHandle client_socket_receive_handle;
+  mojo::ScopedDataPipeProducerHandle client_socket_send_handle;
+
+  mojo::Remote<mojom::TCPConnectedSocket> client_socket;
+  net::StaticSocketDataProvider data_provider;
+  data_provider.set_connect_data(net::MockConnect(
+      GetParam(), net::OK, server_addr_b, /*first_attempt_fails=*/true));
+
+  mock_client_socket_factory_.AddSocketDataProvider(&data_provider);
+
+  mojom::TCPConnectedSocketOptionsPtr tcp_connected_socket_options =
+      mojom::TCPConnectedSocketOptions::New();
+  tcp_connected_socket_options->receive_buffer_size = 1;
+  tcp_connected_socket_options->send_buffer_size = 2;
+
+  EXPECT_EQ(net::OK,
+            CreateTCPConnectedSocketSync(
+                client_socket.BindNewPipeAndPassReceiver(),
+                mojo::NullRemote() /*observer*/, absl::nullopt /*local_addr*/,
+                net::AddressList({server_addr_a, server_addr_b}),
+                &client_socket_receive_handle, &client_socket_send_handle,
+                std::move(tcp_connected_socket_options)));
+}
+
 TEST_P(TCPSocketWithMockSocketTest, SetBufferSizes) {
   typedef struct {
     int passed_buffer_size;
