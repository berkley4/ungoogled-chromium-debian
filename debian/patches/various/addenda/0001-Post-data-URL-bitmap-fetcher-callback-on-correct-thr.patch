From d470ac429a7304e85554b1b2c5ee0ee8a65f958f Mon Sep 17 00:00:00 2001
From: Toni Barzic <tbarzic@chromium.org>
Date: Tue, 29 Mar 2022 05:06:12 +0000
Subject: [PATCH] Post data URL bitmap fetcher callback on correct thread

Bitmap fetcher forces async responses when the result can be calculated
synchronously (for data URLs). This fixes the thread on which the
response is posted - the task should be posted to the current sequenced
task runner, and no thread pool. I assume this was result of unintuitive
API for posting tasks to thread pool (which was named so it was easily
mistaken for API that posts to the current thread).

BUG=1300329, 1303223

(cherry picked from commit 275ad2cad7610166e4936f957d92b241a2c6b26f)

Change-Id: I38b06885afebba5c9f48239b0a2e3dcf768ff5c2
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3485002
Reviewed-by: Tommy Li <tommycli@chromium.org>
Commit-Queue: Toni Barzic <tbarzic@chromium.org>
Cr-Original-Commit-Position: refs/heads/main@{#974430}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3556736
Reviewed-by: Luciano Pacheco <lucmult@chromium.org>
Owners-Override: Luciano Pacheco <lucmult@chromium.org>
Cr-Commit-Position: refs/branch-heads/4896@{#946}
Cr-Branched-From: 1f63ff4bc27570761b35ffbc7f938f6586f7bee8-refs/heads/main@{#972766}
---
 .../browser/bitmap_fetcher/bitmap_fetcher.cc  |  4 +-
 .../bitmap_fetcher_browsertest.cc             | 42 ++++++++++++++++---
 2 files changed, 38 insertions(+), 8 deletions(-)

--- a/chrome/browser/bitmap_fetcher/bitmap_fetcher.cc
+++ b/chrome/browser/bitmap_fetcher/bitmap_fetcher.cc
@@ -6,7 +6,7 @@
 
 #include "base/bind.h"
 #include "base/metrics/histogram_macros.h"
-#include "base/task/thread_pool.h"
+#include "base/threading/sequenced_task_runner_handle.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/storage_partition.h"
@@ -65,7 +65,7 @@
     start_time_ = base::TimeTicks();
     // Post a task to maintain our guarantee that the delegate will only be
     // called asynchronously.
-    base::ThreadPool::PostTask(
+    base::SequencedTaskRunnerHandle::Get()->PostTask(
         FROM_HERE, BindOnce(std::move(callback), std::move(response_body)));
     return;
   }
--- a/chrome/browser/bitmap_fetcher/bitmap_fetcher_browsertest.cc
+++ b/chrome/browser/bitmap_fetcher/bitmap_fetcher_browsertest.cc
@@ -40,14 +40,13 @@
 // Class to catch events from the BitmapFetcher for testing.
 class BitmapFetcherTestDelegate : public BitmapFetcherDelegate {
  public:
-  explicit BitmapFetcherTestDelegate(bool async)
-      : called_(false), success_(false), async_(async) {}
+  explicit BitmapFetcherTestDelegate(bool async) : async_(async) {}
 
   BitmapFetcherTestDelegate(const BitmapFetcherTestDelegate&) = delete;
   BitmapFetcherTestDelegate& operator=(const BitmapFetcherTestDelegate&) =
       delete;
 
-  ~BitmapFetcherTestDelegate() override { EXPECT_TRUE(called_); }
+  ~BitmapFetcherTestDelegate() override { EXPECT_EQ(expect_called_, called_); }
 
   // Method inherited from BitmapFetcherDelegate.
   void OnFetchComplete(const GURL& url, const SkBitmap* bitmap) override {
@@ -76,12 +75,15 @@
   bool success() const { return success_; }
   const SkBitmap& bitmap() const { return bitmap_; }
 
+  void SetExpectNotToGetCalled() { expect_called_ = false; }
+
  private:
   base::RunLoop run_loop_;
-  bool called_;
+  bool called_ = false;
+  bool expect_called_ = true;
   GURL url_;
-  bool success_;
-  bool async_;
+  bool success_ = false;
+  const bool async_;
   SkBitmap bitmap_;
 };
 
@@ -275,6 +277,34 @@
   EXPECT_TRUE(gfx::BitmapsAreEqual(test_bitmap(), delegate.bitmap()));
 }
 
+// Verifies that bitmap fetch callback gets canceled gracefully when the fetcher
+// gets deleted.
+IN_PROC_BROWSER_TEST_F(BitmapFetcherBrowserTest,
+                       FetcherDeletedBeforeDataURLImageResponse) {
+  // This is test_bitmap() in data: URL form.
+  GURL url(
+      "data:image/"
+      "png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAFElEQVQYlWNk+"
+      "M/wn4GBgYGJAQoAHhgCAh6X4CYAAAAASUVORK5CYII=");
+
+  BitmapFetcherTestDelegate delegate(kAsyncCall);
+  delegate.SetExpectNotToGetCalled();
+  {
+    BitmapFetcher fetcher(url, &delegate, TRAFFIC_ANNOTATION_FOR_TESTS);
+
+    fetcher.Init(
+        net::ReferrerPolicy::REDUCE_GRANULARITY_ON_TRANSITION_CROSS_ORIGIN,
+        network::mojom::CredentialsMode::kInclude);
+    fetcher.Start(browser()
+                      ->profile()
+                      ->GetDefaultStoragePartition()
+                      ->GetURLLoaderFactoryForBrowserProcess()
+                      .get());
+  }
+
+  EXPECT_FALSE(delegate.success());
+}
+
 class BitmapFetcherInitiatorBrowserTest : public InProcessBrowserTest {
  public:
   // InProcessBrowserTest:
