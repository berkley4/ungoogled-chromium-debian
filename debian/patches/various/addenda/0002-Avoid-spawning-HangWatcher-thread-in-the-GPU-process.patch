From 3793f15c640775366390ea5115ed9d5a665b9931 Mon Sep 17 00:00:00 2001
From: Etienne Bergeron <etienneb@chromium.org>
Date: Thu, 31 Mar 2022 20:34:20 +0000
Subject: [PATCH] Avoid spawning HangWatcher thread in the GPU process due to
 conflict with WatchDog
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This CL is totally disabling the HangWatcher. No thread will be spawned
in the GPU process.

The WatchDog magic signatures are blaming the HangWatcher thread an hang because
it started between the MainThread and the WatchDog thread. Until this issue is fixed
we will not collect data from GPU process.

R=â€‹fdoray@chromium.org,olivierli@chromium.org

(cherry picked from commit 76557d9bc7ff979a542f0baf54999bbf5ff82b1e)

Bug: 1297760
Change-Id: I61cd3485aa8a2977cf5b8170513178a14e10542f
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3550555
Reviewed-by: Zhenyao Mo <zmo@chromium.org>
Reviewed-by: Francois Pierre Doray <fdoray@chromium.org>
Commit-Queue: Etienne Bergeron <etienneb@chromium.org>
Cr-Original-Commit-Position: refs/heads/main@{#986021}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3564638
Bot-Commit: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Reviewed-by: Krishna Govind <govind@chromium.org>
Commit-Queue: Krishna Govind <govind@chromium.org>
Owners-Override: Krishna Govind <govind@chromium.org>
Cr-Commit-Position: refs/branch-heads/4896@{#995}
Cr-Branched-From: 1f63ff4bc27570761b35ffbc7f938f6586f7bee8-refs/heads/main@{#972766}
---
 base/threading/hang_watcher.cc | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

--- a/base/threading/hang_watcher.cc
+++ b/base/threading/hang_watcher.cc
@@ -254,8 +254,9 @@
   // If a hang is currently being captured we should block here so execution
   // stops and we avoid recording unrelated stack frames in the crash.
   if (current_hang_watch_state->IsFlagSet(
-          internal::HangWatchDeadline::Flag::kShouldBlockOnHang))
+          internal::HangWatchDeadline::Flag::kShouldBlockOnHang)) {
     base::HangWatcher::GetInstance()->BlockIfCaptureInProgress();
+  }
 
 #if DCHECK_IS_ON()
   // Verify that no Scope was destructed out of order.
@@ -293,8 +294,14 @@
   DCHECK(g_main_thread_log_level == LoggingLevel::kNone);
   DCHECK(g_threadpool_log_level == LoggingLevel::kNone);
 
-  const bool enable_hang_watcher =
-      base::FeatureList::IsEnabled(kEnableHangWatcher);
+  bool enable_hang_watcher = base::FeatureList::IsEnabled(kEnableHangWatcher);
+
+  // Do not start HangWatcher in the GPU process until the issue related to
+  // invalid magic signature in the GPU WatchDog is fixed
+  // (https://crbug.com/1297760).
+  if (process_type == ProcessType::kGPUProcess)
+    enable_hang_watcher = false;
+
   g_use_hang_watcher.store(enable_hang_watcher, std::memory_order_relaxed);
 
   // Keep the process type.
@@ -696,8 +703,9 @@
         static_cast<HangWatcher::ThreadType>(i);
     if (hang_count != kInvalidHangCount &&
         ThreadTypeLoggingLevelGreaterOrEqual(thread_type,
-                                             LoggingLevel::kUmaOnly))
+                                             LoggingLevel::kUmaOnly)) {
       LogHungThreadCountHistogram(thread_type, hang_count);
+    }
   }
 
   // Three cases can invalidate this snapshot and prevent the capture of the
@@ -886,7 +894,7 @@
 
 void HangWatcher::BlockIfCaptureInProgress() {
   // Makes a best-effort attempt to block execution if a hang is currently being
-  // captured.Only block on |capture_lock| if |capture_in_progress_| hints that
+  // captured. Only block on |capture_lock| if |capture_in_progress_| hints that
   // it's already held to avoid serializing all threads on this function when no
   // hang capture is in-progress.
   if (capture_in_progress_.load(std::memory_order_relaxed))
