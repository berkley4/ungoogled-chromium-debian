From 7d91b5583c9f79279feb03e35560623dadb90466 Mon Sep 17 00:00:00 2001
From: Peter McNeeley <petermcneeley@chromium.org>
Date: Tue, 26 Apr 2022 23:23:57 +0000
Subject: [PATCH] Account for UVs in Wayland buffer damage

Damage is sent through Wayland in buffer space. Transforming damage from
target space (~pixels on the display) requires some effort.

Originally we were accounting for the transform to content space and
then possible scaling due to resource size not being the same as the
content rect size. With this cl we now correctly account for scaling and
offsets that can occur when UVs are present.

(cherry picked from commit e3b2c9c9761d9ee6addf6d8f7019482f5e337d61)

Bug: 1300255, 1279965, 1307182, 1224991
Change-Id: I1a776a49288f59876b2205862806166f2db8ba07
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3570483
Reviewed-by: Kramer Ge <fangzhoug@chromium.org>
Reviewed-by: Eliot Courtney <edcourtney@chromium.org>
Commit-Queue: Peter McNeeley <petermcneeley@chromium.org>
Cr-Original-Commit-Position: refs/heads/main@{#991904}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3606370
Reviewed-by: Robert Kroeger <rjkroege@chromium.org>
Cr-Commit-Position: refs/branch-heads/4951@{#1078}
Cr-Branched-From: 27de6227ca357da0d57ae2c7b18da170c4651438-refs/heads/main@{#982481}
---
 .../viz/service/display/overlay_candidate.cc  |  24 ++--
 .../viz/service/display/overlay_unittest.cc   |  38 ++++-
 .../platform/wayland/common/wayland_util.cc   |  48 +++++++
 .../platform/wayland/common/wayland_util.h    |   7 +
 .../wayland/gpu/gbm_surfaceless_wayland.h     |   2 +
 .../wayland/gpu/wayland_buffer_manager_gpu.h  |   2 +
 .../gpu/wayland_surface_factory_unittest.cc   | 130 ++++++++++++++++++
 .../host/wayland_connection_unittest.cc       |   6 +-
 .../platform/wayland/host/wayland_surface.cc  |  40 +++---
 .../platform/wayland/test/test_compositor.cc  |   9 +-
 .../platform/wayland/test/test_compositor.h   |   6 +-
 .../test/test_wayland_server_thread.cc        |  11 +-
 .../wayland/test/test_wayland_server_thread.h |   9 +-
 13 files changed, 287 insertions(+), 45 deletions(-)

--- a/components/viz/service/display/overlay_candidate.cc
+++ b/components/viz/service/display/overlay_candidate.cc
@@ -623,22 +623,28 @@
     inv.TransformRect(&transformed_damage);
     // The quad's |rect| is in content space. To get to buffer space we need
     // to remove the |rect|'s pixel offset.
-    // TODO(edcourtney) : Take into account UVs for transformed damage.
     auto buffer_damage_origin =
         transformed_damage.origin() - gfx::PointF(quad->rect.origin());
     transformed_damage.set_origin(
         gfx::PointF(buffer_damage_origin.x(), buffer_damage_origin.y()));
 
     if (!quad->rect.IsEmpty()) {
-      // A quad's |rect| is usually the same size as its buffer size with tile
-      // quads but can have scaling if it is a render pass or (more likely) a
-      // texture draw quad.
-      transformed_damage.Scale(
-          static_cast<float>(candidate->resource_size_in_pixels.width()) /
-              quad->rect.width(),
-          static_cast<float>(candidate->resource_size_in_pixels.height()) /
-              quad->rect.height());
+      // Normalize damage to be in UVs.
+      transformed_damage.Scale(1.0f / quad->rect.width(),
+                               1.0f / quad->rect.height());
     }
+
+    // The normalization above is not enough if the |uv_rect| is not 0,0-1x1.
+    // This is because texture uvs can effectively magnify damage.
+    if (!candidate->uv_rect.IsEmpty()) {
+      transformed_damage.Scale(candidate->uv_rect.width(),
+                               candidate->uv_rect.height());
+      transformed_damage.Offset(candidate->uv_rect.OffsetFromOrigin());
+    }
+
+    // Buffer damage is in texels not UVs so scale by resource size.
+    transformed_damage.Scale(candidate->resource_size_in_pixels.width(),
+                             candidate->resource_size_in_pixels.height());
   } else {
     // If not invertible, set to full damage.
     // TODO(https://crbug.com/1279965): |resource_size_in_pixels| might not be
--- a/components/viz/service/display/overlay_unittest.cc
+++ b/components/viz/service/display/overlay_unittest.cc
@@ -691,6 +691,19 @@
   return matrix;
 }
 
+gfx::RectF ScaleForBufferDamageUV(const gfx::RectF buffer_damage_no_uv,
+                                  const gfx::SizeF resource_size) {
+  auto transformed_damage = buffer_damage_no_uv;
+  gfx::RectF uv = {kUVTopLeft.x(), kUVTopLeft.y(),
+                   kUVBottomRight.x() - kUVTopLeft.x(),
+                   kUVBottomRight.y() - kUVTopLeft.y()};
+
+  transformed_damage.Scale(uv.width(), uv.height());
+  transformed_damage.Offset(uv.x() * resource_size.width(),
+                            uv.y() * resource_size.height());
+  return transformed_damage;
+}
+
 template <typename OverlayProcessorType>
 class OverlayTest : public testing::Test {
  protected:
@@ -1999,8 +2012,18 @@
       std::move(surface_damage_rect_list), nullptr, &candidate_list,
       &damage_rect_, &content_bounds_);
   EXPECT_EQ(1U, candidate_list.size());
-  EXPECT_EQ(kIntendedBufferOffset,
-            candidate_list[0].damage_rect.OffsetFromOrigin());
+  // |transformed_damage| would correspond to candidate buffer damage if our
+  // texture uvs were 0,0 1x1.
+  gfx::RectF transformed_damage = {
+      kIntendedBufferOffset.x(), kIntendedBufferOffset.y(),
+      kOverlayRectInContent.width() - kIntendedBufferOffset.x(),
+      kOverlayRectInContent.height() - kIntendedBufferOffset.y()};
+  // However, the default uvs for candidates are 0.1,0.2 .9x.8  (see the value
+  // of |kUVTopLeft|). So the damage in buffer space is actually smaller because
+  // the uvs have the effect of magnifying portions of the buffer.
+  transformed_damage = ScaleForBufferDamageUV(
+      transformed_damage, gfx::SizeF(kOverlayRectInContent.size()));
+  EXPECT_RECTF_NEAR(transformed_damage, candidate_list[0].damage_rect, 0.0001f);
 }
 
 TEST_F(SingleOverlayOnTopTest, AcceptMirrorYTransform) {
@@ -5549,8 +5572,15 @@
       gfx::ScaleRect(kExpectedRectRelDamage, 0.5f, 0.25f);
   EXPECT_EQ(main_pass->quad_list.size(), candidate_list.size());
   EXPECT_TRUE(damage_rect_.IsEmpty());
-  EXPECT_RECTF_EQ(candidate_list[0].damage_rect, kExpectedScaledRelDamage);
-  EXPECT_RECTF_EQ(candidate_list[1].damage_rect, kExpectedRectRelDamage);
+  EXPECT_RECTF_NEAR(candidate_list[0].damage_rect,
+                    ScaleForBufferDamageUV(kExpectedScaledRelDamage,
+                                           gfx::SizeF(kResourceSize)),
+                    0.001f);
+  EXPECT_RECTF_NEAR(
+      candidate_list[1].damage_rect,
+      ScaleForBufferDamageUV(kExpectedRectRelDamage,
+                             gfx::SizeF(kSmallCandidateRect.size())),
+      0.001f);
 }
 
 TEST_F(DelegatedTest, QuadTypes) {
--- a/ui/ozone/platform/wayland/common/wayland_util.cc
+++ b/ui/ozone/platform/wayland/common/wayland_util.cc
@@ -190,6 +190,54 @@
   return WL_OUTPUT_TRANSFORM_NORMAL;
 }
 
+gfx::RectF ApplyWaylandTransform(const gfx::RectF& rect,
+                                 const gfx::SizeF& bounds,
+                                 wl_output_transform transform) {
+  gfx::RectF result = rect;
+  switch (transform) {
+    case WL_OUTPUT_TRANSFORM_NORMAL:
+      break;
+    case WL_OUTPUT_TRANSFORM_FLIPPED:
+      result.set_x(bounds.width() - rect.x() - rect.width());
+      break;
+    case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+      result.set_x(rect.y());
+      result.set_y(rect.x());
+      result.set_width(rect.height());
+      result.set_height(rect.width());
+      break;
+    case WL_OUTPUT_TRANSFORM_FLIPPED_180:
+      result.set_y(bounds.height() - rect.y() - rect.height());
+      break;
+    case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+      result.set_x(bounds.height() - rect.y() - rect.height());
+      result.set_y(bounds.width() - rect.x() - rect.width());
+      result.set_width(rect.height());
+      result.set_height(rect.width());
+      break;
+    case WL_OUTPUT_TRANSFORM_90:
+      result.set_x(rect.y());
+      result.set_y(bounds.width() - rect.x() - rect.width());
+      result.set_width(rect.height());
+      result.set_height(rect.width());
+      break;
+    case WL_OUTPUT_TRANSFORM_180:
+      result.set_x(bounds.width() - rect.x() - rect.width());
+      result.set_y(bounds.height() - rect.y() - rect.height());
+      break;
+    case WL_OUTPUT_TRANSFORM_270:
+      result.set_x(bounds.height() - rect.y() - rect.height());
+      result.set_y(rect.x());
+      result.set_width(rect.height());
+      result.set_height(rect.width());
+      break;
+    default:
+      NOTREACHED();
+      break;
+  }
+  return result;
+}
+
 gfx::Rect ApplyWaylandTransform(const gfx::Rect& rect,
                                 const gfx::Size& bounds,
                                 wl_output_transform transform) {
--- a/ui/ozone/platform/wayland/common/wayland_util.h
+++ b/ui/ozone/platform/wayland/common/wayland_util.h
@@ -73,6 +73,13 @@
                                 const gfx::Size& bounds,
                                 wl_output_transform transform);
 
+// |bounds| contains |rect|. ApplyWaylandTransform() returns the resulted
+// |rect| after transformation is applied to |bounds| containing |rect| as a
+// whole.
+gfx::RectF ApplyWaylandTransform(const gfx::RectF& rect,
+                                 const gfx::SizeF& bounds,
+                                 wl_output_transform transform);
+
 // Applies transformation to |size|.
 gfx::SizeF ApplyWaylandTransform(const gfx::SizeF& size,
                                  wl_output_transform transform);
--- a/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h
+++ b/ui/ozone/platform/wayland/gpu/gbm_surfaceless_wayland.h
@@ -78,6 +78,8 @@
                            GbmSurfacelessWaylandCommitOverlaysCallbacksTest);
   FRIEND_TEST_ALL_PREFIXES(WaylandSurfaceFactoryTest,
                            GbmSurfacelessWaylandGroupOnSubmissionCallbacksTest);
+  FRIEND_TEST_ALL_PREFIXES(WaylandSurfaceFactoryCompositorV3,
+                           SurfaceDamageTest);
 
   // Holds solid color buffers.
   class SolidColorBufferHolder {
--- a/ui/ozone/platform/wayland/gpu/wayland_buffer_manager_gpu.h
+++ b/ui/ozone/platform/wayland/gpu/wayland_buffer_manager_gpu.h
@@ -169,6 +169,8 @@
                            GbmSurfacelessWaylandCommitOverlaysCallbacksTest);
   FRIEND_TEST_ALL_PREFIXES(WaylandSurfaceFactoryTest,
                            GbmSurfacelessWaylandGroupOnSubmissionCallbacksTest);
+  FRIEND_TEST_ALL_PREFIXES(WaylandSurfaceFactoryCompositorV3,
+                           SurfaceDamageTest);
   FRIEND_TEST_ALL_PREFIXES(WaylandBufferManagerTest,
                            ExecutesTasksAfterInitialization);
   FRIEND_TEST_ALL_PREFIXES(WaylandOverlayManagerTest,
--- a/ui/ozone/platform/wayland/gpu/wayland_surface_factory_unittest.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_surface_factory_unittest.cc
@@ -852,13 +852,143 @@
   EXPECT_FALSE(gl_surface);
 }
 
+class WaylandSurfaceFactoryCompositorV3 : public WaylandSurfaceFactoryTest {};
+
+TEST_P(WaylandSurfaceFactoryCompositorV3, SurfaceDamageTest) {
+  // This tests multiple buffers per-frame and order of SwapCompletionCallbacks.
+  // Even when all OnSubmission from later frames are called, their
+  // SwapCompletionCallbacks should not run until previous frames'
+  // SwapCompletionCallbacks run.
+  gl::SetGLImplementation(gl::kGLImplementationEGLGLES2);
+
+  buffer_manager_gpu_->use_fake_gbm_device_for_test_ = true;
+  buffer_manager_gpu_->gbm_device_ = std::make_unique<MockGbmDevice>();
+  buffer_manager_gpu_->supports_dmabuf_ = true;
+
+  auto* gl_ozone = surface_factory_->GetGLOzone(
+      gl::GLImplementationParts(gl::kGLImplementationEGLGLES2));
+  auto gl_surface = gl_ozone->CreateSurfacelessViewGLSurface(widget_);
+  EXPECT_TRUE(gl_surface);
+  gl_surface->SetRelyOnImplicitSync();
+  static_cast<ui::GbmSurfacelessWayland*>(gl_surface.get())
+      ->SetNoGLFlushForTests();
+
+  // Expect to create 4 buffers.
+  EXPECT_CALL(*server_.zwp_linux_dmabuf_v1(), CreateParams(_, _, _)).Times(4);
+
+  gfx::Size test_buffer_size = {300, 100};
+  gfx::RectF test_buffer_dmg_uv = {0.2f, 0.3f, 0.6, 0.32f};
+  gfx::Rect test_buffer_dmg = gfx::ToEnclosingRect(gfx::ScaleRect(
+      test_buffer_dmg_uv, test_buffer_size.width(), test_buffer_size.height()));
+  gfx::RectF crop_uv = {0.1f, 0.2f, 0.5, 0.5f};
+  gfx::RectF expected_combined_uv = {0.2, 0.2, 0.8, 0.64};
+  gfx::Rect expected_surface_dmg = gfx::ToEnclosingRect(
+      gfx::ScaleRect(expected_combined_uv, window_->GetBounds().width(),
+                     window_->GetBounds().height()));
+
+  // Create buffers and FakeGlImageNativePixmap.
+  std::vector<scoped_refptr<FakeGLImageNativePixmap>> fake_gl_image;
+  for (int i = 0; i < 4; ++i) {
+    auto native_pixmap = surface_factory_->CreateNativePixmap(
+        widget_, nullptr, test_buffer_size, gfx::BufferFormat::BGRA_8888,
+        gfx::BufferUsage::SCANOUT);
+    fake_gl_image.push_back(base::MakeRefCounted<FakeGLImageNativePixmap>(
+        native_pixmap, test_buffer_size));
+
+    Sync();
+
+    // Create one buffer at a time.
+    auto params_vector = server_.zwp_linux_dmabuf_v1()->buffer_params();
+    DCHECK_EQ(params_vector.size(), 1u);
+    zwp_linux_buffer_params_v1_send_created(
+        params_vector.front()->resource(),
+        params_vector.front()->buffer_resource());
+
+    Sync();
+  }
+
+  auto* root_surface = server_.GetObject<wl::MockSurface>(
+      window_->root_surface()->GetSurfaceId());
+  auto* mock_primary_surface = server_.GetObject<wl::MockSurface>(
+      window_->primary_subsurface()->wayland_surface()->GetSurfaceId());
+
+  CallbacksHelper cbs_helper;
+  // Submit a frame with an overlay and background.
+  {
+    // Associate each image with swap id so that we could track released
+    // buffers.
+    auto swap_id = cbs_helper.GetNextLocalSwapId();
+    // Associate the image with the next swap id so that we can easily track if
+    // it became free to reuse.
+    fake_gl_image[0]->AssociateWithSwapId(swap_id);
+    // And set it to be busy...
+    fake_gl_image[0]->SetBusy(true);
+
+    // Prepare background.
+    gl_surface->ScheduleOverlayPlane(
+        fake_gl_image[0].get(), nullptr,
+        gfx::OverlayPlaneData(
+            INT32_MIN, gfx::OverlayTransform::OVERLAY_TRANSFORM_NONE,
+            gfx::RectF(window_->GetBounds()), crop_uv, false,
+            gfx::Rect(test_buffer_dmg), 1.0f, gfx::OverlayPriorityHint::kNone,
+            gfx::RRectF(), gfx::ColorSpace::CreateSRGB(), absl::nullopt));
+
+    std::vector<scoped_refptr<FakeGLImageNativePixmap>> gl_images;
+    gl_images.push_back(fake_gl_image[0]);
+
+    // And submit each image. They will be executed in FIFO manner.
+    gl_surface->SwapBuffersAsync(
+        base::BindOnce(&CallbacksHelper::FinishSwapBuffersAsync,
+                       base::Unretained(&cbs_helper), swap_id, gl_images),
+        base::BindOnce(&CallbacksHelper::BufferPresented,
+                       base::Unretained(&cbs_helper), swap_id));
+  }
+
+  // Let's sync so that 1) GbmSurfacelessWayland submits the buffer according to
+  // internal queue and fake server processes the request.
+
+  // Wait until the mojo calls are done.
+  base::RunLoop().RunUntilIdle();
+
+  Expectation damage =
+      EXPECT_CALL(*surface_, Damage(expected_surface_dmg.origin().x(),
+                                    expected_surface_dmg.origin().y(),
+                                    expected_surface_dmg.width(),
+                                    expected_surface_dmg.height()));
+  wl_resource* buffer_resource = nullptr;
+  Expectation attach = EXPECT_CALL(*surface_, Attach(_, 0, 0))
+                           .WillOnce(SaveArg<0>(&buffer_resource));
+  EXPECT_CALL(*surface_, Commit()).After(damage, attach);
+
+  Sync();
+
+  testing::Mock::VerifyAndClearExpectations(mock_primary_surface);
+  testing::Mock::VerifyAndClearExpectations(root_surface);
+
+  // Give mojo the chance to pass the callbacks.
+  base::RunLoop().RunUntilIdle();
+
+  // We have just received Attach/DamageBuffer/Commit for buffer with swap
+  // id=0u. The SwapCompletionCallback must be executed automatically as long as
+  // we didn't have any buffers attached to the surface before.
+  EXPECT_EQ(cbs_helper.GetLastFinishedSwapId(), 0u);
+
+  cbs_helper.ResetLastFinishedSwapId();
+}
+
 INSTANTIATE_TEST_SUITE_P(XdgVersionStableTest,
                          WaylandSurfaceFactoryTest,
                          Values(wl::ServerConfig{
                              .shell_version = wl::ShellVersion::kStable}));
+
 INSTANTIATE_TEST_SUITE_P(XdgVersionV6Test,
                          WaylandSurfaceFactoryTest,
                          Values(wl::ServerConfig{
                              .shell_version = wl::ShellVersion::kV6}));
 
+INSTANTIATE_TEST_SUITE_P(
+    CompositorVersionV3Test,
+    WaylandSurfaceFactoryCompositorV3,
+    Values(wl::ServerConfig{.compositor_version = wl::CompositorVersion::kV3}));
+
 }  // namespace ui
--- a/ui/ozone/platform/wayland/host/wayland_connection_unittest.cc
+++ b/ui/ozone/platform/wayland/host/wayland_connection_unittest.cc
@@ -20,7 +20,9 @@
   base::test::SingleThreadTaskEnvironment task_environment(
       base::test::SingleThreadTaskEnvironment::MainThreadType::UI);
   wl::TestWaylandServerThread server;
-  ASSERT_TRUE(server.Start({.shell_version = wl::ShellVersion::kStable}));
+  constexpr uint32_t expected_compositor_version = 4;
+  ASSERT_TRUE(server.Start({.shell_version = wl::ShellVersion::kStable,
+                            .compositor_version = wl::CompositorVersion::kV4}));
   WaylandConnection connection;
   ASSERT_TRUE(connection.Initialize());
   connection.event_source()->StartProcessingEvents();
@@ -28,7 +30,7 @@
   base::RunLoop().RunUntilIdle();
   server.Pause();
 
-  EXPECT_EQ(wl::TestCompositor::kVersion,
+  EXPECT_EQ(expected_compositor_version,
             wl::get_version_of_object(connection.compositor()));
 
   xdg_wm_base_send_ping(server.xdg_shell()->resource(), 1234);
--- a/ui/ozone/platform/wayland/host/wayland_surface.cc
+++ b/ui/ozone/platform/wayland/host/wayland_surface.cc
@@ -588,28 +588,28 @@
                              pending_state_.damage_px.back().width(),
                              pending_state_.damage_px.back().height());
   } else {
-    // Calculate the damage region in surface coordinates.
-    // The calculation for damage region relies on the assumption: The buffer is
-    // always attached at surface location (0, 0).
-    // It's possible to write logic that accounts for attaching buffer at other
-    // locations, but it's currently unnecessary.
+    gfx::RectF damage_uv =
+        gfx::ScaleRect(gfx::RectF(pending_state_.damage_px.back()),
+                       1.0f / pending_state_.buffer_size_px.width(),
+                       1.0f / pending_state_.buffer_size_px.height());
 
-    // Apply buffer_transform (wl_surface.set_buffer_transform).
-    gfx::Rect damage = wl::ApplyWaylandTransform(
-        pending_state_.damage_px.back(), pending_state_.buffer_size_px,
-        wl::ToWaylandTransform(pending_state_.buffer_transform));
-    // Apply buffer_scale (wl_surface.set_buffer_scale).
-    damage = gfx::ScaleToEnclosingRect(damage, 1.f / applying_surface_scale);
-    // Adjust coordinates to |viewport_src| (wp_viewport.set_source).
-    damage = wl::TranslateBoundsToParentCoordinates(
-        damage, gfx::ToEnclosingRect(viewport_src_dip));
-    // Apply viewport scale (wp_viewport.set_destination).
-    if (viewport_dst_dip != viewport_src_dip.size()) {
-      damage = gfx::ScaleToEnclosingRect(
-          damage, viewport_dst_dip.width() / viewport_src_dip.width(),
-          viewport_dst_dip.height() / viewport_src_dip.height());
+    if (!pending_state_.crop.IsEmpty()) {
+      damage_uv.Offset(-pending_state_.crop.OffsetFromOrigin());
+      damage_uv.Scale(1.0f / pending_state_.crop.width(),
+                      1.0f / pending_state_.crop.height());
     }
+    damage_uv.Intersect(gfx::RectF(1, 1));
+
+    gfx::RectF damage_uv_transformed = wl::ApplyWaylandTransform(
+        damage_uv, gfx::SizeF(1, 1),
+        wl::ToWaylandTransform(pending_state_.buffer_transform));
 
+    gfx::RectF damage_float =
+        gfx::ScaleRect(damage_uv_transformed, viewport_dst_dip.width(),
+                       viewport_dst_dip.height());
+    constexpr float kAcceptableSubDipDamageError = 0.001f;
+    gfx::Rect damage = gfx::ToEnclosingRectIgnoringError(
+        damage_float, kAcceptableSubDipDamageError);
     wl_surface_damage(surface_.get(), damage.x(), damage.y(), damage.width(),
                       damage.height());
   }
--- a/ui/ozone/platform/wayland/test/test_compositor.cc
+++ b/ui/ozone/platform/wayland/test/test_compositor.cc
@@ -12,8 +12,6 @@
 
 namespace wl {
 
-constexpr uint32_t TestCompositor::kVersion;
-
 namespace {
 
 void CreateSurface(wl_client* client,
@@ -41,8 +39,11 @@
     CreateRegion,   // create_region
 };
 
-TestCompositor::TestCompositor()
-    : GlobalObject(&wl_compositor_interface, &kTestCompositorImpl, kVersion) {}
+TestCompositor::TestCompositor(uint32_t intended_version)
+    : GlobalObject(&wl_compositor_interface,
+                   &kTestCompositorImpl,
+                   intended_version),
+      version_(intended_version) {}
 
 TestCompositor::~TestCompositor() = default;
 
--- a/ui/ozone/platform/wayland/test/test_compositor.h
+++ b/ui/ozone/platform/wayland/test/test_compositor.h
@@ -16,9 +16,7 @@
 // Manage wl_compositor object.
 class TestCompositor : public GlobalObject {
  public:
-  static constexpr uint32_t kVersion = 4;
-
-  TestCompositor();
+  explicit TestCompositor(uint32_t intended_version);
 
   TestCompositor(const TestCompositor&) = delete;
   TestCompositor& operator=(const TestCompositor&) = delete;
@@ -26,8 +24,10 @@
   ~TestCompositor() override;
 
   void AddSurface(MockSurface* surface);
+  uint32_t GetVersion() { return version_; }
 
  private:
+  uint32_t version_;
   std::vector<MockSurface*> surfaces_;
 };
 
--- a/ui/ozone/platform/wayland/test/test_wayland_server_thread.cc
+++ b/ui/ozone/platform/wayland/test/test_wayland_server_thread.cc
@@ -32,6 +32,8 @@
                    base::WaitableEvent::InitialState::NOT_SIGNALED),
       resume_event_(base::WaitableEvent::ResetPolicy::AUTOMATIC,
                     base::WaitableEvent::InitialState::NOT_SIGNALED),
+      compositor_v4_(4),
+      compositor_v3_(3),
       controller_(FROM_HERE) {}
 
 TestWaylandServerThread::~TestWaylandServerThread() {
@@ -60,8 +62,13 @@
 
   if (wl_display_init_shm(display_.get()) < 0)
     return false;
-  if (!compositor_.Initialize(display_.get()))
-    return false;
+  if (config.compositor_version == CompositorVersion::kV3) {
+    if (!compositor_v3_.Initialize(display_.get()))
+      return false;
+  } else {
+    if (!compositor_v4_.Initialize(display_.get()))
+      return false;
+  }
   if (!sub_compositor_.Initialize(display_.get()))
     return false;
   if (!viewporter_.Initialize(display_.get()))
--- a/ui/ozone/platform/wayland/test/test_wayland_server_thread.h
+++ b/ui/ozone/platform/wayland/test/test_wayland_server_thread.h
@@ -46,9 +46,11 @@
 // Server configuration related enums and structs.
 enum class ShellVersion { kV6, kStable };
 enum class PrimarySelectionProtocol { kNone, kGtk, kZwp };
+enum class CompositorVersion { kV3, kV4 };
 
 struct ServerConfig {
   ShellVersion shell_version = ShellVersion::kStable;
+  CompositorVersion compositor_version = CompositorVersion::kV4;
   PrimarySelectionProtocol primary_selection_protocol =
       PrimarySelectionProtocol::kNone;
 };
@@ -151,7 +153,12 @@
   base::WaitableEvent resume_event_;
 
   // Represent Wayland global objects
-  TestCompositor compositor_;
+  // Compositor version is selected dynamically by server config but version is
+  // actually set on construction thus both compositor version objects appear
+  // here.
+  // TODO(crbug.com/1315587): Refactor this pattern when required.
+  TestCompositor compositor_v4_;
+  TestCompositor compositor_v3_;
   TestSubCompositor sub_compositor_;
   TestViewporter viewporter_;
   TestAlphaCompositing alpha_compositing_;
