From 906da494a320cd54e56004fdb496648deb4e3ce6 Mon Sep 17 00:00:00 2001
From: Daniel Rubery <drubery@chromium.org>
Date: Tue, 8 Mar 2022 04:30:28 +0000
Subject: [PATCH] [M99] Use WeakPtr and unique_ptr for ownership in
 ThreatDetails

Currently we use scoped_refptr for the ThreatDetailsCacheCollector,
which holds pointers into resources owned by ThreatDetails. When the
ThreatDetails is destroyed, it's intended that the
ThreatDetailsCacheCollector is destroyed with it, but that does not
occur if there is a pending task with a reference to the
ThreatDetailsCacheCollector.

By having the ThreatDeails hold a unique_ptr, we can ensure that
destruction happens as planned.

(cherry picked from commit 43bd823074abd33f430bbb94448107910680d85a)

Bug: 1297498
Change-Id: I5f14a33d56a86c271b249534ee7410f4045f4f32
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3482677
Reviewed-by: Xinghui Lu <xinghuilu@chromium.org>
Commit-Queue: Daniel Rubery <drubery@chromium.org>
Cr-Original-Commit-Position: refs/heads/main@{#974062}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3508760
Auto-Submit: Daniel Rubery <drubery@chromium.org>
Commit-Queue: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Bot-Commit: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Cr-Commit-Position: refs/branch-heads/4844@{#1006}
Cr-Branched-From: 007241ce2e6c8e5a7b306cc36c730cd07cd38825-refs/heads/main@{#961656}
---
 .../safe_browsing/threat_details_unittest.cc  | 53 +++++++++++++++++++
 .../content/browser/threat_details.cc         |  8 ++-
 .../content/browser/threat_details.h          |  8 +--
 .../content/browser/threat_details_cache.cc   |  7 ++-
 .../content/browser/threat_details_cache.h    |  8 +--
 .../content/browser/threat_details_history.cc |  6 +--
 .../content/browser/threat_details_history.h  |  9 ++--
 7 files changed, 77 insertions(+), 22 deletions(-)

--- a/chrome/browser/safe_browsing/threat_details_unittest.cc
+++ b/chrome/browser/safe_browsing/threat_details_unittest.cc
@@ -151,6 +151,13 @@
     run_loop_ = nullptr;
   }
 
+  void OnRedirectionCollectionReady() override {
+    ThreatDetails::OnRedirectionCollectionReady();
+    if (should_stop_after_redirect_collection_ && run_loop_) {
+      run_loop_->Quit();
+    }
+  }
+
   // Used to synchronize ThreatDetailsDone() with WaitForThreatDetailsDone().
   // RunLoop::RunUntilIdle() is not sufficient because the MessageLoop task
   // queue completely drains at some point between the send and the wait.
@@ -163,9 +170,14 @@
 
   void StartCollection() { ThreatDetails::StartCollection(); }
 
+  void SetShouldStopAfterRedirectCollection(bool should_stop) {
+    should_stop_after_redirect_collection_ = should_stop;
+  }
+
  private:
   raw_ptr<base::RunLoop> run_loop_;
   size_t done_callback_count_;
+  bool should_stop_after_redirect_collection_ = false;
 };
 
 class MockSafeBrowsingUIManager : public SafeBrowsingUIManager {
@@ -1977,4 +1989,45 @@
   VerifyResults(actual, expected);
 }
 
+TEST_F(ThreatDetailsTest, CanCancelDuringCollection) {
+  content::WebContentsTester::For(web_contents())
+      ->NavigateAndCommit(GURL(kLandingURL));
+
+  UnsafeResource resource;
+  InitResource(SB_THREAT_TYPE_URL_CLIENT_SIDE_PHISHING,
+               ThreatSource::CLIENT_SIDE_DETECTION, true /* is_subresource */,
+               GURL(kThreatURL), &resource);
+
+  auto report = std::make_unique<ThreatDetailsWrap>(
+      ui_manager_.get(), web_contents(), resource, test_shared_loader_factory_,
+      history_service(), user_population_callback(),
+      referrer_chain_provider_.get());
+  report->StartCollection();
+
+  SimulateFillCache(kThreatURL);
+
+  // The cache collection starts after the IPC from the DOM is fired.
+  std::vector<mojom::ThreatDOMDetailsNodePtr> params;
+  report->OnReceivedThreatDOMDetails(mojo::Remote<mojom::ThreatReporter>(),
+                                     main_rfh()->GetGlobalId(),
+                                     std::move(params));
+
+  // Let the cache callbacks complete.
+  base::RunLoop().RunUntilIdle();
+
+  // Let the cache collection start
+  {
+    base::RunLoop run_loop;
+    report->SetShouldStopAfterRedirectCollection(true);
+    report->SetRunLoopToQuit(&run_loop);
+    report->FinishCollection(/*did_proceed=*/true, /*num_visits=*/-1);
+    run_loop.Run();
+  }
+
+  // Cancel the collection
+  report.reset();
+
+  base::RunLoop().RunUntilIdle();
+}
+
 }  // namespace safe_browsing
--- a/components/safe_browsing/content/browser/threat_details.cc
+++ b/components/safe_browsing/content/browser/threat_details.cc
@@ -401,11 +401,11 @@
       did_proceed_(false),
       num_visits_(0),
       trim_to_ad_tags_(trim_to_ad_tags),
-      cache_collector_(new ThreatDetailsCacheCollector),
+      cache_collector_(std::make_unique<ThreatDetailsCacheCollector>()),
       done_callback_(std::move(done_callback)),
       all_done_expected_(false),
       is_all_done_(false) {
-  redirects_collector_ = new ThreatDetailsRedirectsCollector(
+  redirects_collector_ = std::make_unique<ThreatDetailsRedirectsCollector>(
       history_service ? history_service->AsWeakPtr()
                       : base::WeakPtr<history::HistoryService>());
 }
@@ -420,9 +420,7 @@
       all_done_expected_(false),
       is_all_done_(false) {}
 
-ThreatDetails::~ThreatDetails() {
-  DCHECK_EQ(all_done_expected_, is_all_done_);
-}
+ThreatDetails::~ThreatDetails() = default;
 
 bool ThreatDetails::IsReportableUrl(const GURL& url) const {
   // TODO(panayiotis): also skip internal urls.
--- a/components/safe_browsing/content/browser/threat_details.h
+++ b/components/safe_browsing/content/browser/threat_details.h
@@ -109,7 +109,8 @@
 
   void OnCacheCollectionReady();
 
-  void OnRedirectionCollectionReady();
+  // Overridden during tests
+  virtual void OnRedirectionCollectionReady();
 
   // WebContentsObserver implementation:
   void RenderFrameDeleted(content::RenderFrameHost* render_frame_host) override;
@@ -262,10 +263,10 @@
   static ThreatDetailsFactory* factory_;
 
   // Used to collect details from the HTTP Cache.
-  scoped_refptr<ThreatDetailsCacheCollector> cache_collector_;
+  std::unique_ptr<ThreatDetailsCacheCollector> cache_collector_;
 
   // Used to collect redirect urls from the history service
-  scoped_refptr<ThreatDetailsRedirectsCollector> redirects_collector_;
+  std::unique_ptr<ThreatDetailsRedirectsCollector> redirects_collector_;
 
   // Callback to run when the report is finished.
   ThreatDetailsDoneCallback done_callback_;
@@ -294,6 +295,7 @@
   FRIEND_TEST_ALL_PREFIXES(ThreatDetailsTest, ThreatDOMDetails_MultipleFrames);
   FRIEND_TEST_ALL_PREFIXES(ThreatDetailsTest, ThreatDOMDetails_TrimToAdTags);
   FRIEND_TEST_ALL_PREFIXES(ThreatDetailsTest, ThreatDOMDetails);
+  FRIEND_TEST_ALL_PREFIXES(ThreatDetailsTest, CanCancelDuringCollection);
 };
 
 // Factory for creating ThreatDetails.  Useful for tests.
--- a/components/safe_browsing/content/browser/threat_details_cache.cc
+++ b/components/safe_browsing/content/browser/threat_details_cache.cc
@@ -54,7 +54,8 @@
   // Post a task in the message loop, so the callers don't need to
   // check if we call their callback immediately.
   content::GetUIThreadTaskRunner({})->PostTask(
-      FROM_HERE, base::BindOnce(&ThreatDetailsCacheCollector::OpenEntry, this));
+      FROM_HERE, base::BindOnce(&ThreatDetailsCacheCollector::OpenEntry,
+                                weak_factory_.GetWeakPtr()));
 }
 
 bool ThreatDetailsCacheCollector::HasStarted() {
@@ -120,6 +121,7 @@
   current_load_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
       url_loader_factory_.get(),
       base::BindOnce(&ThreatDetailsCacheCollector::OnURLLoaderComplete,
+                     // This is safe because `current_load_` is owned by `this`.
                      base::Unretained(this)));
 }
 
@@ -229,7 +231,8 @@
 
   // Create a task so we don't take over the UI thread for too long.
   content::GetUIThreadTaskRunner({})->PostTask(
-      FROM_HERE, base::BindOnce(&ThreatDetailsCacheCollector::OpenEntry, this));
+      FROM_HERE, base::BindOnce(&ThreatDetailsCacheCollector::OpenEntry,
+                                weak_factory_.GetWeakPtr()));
 }
 
 void ThreatDetailsCacheCollector::AllDone(bool success) {
--- a/components/safe_browsing/content/browser/threat_details_cache.h
+++ b/components/safe_browsing/content/browser/threat_details_cache.h
@@ -31,10 +31,10 @@
     std::unique_ptr<ClientSafeBrowsingReportRequest::Resource>>
     ResourceMap;
 
-class ThreatDetailsCacheCollector
-    : public base::RefCounted<ThreatDetailsCacheCollector> {
+class ThreatDetailsCacheCollector {
  public:
   ThreatDetailsCacheCollector();
+  ~ThreatDetailsCacheCollector();
 
   // We use |request_context_getter|, we modify |resources| and
   // |result|, and we call |callback|, so they must all remain alive
@@ -55,8 +55,6 @@
  private:
   friend class base::RefCounted<ThreatDetailsCacheCollector>;
 
-  ~ThreatDetailsCacheCollector();
-
   // Points to the url for which we are fetching the HTTP cache entry or
   // redirect chain.
   ResourceMap::iterator resources_it_;
@@ -80,6 +78,8 @@
   // The current SimpleURLLoader.
   std::unique_ptr<network::SimpleURLLoader> current_load_;
 
+  base::WeakPtrFactory<ThreatDetailsCacheCollector> weak_factory_{this};
+
   // Returns the resource from resources_ that corresponds to |url|
   ClientSafeBrowsingReportRequest::Resource* GetResource(const GURL& url);
 
--- a/components/safe_browsing/content/browser/threat_details_history.cc
+++ b/components/safe_browsing/content/browser/threat_details_history.cc
@@ -42,8 +42,8 @@
 
   content::GetUIThreadTaskRunner({})->PostTask(
       FROM_HERE,
-      base::BindOnce(&ThreatDetailsRedirectsCollector::StartGetRedirects, this,
-                     urls));
+      base::BindOnce(&ThreatDetailsRedirectsCollector::StartGetRedirects,
+                     weak_factory_.GetWeakPtr(), urls));
 }
 
 bool ThreatDetailsRedirectsCollector::HasStarted() const {
@@ -79,7 +79,7 @@
   history_service_->QueryRedirectsTo(
       url,
       base::BindOnce(&ThreatDetailsRedirectsCollector::OnGotQueryRedirectsTo,
-                     base::Unretained(this), url),
+                     weak_factory_.GetWeakPtr(), url),
       &request_tracker_);
 }
 
--- a/components/safe_browsing/content/browser/threat_details_history.h
+++ b/components/safe_browsing/content/browser/threat_details_history.h
@@ -22,12 +22,11 @@
 
 typedef std::vector<GURL> RedirectChain;
 
-class ThreatDetailsRedirectsCollector
-    : public base::RefCounted<ThreatDetailsRedirectsCollector>,
-      public history::HistoryServiceObserver {
+class ThreatDetailsRedirectsCollector : public history::HistoryServiceObserver {
  public:
   explicit ThreatDetailsRedirectsCollector(
       const base::WeakPtr<history::HistoryService>& history_service);
+  ~ThreatDetailsRedirectsCollector() override;
 
   ThreatDetailsRedirectsCollector(const ThreatDetailsRedirectsCollector&) =
       delete;
@@ -52,8 +51,6 @@
  private:
   friend class base::RefCounted<ThreatDetailsRedirectsCollector>;
 
-  ~ThreatDetailsRedirectsCollector() override;
-
   void StartGetRedirects(const std::vector<GURL>& urls);
   void GetRedirects(const GURL& url);
   void OnGotQueryRedirectsTo(const GURL& url,
@@ -82,6 +79,8 @@
   base::ScopedObservation<history::HistoryService,
                           history::HistoryServiceObserver>
       history_service_observation_{this};
+
+  base::WeakPtrFactory<ThreatDetailsRedirectsCollector> weak_factory_{this};
 };
 
 }  // namespace safe_browsing
