From 9c5c8ca2c46946604c4ad2de4ffdfff41e384e24 Mon Sep 17 00:00:00 2001
From: Thomas Guilbert <tguilbert@chromium.org>
Date: Wed, 31 Jan 2024 01:01:04 +0000
Subject: [PATCH] Discard invalid MP3 packets

Ffmpeg can sometimes return bad packets for MP3 stream containers (see
crbug.com/794782). We have had protection against such bad packets in
FfmpegDemuxer for a significant amount of time now, but no such
protection exists for AudioFileReader.

This CL fixes an issue with partially decoded mp3 files when using
AudioContext.decodeAudioData(). Discarding invalid MP3 packets prevents
decode errors, which reduce the length of the output.

Bug: 1520696, 794782
Change-Id: I565b4f329fecfe2401ce80fff7b9254f54f348a7
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5239251
Commit-Queue: Thomas Guilbert <tguilbert@chromium.org>
Auto-Submit: Thomas Guilbert <tguilbert@chromium.org>
Reviewed-by: Dale Curtis <dalecurtis@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1254292}
---

--- a/media/filters/audio_file_reader.cc
+++ b/media/filters/audio_file_reader.cc
@@ -20,6 +20,7 @@
 #include "media/base/media_switches.h"
 #include "media/ffmpeg/ffmpeg_common.h"
 #include "media/ffmpeg/ffmpeg_decoding_loop.h"
+#include "media/formats/mpeg/mpeg1_audio_stream_parser.h"
 
 namespace media {
 
@@ -220,6 +221,32 @@
       av_packet_unref(output_packet);
       continue;
     }
+
+    if (!IsMp3File()) {
+      return true;
+    }
+
+    // FFmpeg may return garbage packets for MP3 stream containers, so we need
+    // to drop these to avoid decoder errors. The ffmpeg team maintains that
+    // this behavior isn't ideal, but have asked for a significant refactoring
+    // of the AVParser infrastructure to fix this, which is overkill for now.
+    // See http://crbug.com/794782.
+
+    // MP3 packets may be zero-padded according to ffmpeg, so trim until we
+    // have the packet.
+    uint8_t* packet_end = output_packet->data + output_packet->size;
+    uint8_t* header_start = output_packet->data;
+    while (header_start < packet_end && !*header_start) {
+      ++header_start;
+    }
+
+    if (packet_end - header_start < MPEG1AudioStreamParser::kHeaderSize ||
+        !MPEG1AudioStreamParser::ParseHeader(nullptr, nullptr, header_start,
+                                             nullptr)) {
+      av_packet_unref(output_packet);
+      continue;
+    }
+
     return true;
   }
   return false;
@@ -312,6 +339,11 @@
   return true;
 }
 
+bool AudioFileReader::IsMp3File() {
+  return glue_->container() ==
+         container_names::MediaContainerName::kContainerMP3;
+}
+
 bool AudioFileReader::SeekForTesting(base::TimeDelta seek_time) {
   // Use the AVStream's time_base, since |codec_context_| does not have
   // time_base populated until after OpenDecoder().
--- a/media/filters/audio_file_reader.h
+++ b/media/filters/audio_file_reader.h
@@ -101,6 +101,7 @@
   bool OnNewFrame(int* total_frames,
                   std::vector<std::unique_ptr<AudioBus>>* decoded_audio_packets,
                   AVFrame* frame);
+  bool IsMp3File();
 
   // Destruct |glue_| after |codec_context_|.
   std::unique_ptr<FFmpegGlue> glue_;
