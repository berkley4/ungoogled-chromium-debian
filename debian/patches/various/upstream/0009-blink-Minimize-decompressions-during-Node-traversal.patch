From 8c1394ee4e467b65744509b31cc0800279c70589 Mon Sep 17 00:00:00 2001
From: Anton Bikineev <bikineev@chromium.org>
Date: Tue, 21 Feb 2023 14:59:36 +0000
Subject: [PATCH] blink: Minimize decompressions during Node traversal

The access patterns of siblings are optimized by first performing zero
checks and then decompressions.

Bug: chromium:1325007
Change-Id: I762c6b316a0a26c8d4f0223e01079ee8aea2d763
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4274723
Auto-Submit: Anton Bikineev <bikineev@chromium.org>
Commit-Queue: Anton Bikineev <bikineev@chromium.org>
Reviewed-by: Kentaro Hara <haraken@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1107731}
---
 .../blink/renderer/core/dom/container_node.cc |  9 +++---
 .../blink/renderer/core/dom/container_node.h  |  8 +++---
 third_party/blink/renderer/core/dom/node.cc   |  6 ++--
 third_party/blink/renderer/core/dom/node.h    |  2 ++
 .../blink/renderer/core/dom/node_traversal.cc | 28 +++++++++++--------
 .../blink/renderer/core/dom/node_traversal.h  | 12 +++++---
 6 files changed, 40 insertions(+), 25 deletions(-)

--- a/third_party/blink/renderer/core/dom/container_node.cc
+++ b/third_party/blink/renderer/core/dom/container_node.cc
@@ -400,9 +400,10 @@
   // 2. Let reference child be child.
   // 3. If reference child is node, set it to node’s next sibling.
   if (ref_child == new_child) {
-    ref_child = new_child->nextSibling();
-    if (!ref_child)
+    if (!new_child->HasNextSibling()) {
       return AppendChild(new_child, exception_state);
+    }
+    ref_child = new_child->nextSibling();
   }
 
   // 4. Adopt node into parent’s node document.
@@ -441,8 +442,8 @@
   // Use insertBefore if you need to handle reparenting (and want DOM mutation
   // events).
   DCHECK(!new_child.parentNode());
-  DCHECK(!new_child.nextSibling());
-  DCHECK(!new_child.previousSibling());
+  DCHECK(!new_child.HasNextSibling());
+  DCHECK(!new_child.HasPreviousSibling());
   DCHECK(!new_child.IsShadowRoot());
 
   Node* prev = next_child.previousSibling();
--- a/third_party/blink/renderer/core/dom/container_node.h
+++ b/third_party/blink/renderer/core/dom/container_node.h
@@ -97,7 +97,7 @@
   bool HasChildren() const { return first_child_; }
 
   bool HasOneChild() const {
-    return first_child_ && !first_child_->nextSibling();
+    return first_child_ && !first_child_->HasNextSibling();
   }
   bool HasOneTextChild() const {
     return HasOneChild() && first_child_->IsTextNode();
@@ -525,21 +525,21 @@
 }
 
 inline unsigned Node::CountChildren() const {
-  auto* this_node = DynamicTo<ContainerNode>(this);
+  auto* this_node = DynamicTo<ContainerNode>(*this);
   if (!this_node)
     return 0;
   return this_node->CountChildren();
 }
 
 inline Node* Node::firstChild() const {
-  auto* this_node = DynamicTo<ContainerNode>(this);
+  auto* this_node = DynamicTo<ContainerNode>(*this);
   if (!this_node)
     return nullptr;
   return this_node->firstChild();
 }
 
 inline Node* Node::lastChild() const {
-  auto* this_node = DynamicTo<ContainerNode>(this);
+  auto* this_node = DynamicTo<ContainerNode>(*this);
   if (!this_node)
     return nullptr;
   return this_node->lastChild();
--- a/third_party/blink/renderer/core/dom/node.cc
+++ b/third_party/blink/renderer/core/dom/node.cc
@@ -374,8 +374,9 @@
 
 Node* Node::PseudoAwarePreviousSibling() const {
   Element* parent = parentElement();
-  if (!parent || previousSibling())
+  if (!parent || HasPreviousSibling()) {
     return previousSibling();
+  }
   switch (GetPseudoId()) {
     case kPseudoIdAfter:
       if (Node* previous = parent->lastChild())
@@ -399,8 +400,9 @@
 
 Node* Node::PseudoAwareNextSibling() const {
   Element* parent = parentElement();
-  if (!parent || nextSibling())
+  if (!parent || HasNextSibling()) {
     return nextSibling();
+  }
   switch (GetPseudoId()) {
     case kPseudoIdMarker:
       if (Node* next = parent->GetPseudoElement(kPseudoIdBefore))
--- a/third_party/blink/renderer/core/dom/node.h
+++ b/third_party/blink/renderer/core/dom/node.h
@@ -222,7 +222,9 @@
   ContainerNode* ParentElementOrShadowRoot() const;
   ContainerNode* ParentElementOrDocumentFragment() const;
   Node* previousSibling() const { return previous_; }
+  bool HasPreviousSibling() const { return previous_; }
   Node* nextSibling() const { return next_; }
+  bool HasNextSibling() const { return next_; }
   NodeList* childNodes();
   Node* firstChild() const;
   Node* lastChild() const;
--- a/third_party/blink/renderer/core/dom/node_traversal.cc
+++ b/third_party/blink/renderer/core/dom/node_traversal.cc
@@ -69,23 +69,25 @@
 }
 
 Node* NodeTraversal::NextAncestorSibling(const Node& current) {
-  DCHECK(!current.nextSibling());
+  DCHECK(!current.HasNextSibling());
   for (Node& parent : AncestorsOf(current)) {
-    if (parent.nextSibling())
+    if (parent.HasNextSibling()) {
       return parent.nextSibling();
+    }
   }
   return nullptr;
 }
 
 Node* NodeTraversal::NextAncestorSibling(const Node& current,
                                          const Node* stay_within) {
-  DCHECK(!current.nextSibling());
+  DCHECK(!current.HasNextSibling());
   DCHECK_NE(current, stay_within);
   for (Node& parent : AncestorsOf(current)) {
     if (parent == stay_within)
       return nullptr;
-    if (parent.nextSibling())
+    if (parent.HasNextSibling()) {
       return parent.nextSibling();
+    }
   }
   return nullptr;
 }
@@ -107,7 +109,7 @@
 Node* NodeTraversal::Previous(const Node& current, const Node* stay_within) {
   if (current == stay_within)
     return nullptr;
-  if (current.previousSibling()) {
+  if (current.HasPreviousSibling()) {
     Node* previous = current.previousSibling();
     while (Node* child = previous->lastChild())
       previous = child;
@@ -133,8 +135,9 @@
   for (Node& node : InclusiveAncestorsOf(current)) {
     if (node == stay_within)
       return nullptr;
-    if (Node* prev = node.previousSibling())
-      return prev;
+    if (node.HasPreviousSibling()) {
+      return node.previousSibling();
+    }
   }
   return nullptr;
 }
@@ -143,8 +146,9 @@
                                    const Node* stay_within) {
   if (current == stay_within)
     return nullptr;
-  if (!current.nextSibling())
+  if (!current.HasNextSibling()) {
     return current.parentNode();
+  }
   Node* next = current.nextSibling();
   while (Node* child = next->firstChild())
     next = child;
@@ -153,12 +157,13 @@
 
 Node* NodeTraversal::PreviousAncestorSiblingPostOrder(const Node& current,
                                                       const Node* stay_within) {
-  DCHECK(!current.previousSibling());
+  DCHECK(!current.HasPreviousSibling());
   for (Node& parent : NodeTraversal::AncestorsOf(current)) {
     if (parent == stay_within)
       return nullptr;
-    if (parent.previousSibling())
+    if (parent.HasPreviousSibling()) {
       return parent.previousSibling();
+    }
   }
   return nullptr;
 }
@@ -169,8 +174,9 @@
     return last_child;
   if (current == stay_within)
     return nullptr;
-  if (current.previousSibling())
+  if (current.HasPreviousSibling()) {
     return current.previousSibling();
+  }
   return PreviousAncestorSiblingPostOrder(current, stay_within);
 }
 
--- a/third_party/blink/renderer/core/dom/node_traversal.h
+++ b/third_party/blink/renderer/core/dom/node_traversal.h
@@ -194,8 +194,9 @@
 inline Node* NodeTraversal::TraverseNextTemplate(NodeType& current) {
   if (current.hasChildren())
     return current.firstChild();
-  if (current.nextSibling())
+  if (current.HasNextSibling()) {
     return current.nextSibling();
+  }
   return NextAncestorSibling(current);
 }
 
@@ -206,14 +207,16 @@
     return current.firstChild();
   if (current == stay_within)
     return nullptr;
-  if (current.nextSibling())
+  if (current.HasNextSibling()) {
     return current.nextSibling();
+  }
   return NextAncestorSibling(current, stay_within);
 }
 
 inline Node* NodeTraversal::NextSkippingChildren(const Node& current) {
-  if (current.nextSibling())
+  if (current.HasNextSibling()) {
     return current.nextSibling();
+  }
   return NextAncestorSibling(current);
 }
 
@@ -221,8 +224,9 @@
                                                  const Node* stay_within) {
   if (current == stay_within)
     return nullptr;
-  if (current.nextSibling())
+  if (current.HasNextSibling()) {
     return current.nextSibling();
+  }
   return NextAncestorSibling(current, stay_within);
 }
 
