From 751463ce650b83c96c7f63a7e8c198dfeb6a90ce Mon Sep 17 00:00:00 2001
From: Tommy Steimel <steimel@chromium.org>
Date: Mon, 15 Jul 2024 17:31:41 +0000
Subject: [PATCH] [picture-in-picture] Fix potential crash in pip occlusion observation

This CL fixes a potential issue in
ScopedPictureInPictureOcclusionObservation where if a client
synchronously starts observing another widget on the initial
`OnOcclusionStateChanged()` callback then we end up crashing due to the
underlying `widget_observation_`.

Bug: 353039531
Change-Id: I169c23f86589825a9b07b6e1c8c1eb9a76a97faf
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5707771
Reviewed-by: Benjamin Keen <bkeen@google.com>
Commit-Queue: Tommy Steimel <steimel@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1327593}
---

--- a/chrome/browser/picture_in_picture/picture_in_picture_occlusion_tracker_unittest.cc
+++ b/chrome/browser/picture_in_picture/picture_in_picture_occlusion_tracker_unittest.cc
@@ -14,6 +14,7 @@
 namespace {
 
 using testing::_;
+using testing::Invoke;
 
 class MockPictureInPictureOcclusionObserver
     : public PictureInPictureOcclusionObserver {
@@ -269,4 +270,39 @@
   occludable_widget1.reset();
 }
 
+// Regression test for https://crbug/com/353039531.
+TEST_F(PictureInPictureOcclusionTrackerTest,
+       SynchronouslyReobservingDoesNotCrash) {
+  MockPictureInPictureOcclusionObserver observer;
+  ScopedPictureInPictureOcclusionObservation observation(&observer);
+  std::unique_ptr<views::Widget> picture_in_picture_widget =
+      CreatePictureInPictureWidget();
+
+  // Create a widget to track the occlusion state of, placing it so that it
+  // starts out occluded.
+  std::unique_ptr<views::Widget> occludable_widget1 =
+      CreateTestWidget(views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET);
+  occludable_widget1->Show();
+  occludable_widget1->SetBounds({50, 50, 200, 200});
+
+  // Create a second widget to observe in the `OnOcclusionStateChanged`
+  // callback.
+  std::unique_ptr<views::Widget> occludable_widget2 =
+      CreateTestWidget(views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET);
+  occludable_widget2->Show();
+
+  EXPECT_CALL(observer, OnOcclusionStateChanged(true)).WillOnce(Invoke([&]() {
+    testing::Mock::VerifyAndClearExpectations(&observer);
+
+    // Synchronously start observing the second widget when we see that the
+    // first is occluded. This should not crash.
+    observation.Observe(occludable_widget2.get());
+  }));
+
+  // Start observing `occludable_widget`. This should immediately inform the
+  // observer that the window is occluded and therefore synchronously start
+  // observing `occludable_widget2`.
+  observation.Observe(occludable_widget1.get());
+}
+
 }  // namespace
--- a/chrome/browser/picture_in_picture/scoped_picture_in_picture_occlusion_observation.cc
+++ b/chrome/browser/picture_in_picture/scoped_picture_in_picture_occlusion_observation.cc
@@ -45,8 +45,8 @@
       base::ScopedObservation<PictureInPictureOcclusionTracker,
                               PictureInPictureOcclusionTrackerObserver>>(
       observer_.get());
-  observation_->Observe(tracker);
   widget_observation_.Observe(widget);
+  observation_->Observe(tracker);
 }
 
 void ScopedPictureInPictureOcclusionObservation::OnWidgetDestroying(
