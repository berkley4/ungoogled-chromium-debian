From 543a94e73eec0ac981122c35a05a00feb12c1b40 Mon Sep 17 00:00:00 2001
From: Rakina Zata Amni <rakina@chromium.org>
Date: Tue, 16 Jul 2024 05:24:49 +0000
Subject: [PATCH] Return v8::Undefined instead of empty value in DOMWindow::Wrap()

Returning an empty value will result in crashes later on, so
return an undefined value instead.

Bug: 41494798
Change-Id: I87bc87f8fd1e9c2f901895c6b701586b4bc9e0d1
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5706212
Reviewed-by: Yuki Shiino <yukishiino@chromium.org>
Commit-Queue: Rakina Zata Amni <rakina@chromium.org>
Reviewed-by: Michael Lippautz <mlippautz@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1327960}
---

--- a/third_party/blink/renderer/bindings/core/v8/window_proxy.cc
+++ b/third_party/blink/renderer/bindings/core/v8/window_proxy.cc
@@ -80,7 +80,7 @@
   DisposeContext(Lifecycle::kV8MemoryIsForciblyPurged, kFrameWillNotBeReused);
 }
 
-v8::Local<v8::Object> WindowProxy::GlobalProxyIfNotDetached() {
+v8::MaybeLocal<v8::Object> WindowProxy::GlobalProxyIfNotDetached() {
   if (lifecycle_ == Lifecycle::kContextIsInitialized) {
     DLOG_IF(FATAL, !is_global_object_attached_)
         << "Context is initialized but global object is detached!";
--- a/third_party/blink/renderer/bindings/core/v8/window_proxy.h
+++ b/third_party/blink/renderer/bindings/core/v8/window_proxy.h
@@ -154,7 +154,7 @@
   void ClearForSwap();
   void ClearForV8MemoryPurge();
 
-  v8::Local<v8::Object> GlobalProxyIfNotDetached();
+  v8::MaybeLocal<v8::Object> GlobalProxyIfNotDetached();
   v8::Local<v8::Object> ReleaseGlobalProxy();
   // This does not initialize the window proxy, either Initialize or
   // InitializeIfNeeded needs to be called after this method.
--- a/third_party/blink/renderer/core/frame/dom_window.cc
+++ b/third_party/blink/renderer/core/frame/dom_window.cc
@@ -83,14 +83,20 @@
   if (!frame)
     return v8::Null(script_state->GetIsolate());
 
-  // TODO(yukishiino): Make this function always return the non-empty handle
-  // even if the frame is detached because the global proxy must always exist
-  // per spec.
+  // TODO(yukishiino): We'd like to return a global proxy instead of undefined
+  // regardless of whether it's detached or not, in order to conform to spec.
   //
   // Getting the proxy also results in initializing it and eventually yields in
   // `SetupWindowPrototypeChain()` calls for the window proxy.
-  return frame->GetWindowProxy(script_state->World())
-      ->GlobalProxyIfNotDetached();
+  v8::MaybeLocal<v8::Object> proxy =
+      frame->GetWindowProxy(script_state->World())->GlobalProxyIfNotDetached();
+  if (proxy.IsEmpty()) {
+    // Return Undefined instead of an empty to avoid crashes further along the
+    // way, as `Wrap()` is expected to return a non-empty value.
+    return v8::Undefined(script_state->GetIsolate());
+  } else {
+    return proxy.ToLocalChecked();
+  }
 }
 
 v8::Local<v8::Object> DOMWindow::AssociateWithWrapper(
--- a/third_party/blink/renderer/core/frame/web_remote_frame_impl.cc
+++ b/third_party/blink/renderer/core/frame/web_remote_frame_impl.cc
@@ -398,7 +398,8 @@
     v8::Isolate* isolate) const {
   return GetFrame()
       ->GetWindowProxy(DOMWrapperWorld::MainWorld(isolate))
-      ->GlobalProxyIfNotDetached();
+      ->GlobalProxyIfNotDetached()
+      .ToLocalChecked();
 }
 
 gfx::Rect WebRemoteFrameImpl::GetCompositingRect() {
