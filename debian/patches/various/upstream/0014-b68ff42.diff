From b68ff42ec45e46b37a2731b513aa2bd8b5e3eb0b Mon Sep 17 00:00:00 2001
From: Yoshisato Yanagisawa <yyanagisawa@chromium.org>
Date: Thu, 28 Mar 2024 14:29:06 +0000
Subject: [PATCH] Prevent calling CountFeature() until ContainerInfoForClient is sent

When AssociatedRemote is used, its method must not be called before the
AssociatedReceiver is sent to a counter part. Otherwise, the mojo call
will crash. We expected DCHECK find this out, but it actually seems not
and hit by a null pointer exception in crbug.com/40918057.

This change adds an additional flag that is only updated when the
associated receiver has been sent to the renderer so that CountFeature()
won't be called before the associated receiver has been sent.

Bug: 40918057
Change-Id: Ia889caed7e2fbaab36bdcc42142236605c59c302
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5400180
Reviewed-by: Shunya Shishido <sisidovski@chromium.org>
Reviewed-by: Rakina Zata Amni <rakina@chromium.org>
Reviewed-by: Minoru Chikamune <chikamune@chromium.org>
Auto-Submit: Yoshisato Yanagisawa <yyanagisawa@chromium.org>
Reviewed-by: Hiroki Nakagawa <nhiroki@chromium.org>
Commit-Queue: Rakina Zata Amni <rakina@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1279624}
---

--- a/content/browser/renderer_host/navigation_request.cc
+++ b/content/browser/renderer_host/navigation_request.cc
@@ -6020,6 +6020,9 @@
       std::move(subresource_loader_params_), std::move(subresource_overrides_),
       std::move(service_worker_container_info), document_token_,
       devtools_navigation_token_);
+  if (service_worker_handle_ && service_worker_handle_->container_host()) {
+    service_worker_handle_->container_host()->SetContainerReady();
+  }
   UpdateNavigationHandleTimingsOnCommitSent();
 
   // Give SpareRenderProcessHostManager a heads-up about the most recently used
--- a/content/browser/service_worker/service_worker_container_host.cc
+++ b/content/browser/service_worker/service_worker_container_host.cc
@@ -12,6 +12,7 @@
 #include "base/debug/crash_logging.h"
 #include "base/functional/callback_helpers.h"
 #include "base/functional/overloaded.h"
+#include "base/metrics/histogram_functions.h"
 #include "base/strings/stringprintf.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/uuid.h"
@@ -73,6 +74,18 @@
   return control;
 }
 
+// These values are persisted to logs. Entries should not be renumbered and
+// numeric values should never be reused.
+// TODO(crbug.com/40918057): remove this metrics if we confirm that
+// kContainerNotReady prevents calling the CountFeature IPC.
+enum class CountFeatureDropOutReason {
+  kOk = 0,
+  kContainerNotReady = 1,
+  kExecutionNotReady = 2,
+  kNotBoundOrNotConnected = 3,
+  kMaxValue = kNotBoundOrNotConnected,
+};
+
 }  // namespace
 
 // RAII helper class for keeping track of versions waiting for an update hint
@@ -621,23 +634,45 @@
     blink::mojom::WebFeature feature) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   SCOPED_CRASH_KEY_NUMBER("SWCH_CF", "feature", static_cast<int32_t>(feature));
+  SCOPED_CRASH_KEY_NUMBER("SWCH_CF", "client_type",
+                          static_cast<int32_t>(GetClientType()));
+
+  constexpr char kDropOutMetrics[] = "ServiceWorker.CountFeature.DropOut";
 
   // CountFeature is a message about the client's controller. It should be sent
   // only for clients.
   DCHECK(IsContainerForClient());
 
+  // `container_` can be used only if ServiceWorkerContainerInfoForClient has
+  // been passed to the renderer process. Otherwise, the method call will crash
+  // inside the mojo library (See crbug.com/40918057).
+  if (!is_container_ready_) {
+    // TODO(crbug.com/331682623): Record WebFeature to be resent after the
+    // container become ready.
+    base::UmaHistogramEnumeration(
+        kDropOutMetrics, CountFeatureDropOutReason::kContainerNotReady);
+    return;
+  }
+
   // And only when loading finished so the controller is really settled.
-  if (!is_execution_ready())
+  if (!is_execution_ready()) {
+    base::UmaHistogramEnumeration(
+        kDropOutMetrics, CountFeatureDropOutReason::kExecutionNotReady);
     return;
+  }
 
   // `container_` shouldn't be disconnected during the lifetime of `this` but
   // there seems a situation where `container_` is disconnected or unbound.
   // TODO(crbug.com/1136843, crbug.com/40918057): Figure out the cause and
   // remove this check.
   if (!container_.is_bound() || !container_.is_connected()) {
+    base::UmaHistogramEnumeration(
+        kDropOutMetrics, CountFeatureDropOutReason::kNotBoundOrNotConnected);
     return;
   }
 
+  base::UmaHistogramEnumeration(kDropOutMetrics,
+                                CountFeatureDropOutReason::kOk);
   container_->CountFeature(feature);
 }
 
--- a/content/browser/service_worker/service_worker_container_host.h
+++ b/content/browser/service_worker/service_worker_container_host.h
@@ -533,6 +533,8 @@
 
   ukm::SourceId ukm_source_id() const { return ukm_source_id_; }
 
+  void SetContainerReady() { is_container_ready_ = true; }
+
  private:
   class ServiceWorkerRunningStatusObserver;
   friend class ServiceWorkerContainerHostTest;
@@ -732,6 +734,12 @@
   // |container_| is the remote renderer-side ServiceWorkerContainer that |this|
   // is hosting.
   mojo::AssociatedRemote<blink::mojom::ServiceWorkerContainer> container_;
+  // |is_container_ready_| is set to be true after |container_| has been passed
+  // to the renderer process. This flag is needed to prevent |container_| used
+  // before the association to the existing message pipe, which happens when
+  // |container_| is passed to the renderer via a mojo call. Note that the mojo
+  // call's message pipe is piggy-backed.
+  bool is_container_ready_ = false;
 
   // The type of client.
   std::optional<ServiceWorkerClientInfo> client_info_;
--- a/content/browser/worker_host/dedicated_worker_host.cc
+++ b/content/browser/worker_host/dedicated_worker_host.cc
@@ -488,6 +488,9 @@
       subresource_loader_updater_.BindNewPipeAndPassReceiver(),
       std::move(controller),
       BindAndPassRemoteForBackForwardCacheControllerHost());
+  if (service_worker_handle_->container_host()) {
+    service_worker_handle_->container_host()->SetContainerReady();
+  }
 
   // |service_worker_remote_object| is an associated remote, so calls can't be
   // made on it until its receiver is sent. Now that the receiver was sent, it
--- a/content/browser/worker_host/shared_worker_host.cc
+++ b/content/browser/worker_host/shared_worker_host.cc
@@ -369,6 +369,9 @@
       receiver_.BindNewPipeAndPassRemote(), std::move(worker_receiver_),
       std::move(browser_interface_broker), ukm_source_id_,
       instance_.DoesRequireCrossSiteRequestForCookies());
+  if (service_worker_handle_->container_host()) {
+    service_worker_handle_->container_host()->SetContainerReady();
+  }
 
   // |service_worker_remote_object| is an associated interface ptr, so calls
   // can't be made on it until its request endpoint is sent. Now that the
--- a/tools/metrics/histograms/enums.xml
+++ b/tools/metrics/histograms/enums.xml
@@ -4095,6 +4095,13 @@
   <int value="2" label="Cache miss"/>
 </enum>
 
+<enum name="CountFeatureDropOutReason">
+  <int value="0" label="kOk"/>
+  <int value="1" label="kContainerNotReady"/>
+  <int value="2" label="kExecutionNotReady"/>
+  <int value="3" label="kNotBoundOrNotConnected"/>
+</enum>
+
 <enum name="CpuTimeMetricsThreadType">
   <summary>Thread types used for CPU time metric breakdowns.</summary>
   <int value="0" label="UnattributedThread">
--- a/tools/metrics/histograms/metadata/service/histograms.xml
+++ b/tools/metrics/histograms/metadata/service/histograms.xml
@@ -238,6 +238,18 @@
   </summary>
 </histogram>
 
+<histogram name="ServiceWorker.CountFeature.DropOut"
+    enum="CountFeatureDropOutReason" expires_after="2024-10-01">
+  <owner>yyanagisawa@chromium.org</owner>
+  <owner>chrome-worker@google.com</owner>
+  <summary>
+    The reason of not calling ServiceWorkerContainer::CountFeature is recorded
+    when ServiceWorkerContainerHost::CountFeature is called. This UMA is for
+    investigating crbug.com/40918057. With this UMA, we can decide which drop
+    out path can be removed.
+  </summary>
+</histogram>
+
 <histogram name="ServiceWorker.CountUse.CallerInterface"
     enum="WorkerOrWorkletInterfaceNameType" expires_after="2024-10-01">
   <owner>yyanagisawa@chromium.org</owner>
