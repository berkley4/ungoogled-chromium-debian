From 22bdee798b96942cfcf704dbefcfd89e25ef32fa Mon Sep 17 00:00:00 2001
From: Peter Kotwicz <pkotwicz@chromium.org>
Date: Wed, 17 Jul 2024 21:33:34 +0000
Subject: [PATCH] Fix LargeIconServiceImpl

This CL fixes a potential crash in
LargeIconServiceImpl::GetLargeIconFromCacheFallbackToGoogleServer() if
the CancelableTaskTracker is destroyed prior to the asynchronous call
finishing.

BUG=349393386
TEST=LargeIconServiceGetterTest.CancelableTaskTrackerDestroyedEarly

Change-Id: I785920b109b4bab5d2432de482cdceb086315582
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5656594
Reviewed-by: Mikel Astiz <mastiz@chromium.org>
Commit-Queue: Peter Kotwicz <pkotwicz@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1329140}
---

--- a/components/favicon/core/large_icon_service_impl.cc
+++ b/components/favicon/core/large_icon_service_impl.cc
@@ -398,11 +398,17 @@
     return;
   }
 
+  // `was_task_canceled_callback` tracks whether `tracker` has been destroyed.
+  base::CancelableTaskTracker::IsCanceledCallback was_task_canceled_callback;
+  tracker->NewTrackedTaskId(&was_task_canceled_callback);
+
   GetLargeIconOrFallbackStyleFromGoogleServerSkippingLocalCache(
       page_url, should_trim_page_url_path, traffic_annotation,
       base::BindOnce(&LargeIconServiceImpl::OnIconFetchedFromServer,
                      base::Unretained(this), page_url, min_source_size_in_pixel,
-                     size_in_pixel_to_resize_to, std::move(callback), tracker));
+                     size_in_pixel_to_resize_to, std::move(callback),
+                     std::move(was_task_canceled_callback),
+                     base::UnsafeDangling(tracker)));
 }
 
 void LargeIconServiceImpl::OnIconFetchedFromServer(
@@ -410,8 +416,14 @@
     int min_source_size_in_pixel,
     std::optional<int> size_in_pixel_to_resize_to,
     favicon_base::LargeIconCallback callback,
-    base::CancelableTaskTracker* tracker,
+    base::CancelableTaskTracker::IsCanceledCallback was_task_canceled_callback,
+    MayBeDangling<base::CancelableTaskTracker> tracker,
     favicon_base::GoogleFaviconServerRequestStatus status) {
+  // Check whether `tracker` has been destroyed.
+  if (was_task_canceled_callback.Run()) {
+    return;
+  }
+
   if (status == favicon_base::GoogleFaviconServerRequestStatus::SUCCESS) {
     GetLargeIconOrFallbackStyleImpl(
         page_url, min_source_size_in_pixel, size_in_pixel_to_resize_to,
--- a/components/favicon/core/large_icon_service_impl.h
+++ b/components/favicon/core/large_icon_service_impl.h
@@ -135,7 +135,9 @@
       int min_source_size_in_pixel,
       std::optional<int> size_in_pixel_to_resize_to,
       favicon_base::LargeIconCallback callback,
-      base::CancelableTaskTracker* tracker,
+      base::CancelableTaskTracker::IsCanceledCallback
+          was_task_canceled_callback,
+      MayBeDangling<base::CancelableTaskTracker> tracker,
       favicon_base::GoogleFaviconServerRequestStatus status);
 
   const raw_ptr<FaviconService> favicon_service_;
--- a/components/favicon/core/large_icon_service_impl_unittest.cc
+++ b/components/favicon/core/large_icon_service_impl_unittest.cc
@@ -373,7 +373,66 @@
 class LargeIconServiceGetterTest : public LargeIconServiceTest,
                                    public ::testing::WithParamInterface<bool> {
  public:
-  LargeIconServiceGetterTest() {}
+  struct MockDatabaseLookupResult {
+    GURL page_url;
+    favicon_base::FaviconRawBitmapResult result;
+  };
+
+  struct MockDownloadResult {
+    GURL image_url;
+    size_t image_size = 0;
+  };
+
+  LargeIconServiceGetterTest() {
+    ON_CALL(mock_favicon_service_,
+            GetLargestRawFaviconForPageURL(_, _, _, _, _))
+        .WillByDefault([this](const GURL& page_url, auto, auto,
+                              favicon_base::FaviconRawBitmapCallback callback,
+                              base::CancelableTaskTracker* tracker) {
+          MockDatabaseLookupResult mock_result =
+              (mock_database_lookup_result_.page_url == page_url)
+                  ? mock_database_lookup_result_
+                  : MockDatabaseLookupResult();
+          return tracker->PostTask(
+              base::SingleThreadTaskRunner::GetCurrentDefault().get(),
+              FROM_HERE,
+              base::BindOnce(std::move(callback), mock_result.result));
+        });
+
+    ON_CALL(*mock_image_fetcher_,
+            FetchImageAndData_(
+                Property("spec", &GURL::spec,
+                         StartsWith("https://t0.gstatic.com/faviconV2")),
+                _, _, _))
+        .WillByDefault([this](auto, auto,
+                              image_fetcher::ImageFetcherCallback* callback,
+                              auto) {
+          image_fetcher::RequestMetadata metadata;
+          metadata.content_location_header =
+              mock_download_result_.image_url.spec();
+          base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(
+              FROM_HERE,
+              base::BindOnce(std::move(*callback),
+                             gfx::test::CreateImage(
+                                 mock_download_result_.image_size, kTestColor),
+                             metadata));
+        });
+
+    ON_CALL(mock_favicon_service_,
+            SetOnDemandFavicons(_, _, favicon_base::IconType::kTouchIcon, _, _))
+        .WillByDefault([this](auto url, auto original_icon_url, auto icon_type,
+                              const gfx::Image& image,
+                              base::OnceCallback<void(bool)> callback) {
+          // Simulate persisting the fetched icon in the local cache. Avoid
+          // the complexity of transferring the data from the `image` because
+          // the tests don't care about it.
+          this->InjectMockDatabaseResult(
+              url, CreateTestBitmapResult(image.Width(), image.Height(),
+                                          kTestColor));
+          return base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(
+              FROM_HERE, base::BindOnce(std::move(callback), true));
+        });
+  }
 
   LargeIconServiceGetterTest(const LargeIconServiceGetterTest&) = delete;
   LargeIconServiceGetterTest& operator=(const LargeIconServiceGetterTest&) =
@@ -381,6 +440,14 @@
 
   ~LargeIconServiceGetterTest() override {}
 
+  void ExpectFetchImageFromGoogleServer() {
+    EXPECT_CALL(*mock_image_fetcher_,
+                FetchImageAndData_(
+                    Property("spec", &GURL::spec,
+                             StartsWith("https://t0.gstatic.com/faviconV2")),
+                    _, _, _));
+  }
+
   void GetLargeIconOrFallbackStyleAndWaitForCallback(
       const GURL& page_url,
       int min_source_size_in_pixel,
@@ -425,24 +492,22 @@
     }
   }
 
-  // The parameter `mock_result` needs to be passed by value otherwise the
-  // lambda injected into the mock may capture a reference to a temporary,
-  // which would cause Undefined Behaviour.
-  void InjectMockResult(const GURL& page_url,
-                        favicon_base::FaviconRawBitmapResult mock_result) {
-    ON_CALL(mock_favicon_service_,
-            GetLargestRawFaviconForPageURL(page_url, _, _, _, _))
-        .WillByDefault([=](auto, auto, auto,
-                           favicon_base::FaviconRawBitmapCallback callback,
-                           base::CancelableTaskTracker* tracker) {
-          return tracker->PostTask(
-              base::SingleThreadTaskRunner::GetCurrentDefault().get(),
-              FROM_HERE, base::BindOnce(std::move(callback), mock_result));
-        });
+  void InjectMockDatabaseResult(
+      const GURL& page_url,
+      const favicon_base::FaviconRawBitmapResult& mock_result) {
+    mock_database_lookup_result_.page_url = page_url;
+    mock_database_lookup_result_.result = mock_result;
+  }
+
+  void InjectMockDownloadResult(GURL image_url, size_t image_size) {
+    mock_download_result_.image_url = image_url;
+    mock_download_result_.image_size = image_size;
   }
 
  protected:
   base::CancelableTaskTracker cancelable_task_tracker_;
+  MockDatabaseLookupResult mock_database_lookup_result_;
+  MockDownloadResult mock_download_result_;
 
   std::optional<favicon_base::FallbackIconStyle> returned_fallback_style_;
   std::optional<gfx::Size> returned_bitmap_size_;
@@ -458,8 +523,8 @@
   if (GetParam()) {
     return;
   }
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(16, 16, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(16, 16, kTestColor));
 
   EXPECT_CALL(mock_favicon_service_, CanSetOnDemandFavicons).Times(0);
   EXPECT_CALL(*mock_image_fetcher_, FetchImageAndData_).Times(0);
@@ -488,8 +553,9 @@
   if (GetParam()) {
     return;
   }
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(16, 16, kTestColor));
+
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(16, 16, kTestColor));
 
   EXPECT_CALL(mock_favicon_service_, CanSetOnDemandFavicons).Times(0);
   EXPECT_CALL(*mock_image_fetcher_, FetchImageAndData_).Times(0);
@@ -520,8 +586,8 @@
     return;
   }
   // Inject an icon which size is smaller than the requested one.
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(16, 16, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(16, 16, kTestColor));
 
   // Configure the Google server to return a 64x64 icon.
   const GURL kExpectedOriginalUrl("http://www.example.com/favicon.png");
@@ -558,20 +624,13 @@
   }
 
   // Configure `FaviconService` to return no icon for the `kDummyPageUrl`.
-  ON_CALL(mock_favicon_service_,
-          GetLargestRawFaviconForPageURL(GURL(kDummyPageUrl), _, _, _, _))
-      .WillByDefault([=](auto, auto, auto,
-                         favicon_base::FaviconRawBitmapCallback callback,
-                         base::CancelableTaskTracker* tracker) {
-        return tracker->PostTask(
-            base::SingleThreadTaskRunner::GetCurrentDefault().get(), FROM_HERE,
-            base::BindOnce(std::move(callback),
-                           favicon_base::FaviconRawBitmapResult()));
-      });
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           favicon_base::FaviconRawBitmapResult());
 
+  // Configure the Google server to return a 64x64 icon.
   const GURL kExpectedOriginalUrl("http://www.example.com/favicon.png");
+  InjectMockDownloadResult(kExpectedOriginalUrl, /*image_size=*/64);
 
-  // Configure the Google server to return a 64x64 icon.
   EXPECT_CALL(mock_favicon_service_,
               CanSetOnDemandFavicons(GURL(kDummyPageUrl),
                                      favicon_base::IconType::kTouchIcon, _))
@@ -580,29 +639,65 @@
             FROM_HERE, base::BindOnce(std::move(callback), true));
       });
 
-  image_fetcher::RequestMetadata expected_metadata;
-  expected_metadata.content_location_header = kExpectedOriginalUrl.spec();
-  EXPECT_CALL(*mock_image_fetcher_,
-              FetchImageAndData_(
-                  Property("spec", &GURL::spec,
-                           StartsWith("https://t0.gstatic.com/faviconV2")),
-                  _, _, _))
-      .WillOnce(PostFetchReplyWithMetadata(
-          gfx::test::CreateImage(/*size=*/64, kTestColor), expected_metadata));
+  ExpectFetchImageFromGoogleServer();
+
   EXPECT_CALL(mock_favicon_service_,
               SetOnDemandFavicons(GURL(kDummyPageUrl), kExpectedOriginalUrl,
-                                  favicon_base::IconType::kTouchIcon, _, _))
-      .WillOnce([this](auto url, auto original_icon_url, auto icon_type,
-                       auto image, base::OnceCallback<void(bool)> callback) {
-        // Simulate persisting the fetched icon in the local cache. Avoid
-        // the complexity of transferring the data from the `image` because
-        // the tests don't care about it.
-        InjectMockResult(url, CreateTestBitmapResult(
-                                  image.Width(), image.Height(), kTestColor));
+                                  favicon_base::IconType::kTouchIcon, _, _));
+
+  // Request the icon of size exactly 32x32 for the domain, which has no icons
+  // stored locally.
+  large_icon_service_.GetLargeIconFromCacheFallbackToGoogleServer(
+      GURL(kDummyPageUrl),
+      /*min_source_size=*/LargeIconService::StandardIconSize::k32x32,
+      /*size_to_resize_to=*/LargeIconService::StandardIconSize::k32x32,
+      LargeIconService::NoBigEnoughIconBehavior::kReturnBitmap,
+      /*should_trim_page_url_path=*/false, TRAFFIC_ANNOTATION_FOR_TESTS,
+      base::BindRepeating(&LargeIconServiceGetterTest::RawBitmapResultCallback,
+                          base::Unretained(this)),
+      &cancelable_task_tracker_);
+  task_environment_.RunUntilIdle();
+
+  EXPECT_EQ(gfx::Size(32, 32), returned_bitmap_size_);
+  EXPECT_EQ(std::nullopt, returned_fallback_style_);
+}
+
+// Test that GetLargeIconFromCacheFallbackToGoogleServer() doesn't crash if the
+// CancelableTaskTracker is destroyed before the async call finishes.
+TEST_P(LargeIconServiceGetterTest, CancelableTaskTrackerDestroyedEarly) {
+  // TODO(crbug.com/337714411): Remove
+  // LargeIconService::GetLargeIconImageOrFallbackStyleForPageUrl().
+  if (GetParam()) {
+    return;
+  }
+
+  const GURL kIconUrl("http://www.example.com/favicon.png");
+
+  auto test_specific_cancelable_task_tracker =
+      std::make_unique<base::CancelableTaskTracker>();
+
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           favicon_base::FaviconRawBitmapResult());
+  InjectMockDownloadResult(kIconUrl, /*image_size=*/64);
+
+  EXPECT_CALL(mock_favicon_service_,
+              GetLargestRawFaviconForPageURL(_, _, _, _, _));
+
+  // CancelableTaskTracker is destroyed during
+  // FaviconService::CanSetOnDemandFavicons() call.
+  EXPECT_CALL(mock_favicon_service_,
+              CanSetOnDemandFavicons(GURL(kDummyPageUrl),
+                                     favicon_base::IconType::kTouchIcon, _))
+      .WillOnce([&test_specific_cancelable_task_tracker](
+                    auto, auto, base::OnceCallback<void(bool)> callback) {
+        test_specific_cancelable_task_tracker.reset();
+
         return base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(
             FROM_HERE, base::BindOnce(std::move(callback), true));
       });
 
+  ExpectFetchImageFromGoogleServer();
+
   // Request the icon of size exactly 32x32 for the domain, which has no icons
   // stored locally.
   large_icon_service_.GetLargeIconFromCacheFallbackToGoogleServer(
@@ -613,16 +708,16 @@
       /*should_trim_page_url_path=*/false, TRAFFIC_ANNOTATION_FOR_TESTS,
       base::BindRepeating(&LargeIconServiceGetterTest::RawBitmapResultCallback,
                           base::Unretained(this)),
-      &cancelable_task_tracker_);
+      test_specific_cancelable_task_tracker.get());
   task_environment_.RunUntilIdle();
 
-  EXPECT_EQ(gfx::Size(32, 32), returned_bitmap_size_);
+  EXPECT_EQ(std::nullopt, returned_bitmap_size_);
   EXPECT_EQ(std::nullopt, returned_fallback_style_);
 }
 
 TEST_P(LargeIconServiceGetterTest, SameSize) {
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(24, 24, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(24, 24, kTestColor));
   GetLargeIconOrFallbackStyleAndWaitForCallback(
       GURL(kDummyPageUrl),
       24,   // `min_source_size_in_pixel`
@@ -632,16 +727,16 @@
 }
 
 TEST_P(LargeIconServiceGetterTest, ScaleDown) {
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(32, 32, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(32, 32, kTestColor));
   GetLargeIconOrFallbackStyleAndWaitForCallback(GURL(kDummyPageUrl), 24, 24);
   EXPECT_EQ(gfx::Size(24, 24), returned_bitmap_size_);
   EXPECT_EQ(std::nullopt, returned_fallback_style_);
 }
 
 TEST_P(LargeIconServiceGetterTest, ScaleUp) {
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(16, 16, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(16, 16, kTestColor));
   GetLargeIconOrFallbackStyleAndWaitForCallback(
       GURL(kDummyPageUrl),
       14,  // Lowered requirement so stored bitmap is admitted.
@@ -652,16 +747,16 @@
 
 // `desired_size_in_pixel` == 0 means retrieve original image without scaling.
 TEST_P(LargeIconServiceGetterTest, NoScale) {
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(24, 24, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(24, 24, kTestColor));
   GetLargeIconOrFallbackStyleAndWaitForCallback(GURL(kDummyPageUrl), 16, 0);
   EXPECT_EQ(gfx::Size(24, 24), returned_bitmap_size_);
   EXPECT_EQ(std::nullopt, returned_fallback_style_);
 }
 
 TEST_P(LargeIconServiceGetterTest, FallbackSinceIconTooSmall) {
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(16, 16, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(16, 16, kTestColor));
   GetLargeIconOrFallbackStyleAndWaitForCallback(GURL(kDummyPageUrl), 24, 24);
   EXPECT_EQ(std::nullopt, returned_bitmap_size_);
   EXPECT_TRUE(HasBackgroundColor(*returned_fallback_style_, kTestColor));
@@ -670,8 +765,8 @@
 }
 
 TEST_P(LargeIconServiceGetterTest, FallbackSinceIconNotSquare) {
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(24, 32, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(24, 32, kTestColor));
   GetLargeIconOrFallbackStyleAndWaitForCallback(GURL(kDummyPageUrl), 24, 24);
   EXPECT_EQ(std::nullopt, returned_bitmap_size_);
   EXPECT_TRUE(HasBackgroundColor(*returned_fallback_style_, kTestColor));
@@ -680,7 +775,8 @@
 }
 
 TEST_P(LargeIconServiceGetterTest, FallbackSinceIconMissing) {
-  InjectMockResult(GURL(kDummyPageUrl), favicon_base::FaviconRawBitmapResult());
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           favicon_base::FaviconRawBitmapResult());
   GetLargeIconOrFallbackStyleAndWaitForCallback(GURL(kDummyPageUrl), 24, 24);
   EXPECT_EQ(std::nullopt, returned_bitmap_size_);
   EXPECT_TRUE(returned_fallback_style_->is_default_background_color);
@@ -689,7 +785,8 @@
 }
 
 TEST_P(LargeIconServiceGetterTest, FallbackSinceIconMissingNoScale) {
-  InjectMockResult(GURL(kDummyPageUrl), favicon_base::FaviconRawBitmapResult());
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           favicon_base::FaviconRawBitmapResult());
   GetLargeIconOrFallbackStyleAndWaitForCallback(GURL(kDummyPageUrl), 24, 0);
   EXPECT_EQ(std::nullopt, returned_bitmap_size_);
   EXPECT_TRUE(returned_fallback_style_->is_default_background_color);
@@ -700,8 +797,8 @@
 // Oddball case where we demand a high resolution icon to scale down. Generates
 // fallback even though an icon with the final size is available.
 TEST_P(LargeIconServiceGetterTest, FallbackSinceTooPicky) {
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(24, 24, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(24, 24, kTestColor));
   GetLargeIconOrFallbackStyleAndWaitForCallback(GURL(kDummyPageUrl), 32, 24);
   EXPECT_EQ(std::nullopt, returned_bitmap_size_);
   EXPECT_TRUE(HasBackgroundColor(*returned_fallback_style_, kTestColor));
@@ -716,8 +813,8 @@
     return;
   }
 
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(16, 16, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(16, 16, kTestColor));
   large_icon_service_.GetLargeIconRawBitmapForPageUrl(
       GURL(kDummyPageUrl), 24, std::nullopt,
       LargeIconService::NoBigEnoughIconBehavior::kReturnBitmap,
@@ -737,8 +834,8 @@
     return;
   }
 
-  InjectMockResult(GURL(kDummyPageUrl),
-                   CreateTestBitmapResult(16, 16, kTestColor));
+  InjectMockDatabaseResult(GURL(kDummyPageUrl),
+                           CreateTestBitmapResult(16, 16, kTestColor));
   large_icon_service_.GetLargeIconRawBitmapForPageUrl(
       GURL(kDummyPageUrl), 24, std::nullopt,
       LargeIconService::NoBigEnoughIconBehavior::kReturnEmpty,
