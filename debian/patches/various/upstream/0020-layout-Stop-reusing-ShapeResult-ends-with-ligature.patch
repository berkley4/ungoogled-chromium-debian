From ba54c288323445f6bf93e7e6e9888450114c4d88 Mon Sep 17 00:00:00 2001
From: Yoshifumi Inoue <yosin@chromium.org>
Date: Wed, 1 Feb 2023 03:54:41 +0000
Subject: [PATCH] [layout] Stop reusing `ShapeResult` ends with ligature

This patch changes `NeedsShapeText()` to return false when `ShapeResult`
ends with ligature spans into multiple `Text` node to paint corret glyph
after text change, e.g.
    <div>abf<span>i</span><div>, we may have a ligature "fi".
change to
    <div>abf<div>

This patch also changes `NGInlineItem` and `NGInlineNode::ShapeText()`
to record whether `ShapeResult` ends with ligature or not.

Bug: 1409702
Change-Id: Id9f497f1af4c92100faf984c30f93db9f19621f8
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4206952
Commit-Queue: Yoshifumi Inoue <yosin@chromium.org>
Auto-Submit: Yoshifumi Inoue <yosin@chromium.org>
Reviewed-by: Koji Ishii <kojii@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1099639}
---
 .../core/layout/ng/inline/ng_inline_item.cc   |   6 ++-
 .../core/layout/ng/inline/ng_inline_item.h    |   7 ++++
 .../core/layout/ng/inline/ng_inline_node.cc   |  19 ++++++++-
 .../layout/ng/inline/ng_inline_node_test.cc   |  37 ++++++++++++++++++
 .../core/testing/data/GoogleSans-Regular.ttf  | Bin 0 -> 119984 bytes
 .../renderer/core/testing/page_test_base.cc   |  29 ++++++--------
 .../renderer/core/testing/page_test_base.h    |   5 +++
 7 files changed, 83 insertions(+), 20 deletions(-)
 create mode 100644 third_party/blink/renderer/core/testing/data/GoogleSans-Regular.ttf

--- a/third_party/blink/renderer/core/layout/ng/inline/ng_inline_item.cc
+++ b/third_party/blink/renderer/core/layout/ng/inline/ng_inline_item.cc
@@ -86,7 +86,8 @@
       is_empty_item_(false),
       is_block_level_(false),
       is_end_collapsible_newline_(false),
-      is_generated_for_line_break_(false) {
+      is_generated_for_line_break_(false),
+      is_unsafe_to_reuse_shape_result_(false) {
   DCHECK_GE(end, start);
   ComputeBoxProperties();
 }
@@ -110,7 +111,8 @@
       is_empty_item_(other.is_empty_item_),
       is_block_level_(other.is_block_level_),
       is_end_collapsible_newline_(other.is_end_collapsible_newline_),
-      is_generated_for_line_break_(other.is_generated_for_line_break_) {
+      is_generated_for_line_break_(other.is_generated_for_line_break_),
+      is_unsafe_to_reuse_shape_result_(other.is_unsafe_to_reuse_shape_result_) {
   DCHECK_GE(end, start);
 }
 
--- a/third_party/blink/renderer/core/layout/ng/inline/ng_inline_item.h
+++ b/third_party/blink/renderer/core/layout/ng/inline/ng_inline_item.h
@@ -85,6 +85,12 @@
   }
 
   const ShapeResult* TextShapeResult() const { return shape_result_.get(); }
+  bool IsUnsafeToReuseShapeResult() const {
+    return is_unsafe_to_reuse_shape_result_;
+  }
+  void SetUnsafeToReuseShapeResult() {
+    is_unsafe_to_reuse_shape_result_ = true;
+  }
 
   // If this item is "empty" for the purpose of empty block calculation.
   // Note: for block-in-inlines, this can't be determined until this is laid
@@ -274,6 +280,7 @@
   unsigned is_block_level_ : 1;
   unsigned is_end_collapsible_newline_ : 1;
   unsigned is_generated_for_line_break_ : 1;
+  unsigned is_unsafe_to_reuse_shape_result_ : 1;
   friend class NGInlineNode;
   friend class NGInlineNodeDataEditor;
 };
--- a/third_party/blink/renderer/core/layout/ng/inline/ng_inline_node.cc
+++ b/third_party/blink/renderer/core/layout/ng/inline/ng_inline_node.cc
@@ -407,8 +407,12 @@
     return false;
   // Text item with length==0 exists to maintain LayoutObject states such as
   // ClearNeedsLayout, but not needed to shape.
-  if (!item.Length())
+  if (!item.Length()) {
     return false;
+  }
+  if (item.IsUnsafeToReuseShapeResult()) {
+    return true;
+  }
   const ShapeResult* shape_result = item.TextShapeResult();
   if (!shape_result)
     return true;
@@ -1451,6 +1455,11 @@
     // "32" is heuristic, most major sites are up to 8 or so, wikipedia is 21.
     Vector<ShapeResult::ShapeRange, 32> text_item_ranges;
     text_item_ranges.ReserveInitialCapacity(num_text_items);
+    const bool has_ligatures =
+        shape_result->NumGlyphs() < shape_result->NumCharacters();
+    if (has_ligatures) {
+      shape_result->EnsurePositionData();
+    }
     for (; index < end_index; index++) {
       NGInlineItem& item = (*items)[index];
       if (item.Type() != NGInlineItem::kText || !item.Length())
@@ -1466,6 +1475,14 @@
           ShapeResult::CreateEmpty(*shape_result.get());
       text_item_ranges.emplace_back(item.StartOffset(), item.EndOffset(),
                                     item_result.get());
+      if (has_ligatures && item.EndOffset() < shape_result->EndIndex() &&
+          shape_result->CachedNextSafeToBreakOffset(item.EndOffset()) !=
+              item.EndOffset()) {
+        // Note: We should not reuse `ShapeResult` ends with ligature glyph.
+        // e.g. <div>f<span>i</div> to <div>f</div> with ligature "fi".
+        // See http://crbug.com/1409702
+        item.SetUnsafeToReuseShapeResult();
+      }
       item.shape_result_ = std::move(item_result);
     }
     DCHECK_EQ(text_item_ranges.size(), num_text_items);
