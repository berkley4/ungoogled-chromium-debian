From 4862b4da110b51f193b033d7943be47e15437bfc Mon Sep 17 00:00:00 2001
From: Ari Chivukula <arichiv@chromium.org>
Date: Wed, 24 Jul 2024 20:59:34 +0000
Subject: [PATCH] [SAA] Fix remote disconnection issue with GC & handles

There's a bug where if the SAA handle falls out of scope, connections
between other objects (like Broadcast Channels) allocated from the
handle cease to work.
https://github.com/privacysandbox/privacy-sandbox-dev-support/issues/398

Let's add a test for the impacts of GC and transfer ownership of key
remotes/objects to a per-window-global to prevent disconnection issues.

I have confirmed this test crashes due to disconnection on trunk, and
succeeds here.

Fixed: 355018914
Change-Id: I1e760964a9927293b8a21565afe55360a100e8aa
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5736256
Reviewed-by: Ben Kelly <wanderview@chromium.org>
Commit-Queue: Ayu Ishii <ayui@chromium.org>
Reviewed-by: Chris Fredrickson <cfredric@chromium.org>
Auto-Submit: Ari Chivukula <arichiv@chromium.org>
Reviewed-by: Ayu Ishii <ayui@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1332592}
---

--- a/third_party/blink/renderer/core/fileapi/public_url_manager.cc
+++ b/third_party/blink/renderer/core/fileapi/public_url_manager.cc
@@ -132,7 +132,7 @@
 }
 
 PublicURLManager::PublicURLManager(
-    base::PassKey<StorageAccessHandle>,
+    base::PassKey<GlobalStorageAccessHandle>,
     ExecutionContext* execution_context,
     mojo::PendingAssociatedRemote<mojom::blink::BlobURLStore>
         frame_url_store_remote)
--- a/third_party/blink/renderer/core/fileapi/public_url_manager.h
+++ b/third_party/blink/renderer/core/fileapi/public_url_manager.h
@@ -44,7 +44,7 @@
 
 class KURL;
 class ExecutionContext;
-class StorageAccessHandle;
+class GlobalStorageAccessHandle;
 class URLRegistry;
 class URLRegistrable;
 
@@ -54,7 +54,7 @@
  public:
   explicit PublicURLManager(ExecutionContext*);
   explicit PublicURLManager(
-      base::PassKey<StorageAccessHandle>,
+      base::PassKey<GlobalStorageAccessHandle>,
       ExecutionContext*,
       mojo::PendingAssociatedRemote<mojom::blink::BlobURLStore>);
 
--- a/third_party/blink/renderer/modules/broadcastchannel/broadcast_channel.cc
+++ b/third_party/blink/renderer/modules/broadcastchannel/broadcast_channel.cc
@@ -342,4 +342,8 @@
       WTF::BindOnce(&BroadcastChannel::OnError, WrapWeakPersistent(this)));
 }
 
+bool BroadcastChannel::IsRemoteClientConnectedForTesting() const {
+  return remote_client_.is_connected();
+}
+
 }  // namespace blink
--- a/third_party/blink/renderer/modules/broadcastchannel/broadcast_channel.h
+++ b/third_party/blink/renderer/modules/broadcastchannel/broadcast_channel.h
@@ -75,6 +75,8 @@
 
   void Trace(Visitor*) const override;
 
+  bool IsRemoteClientConnectedForTesting() const;
+
  private:
   BroadcastChannel(
       ExecutionContext*,
--- a/third_party/blink/renderer/modules/storage_access/BUILD.gn
+++ b/third_party/blink/renderer/modules/storage_access/BUILD.gn
@@ -8,6 +8,8 @@
   sources = [
     "document_storage_access.cc",
     "document_storage_access.h",
+    "global_storage_access_handle.cc",
+    "global_storage_access_handle.h",
     "storage_access_handle.cc",
     "storage_access_handle.h",
   ]
@@ -37,6 +39,7 @@
     "//testing/gtest",
     "//third_party/blink/public:test_headers",
     "//third_party/blink/renderer/controller:blink_bindings_test_sources",
+    "//third_party/blink/renderer/core:testing",
     "//third_party/blink/renderer/core:unit_test_support",
     "//third_party/blink/renderer/modules",
     "//third_party/blink/renderer/platform:test_support",
--- /dev/null
+++ b/third_party/blink/renderer/modules/storage_access/global_storage_access_handle.cc
@@ -0,0 +1,220 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/modules/storage_access/global_storage_access_handle.h"
+
+#include "third_party/blink/renderer/core/frame/navigator.h"
+#include "third_party/blink/renderer/core/frame/settings.h"
+#include "third_party/blink/renderer/modules/storage/storage_controller.h"
+
+namespace blink {
+
+using PassKey = base::PassKey<GlobalStorageAccessHandle>;
+
+// static
+const char GlobalStorageAccessHandle::kSupplementName[] =
+    "GlobalStorageAccessHandle";
+
+// static
+GlobalStorageAccessHandle& GlobalStorageAccessHandle::From(
+    LocalDOMWindow& window) {
+  GlobalStorageAccessHandle* supplement =
+      Supplement<LocalDOMWindow>::template From<GlobalStorageAccessHandle>(
+          window);
+  if (!supplement) {
+    supplement =
+        MakeGarbageCollected<GlobalStorageAccessHandle>(PassKey(), window);
+    Supplement<LocalDOMWindow>::ProvideTo(window, supplement);
+  }
+  return *supplement;
+}
+
+HeapMojoRemote<mojom::blink::StorageAccessHandle>&
+GlobalStorageAccessHandle::GetRemote() {
+  if (!remote_) {
+    mojo::PendingRemote<mojom::blink::StorageAccessHandle> remote;
+    GetSupplementable()
+        ->GetExecutionContext()
+        ->GetBrowserInterfaceBroker()
+        .GetInterface(remote.InitWithNewPipeAndPassReceiver());
+    remote_.Bind(std::move(remote),
+                 GetSupplementable()->GetExecutionContext()->GetTaskRunner(
+                     TaskType::kMiscPlatformAPI));
+  }
+  return remote_;
+}
+
+StorageArea* GlobalStorageAccessHandle::GetSessionStorageArea() {
+  if (!session_storage_area_) {
+    if (!GetSupplementable()->GetSecurityOrigin()->CanAccessSessionStorage()) {
+      return nullptr;
+    }
+    if (!GetSupplementable()->GetFrame()) {
+      return nullptr;
+    }
+    StorageNamespace* storage_namespace =
+        StorageNamespace::From(GetSupplementable()->GetFrame()->GetPage());
+    if (!storage_namespace) {
+      return nullptr;
+    }
+    session_storage_area_ = StorageArea::Create(
+        GetSupplementable(),
+        storage_namespace->GetCachedArea(
+            GetSupplementable(), {},
+            StorageNamespace::StorageContext::kStorageAccessAPI),
+        StorageArea::StorageType::kSessionStorage);
+  }
+  return session_storage_area_;
+}
+
+StorageArea* GlobalStorageAccessHandle::GetLocalStorageArea() {
+  if (!local_storage_area_) {
+    if (!GetSupplementable()->GetSecurityOrigin()->CanAccessLocalStorage()) {
+      return nullptr;
+    }
+    if (!GetSupplementable()->GetFrame()) {
+      return nullptr;
+    }
+    if (!GetSupplementable()
+             ->GetFrame()
+             ->GetSettings()
+             ->GetLocalStorageEnabled()) {
+      return nullptr;
+    }
+    scoped_refptr<CachedStorageArea> storage_area =
+        StorageController::GetInstance()->GetLocalStorageArea(
+            GetSupplementable(), {},
+            StorageNamespace::StorageContext::kStorageAccessAPI);
+    local_storage_area_ =
+        StorageArea::Create(GetSupplementable(), std::move(storage_area),
+                            StorageArea::StorageType::kLocalStorage);
+  }
+  return local_storage_area_;
+}
+
+IDBFactory* GlobalStorageAccessHandle::GetIDBFactory() {
+  if (!idb_factory_) {
+    if (!GetSupplementable()->GetSecurityOrigin()->CanAccessDatabase()) {
+      return nullptr;
+    }
+    HeapMojoRemote<mojom::blink::StorageAccessHandle>& remote = GetRemote();
+    if (!remote) {
+      return nullptr;
+    }
+    mojo::PendingRemote<mojom::blink::IDBFactory> indexed_db_remote;
+    remote->BindIndexedDB(indexed_db_remote.InitWithNewPipeAndPassReceiver());
+    idb_factory_ = MakeGarbageCollected<IDBFactory>(GetSupplementable());
+    idb_factory_->SetRemote(std::move(indexed_db_remote));
+  }
+  return idb_factory_;
+}
+
+LockManager* GlobalStorageAccessHandle::GetLockManager() {
+  if (!lock_manager_) {
+    if (!GetSupplementable()->GetSecurityOrigin()->CanAccessLocks()) {
+      return nullptr;
+    }
+    HeapMojoRemote<mojom::blink::StorageAccessHandle>& remote = GetRemote();
+    if (!remote) {
+      return nullptr;
+    }
+    mojo::PendingRemote<mojom::blink::LockManager> locks_remote;
+    remote->BindLocks(locks_remote.InitWithNewPipeAndPassReceiver());
+    lock_manager_ =
+        MakeGarbageCollected<LockManager>(*GetSupplementable()->navigator());
+    lock_manager_->SetManager(std::move(locks_remote),
+                              GetSupplementable()->GetExecutionContext());
+  }
+  return lock_manager_;
+}
+
+CacheStorage* GlobalStorageAccessHandle::GetCacheStorage() {
+  if (!cache_storage_) {
+    if (!GetSupplementable()->GetSecurityOrigin()->CanAccessCacheStorage()) {
+      return nullptr;
+    }
+    HeapMojoRemote<mojom::blink::StorageAccessHandle>& remote = GetRemote();
+    if (!remote) {
+      return nullptr;
+    }
+    mojo::PendingRemote<mojom::blink::CacheStorage> cache_remote;
+    remote->BindCaches(cache_remote.InitWithNewPipeAndPassReceiver());
+    cache_storage_ = MakeGarbageCollected<CacheStorage>(
+        GetSupplementable()->GetExecutionContext(),
+        GlobalFetch::ScopedFetcher::From(*GetSupplementable()),
+        std::move(cache_remote));
+  }
+  return cache_storage_;
+}
+
+PublicURLManager* GlobalStorageAccessHandle::GetPublicURLManager() {
+  if (!public_url_manager_) {
+    if (GetSupplementable()->GetSecurityOrigin()->IsOpaque()) {
+      return nullptr;
+    }
+    HeapMojoRemote<mojom::blink::StorageAccessHandle>& remote = GetRemote();
+    if (!remote) {
+      return nullptr;
+    }
+    mojo::PendingAssociatedRemote<mojom::blink::BlobURLStore>
+        blob_storage_remote;
+    remote->BindBlobStorage(
+        blob_storage_remote.InitWithNewEndpointAndPassReceiver());
+    public_url_manager_ = MakeGarbageCollected<PublicURLManager>(
+        PassKey(), GetSupplementable()->GetExecutionContext(),
+        std::move(blob_storage_remote));
+  }
+  return public_url_manager_;
+}
+
+HeapMojoAssociatedRemote<mojom::blink::BroadcastChannelProvider>&
+GlobalStorageAccessHandle::GetBroadcastChannelProvider() {
+  if (!broadcast_channel_provider_) {
+    if (GetSupplementable()->GetSecurityOrigin()->IsOpaque()) {
+      return broadcast_channel_provider_;
+    }
+    HeapMojoRemote<mojom::blink::StorageAccessHandle>& remote = GetRemote();
+    if (!remote) {
+      return broadcast_channel_provider_;
+    }
+    remote->BindBroadcastChannel(
+        broadcast_channel_provider_.BindNewEndpointAndPassReceiver(
+            GetSupplementable()->GetExecutionContext()->GetTaskRunner(
+                TaskType::kInternalDefault)));
+  }
+  return broadcast_channel_provider_;
+}
+
+HeapMojoRemote<mojom::blink::SharedWorkerConnector>&
+GlobalStorageAccessHandle::GetSharedWorkerConnector() {
+  if (!shared_worker_connector_) {
+    if (!GetSupplementable()->GetSecurityOrigin()->CanAccessSharedWorkers()) {
+      return shared_worker_connector_;
+    }
+    HeapMojoRemote<mojom::blink::StorageAccessHandle>& remote = GetRemote();
+    if (!remote) {
+      return shared_worker_connector_;
+    }
+    remote->BindSharedWorker(
+        shared_worker_connector_.BindNewPipeAndPassReceiver(
+            GetSupplementable()->GetExecutionContext()->GetTaskRunner(
+                TaskType::kDOMManipulation)));
+  }
+  return shared_worker_connector_;
+}
+
+void GlobalStorageAccessHandle::Trace(Visitor* visitor) const {
+  visitor->Trace(remote_);
+  visitor->Trace(session_storage_area_);
+  visitor->Trace(local_storage_area_);
+  visitor->Trace(idb_factory_);
+  visitor->Trace(lock_manager_);
+  visitor->Trace(cache_storage_);
+  visitor->Trace(public_url_manager_);
+  visitor->Trace(broadcast_channel_provider_);
+  visitor->Trace(shared_worker_connector_);
+  Supplement<LocalDOMWindow>::Trace(visitor);
+}
+
+}  // namespace blink
--- /dev/null
+++ b/third_party/blink/renderer/modules/storage_access/global_storage_access_handle.h
@@ -0,0 +1,72 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_STORAGE_ACCESS_GLOBAL_STORAGE_ACCESS_HANDLE_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_STORAGE_ACCESS_GLOBAL_STORAGE_ACCESS_HANDLE_H_
+
+#include "base/types/pass_key.h"
+#include "mojo/public/cpp/bindings/pending_remote.h"
+#include "third_party/blink/public/mojom/broadcastchannel/broadcast_channel.mojom-blink.h"
+#include "third_party/blink/public/mojom/storage_access/storage_access_handle.mojom-blink.h"
+#include "third_party/blink/public/mojom/worker/shared_worker_connector.mojom-blink.h"
+#include "third_party/blink/renderer/core/fileapi/public_url_manager.h"
+#include "third_party/blink/renderer/core/frame/local_dom_window.h"
+#include "third_party/blink/renderer/modules/cache_storage/cache_storage.h"
+#include "third_party/blink/renderer/modules/indexeddb/idb_factory.h"
+#include "third_party/blink/renderer/modules/locks/lock_manager.h"
+#include "third_party/blink/renderer/modules/storage/storage_area.h"
+#include "third_party/blink/renderer/platform/heap/garbage_collected.h"
+#include "third_party/blink/renderer/platform/supplementable.h"
+
+namespace blink {
+
+// This singleton-per-LocalDOMWindow owns the objects/remotes needed for any
+// StorageAccessHandle on that same LocalDOMWindow. We store them here instead
+// of on the StorageAccessHandle to avoid duplicate constructions and to prevent
+// disconnections when the handle is garbage collected.
+class GlobalStorageAccessHandle final
+    : public GarbageCollected<GlobalStorageAccessHandle>,
+      public Supplement<LocalDOMWindow> {
+ public:
+  static const char kSupplementName[];
+
+  static GlobalStorageAccessHandle& From(LocalDOMWindow& window);
+
+  explicit GlobalStorageAccessHandle(base::PassKey<GlobalStorageAccessHandle>,
+                                     LocalDOMWindow& window)
+      : Supplement<LocalDOMWindow>(window),
+        remote_(window.GetExecutionContext()),
+        broadcast_channel_provider_(window.GetExecutionContext()),
+        shared_worker_connector_(window.GetExecutionContext()) {}
+
+  HeapMojoRemote<mojom::blink::StorageAccessHandle>& GetRemote();
+  StorageArea* GetSessionStorageArea();
+  StorageArea* GetLocalStorageArea();
+  IDBFactory* GetIDBFactory();
+  LockManager* GetLockManager();
+  CacheStorage* GetCacheStorage();
+  PublicURLManager* GetPublicURLManager();
+  HeapMojoAssociatedRemote<mojom::blink::BroadcastChannelProvider>&
+  GetBroadcastChannelProvider();
+  HeapMojoRemote<mojom::blink::SharedWorkerConnector>&
+  GetSharedWorkerConnector();
+
+  void Trace(Visitor* visitor) const override;
+
+ private:
+  HeapMojoRemote<mojom::blink::StorageAccessHandle> remote_;
+  Member<StorageArea> session_storage_area_;
+  Member<StorageArea> local_storage_area_;
+  Member<IDBFactory> idb_factory_;
+  Member<LockManager> lock_manager_;
+  Member<CacheStorage> cache_storage_;
+  Member<PublicURLManager> public_url_manager_;
+  HeapMojoAssociatedRemote<mojom::blink::BroadcastChannelProvider>
+      broadcast_channel_provider_;
+  HeapMojoRemote<mojom::blink::SharedWorkerConnector> shared_worker_connector_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_STORAGE_ACCESS_GLOBAL_STORAGE_ACCESS_HANDLE_H_
--- a/third_party/blink/renderer/modules/storage_access/storage_access_handle.cc
+++ b/third_party/blink/renderer/modules/storage_access/storage_access_handle.cc
@@ -9,12 +9,10 @@
 #include "third_party/blink/renderer/bindings/modules/v8/v8_storage_estimate.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_storage_usage_details.h"
 #include "third_party/blink/renderer/core/fileapi/blob.h"
-#include "third_party/blink/renderer/core/frame/navigator.h"
-#include "third_party/blink/renderer/core/frame/settings.h"
 #include "third_party/blink/renderer/core/workers/shared_worker.h"
 #include "third_party/blink/renderer/modules/broadcastchannel/broadcast_channel.h"
 #include "third_party/blink/renderer/modules/file_system_access/storage_manager_file_system_access.h"
-#include "third_party/blink/renderer/modules/storage/storage_controller.h"
+#include "third_party/blink/renderer/modules/storage_access/global_storage_access_handle.h"
 #include "third_party/blink/renderer/platform/bindings/exception_state.h"
 
 namespace blink {
@@ -107,10 +105,7 @@
     LocalDOMWindow& window,
     const StorageAccessTypes* storage_access_types)
     : Supplement<LocalDOMWindow>(window),
-      storage_access_types_(storage_access_types),
-      remote_(window.GetExecutionContext()),
-      broadcast_channel_(window.GetExecutionContext()),
-      shared_worker_(window.GetExecutionContext()) {
+      storage_access_types_(storage_access_types) {
   window.CountUse(
       WebFeature::kStorageAccessAPI_requestStorageAccess_BeyondCookies);
   if (storage_access_types_->all()) {
@@ -176,53 +171,48 @@
         WebFeature::
             kStorageAccessAPI_requestStorageAccess_BeyondCookies_SharedWorker);
   }
+  // StorageAccessHandle is constructed in a promise, so while we are 'awaiting'
+  // we should preempt the IPC we know we will need (and let local/session
+  // storage have a chance to load from disk if needed) to ensure the latency of
+  // synchronous methods stays low.
   if (storage_access_types_->all() || storage_access_types_->sessionStorage()) {
-    InitSessionStorage();
+    GlobalStorageAccessHandle::From(window).GetSessionStorageArea();
   }
   if (storage_access_types_->all() || storage_access_types_->localStorage()) {
-    InitLocalStorage();
+    GlobalStorageAccessHandle::From(window).GetLocalStorageArea();
   }
   if (storage_access_types_->all() || storage_access_types_->indexedDB()) {
-    InitIndexedDB();
+    GlobalStorageAccessHandle::From(window).GetIDBFactory();
   }
   if (storage_access_types_->all() || storage_access_types_->locks()) {
-    InitLocks();
+    GlobalStorageAccessHandle::From(window).GetLockManager();
   }
   if (storage_access_types_->all() || storage_access_types_->caches()) {
-    InitCaches();
+    GlobalStorageAccessHandle::From(window).GetCacheStorage();
   }
   if (storage_access_types_->all() || storage_access_types_->getDirectory()) {
-    InitGetDirectory();
+    GlobalStorageAccessHandle::From(window).GetRemote();
   }
   if (storage_access_types_->all() || storage_access_types_->estimate()) {
-    InitQuota();
+    GlobalStorageAccessHandle::From(window).GetRemote();
   }
   if (storage_access_types_->all() ||
       storage_access_types_->createObjectURL() ||
       storage_access_types_->revokeObjectURL() ||
       storage_access_types_->sharedWorker()) {
-    InitBlobStorage();
+    GlobalStorageAccessHandle::From(window).GetPublicURLManager();
   }
   if (storage_access_types_->all() ||
       storage_access_types_->broadcastChannel()) {
-    InitBroadcastChannel();
+    GlobalStorageAccessHandle::From(window).GetBroadcastChannelProvider();
   }
   if (storage_access_types_->all() || storage_access_types_->sharedWorker()) {
-    InitSharedWorker();
+    GlobalStorageAccessHandle::From(window).GetSharedWorkerConnector();
   }
 }
 
 void StorageAccessHandle::Trace(Visitor* visitor) const {
   visitor->Trace(storage_access_types_);
-  visitor->Trace(session_storage_);
-  visitor->Trace(local_storage_);
-  visitor->Trace(remote_);
-  visitor->Trace(indexed_db_);
-  visitor->Trace(locks_);
-  visitor->Trace(caches_);
-  visitor->Trace(blob_storage_);
-  visitor->Trace(broadcast_channel_);
-  visitor->Trace(shared_worker_);
   ScriptWrappable::Trace(visitor);
   Supplement<LocalDOMWindow>::Trace(visitor);
 }
@@ -238,17 +228,19 @@
   window->CountUse(
       WebFeature::
           kStorageAccessAPI_requestStorageAccess_BeyondCookies_sessionStorage_Use);
-  if (!session_storage_) {
+  StorageArea* session_storage_area =
+      GlobalStorageAccessHandle::From(*window).GetSessionStorageArea();
+  if (!session_storage_area) {
     return nullptr;
   }
   if (window->GetSecurityOrigin()->IsLocal()) {
     window->CountUse(WebFeature::kFileAccessedSessionStorage);
   }
-  if (!session_storage_->CanAccessStorage()) {
+  if (!session_storage_area->CanAccessStorage()) {
     exception_state.ThrowSecurityError(StorageArea::kAccessDeniedMessage);
     return nullptr;
   }
-  return session_storage_;
+  return session_storage_area;
 }
 
 StorageArea* StorageAccessHandle::localStorage(
@@ -261,17 +253,19 @@
   window->CountUse(
       WebFeature::
           kStorageAccessAPI_requestStorageAccess_BeyondCookies_localStorage_Use);
-  if (!local_storage_) {
+  StorageArea* local_storage_area =
+      GlobalStorageAccessHandle::From(*window).GetLocalStorageArea();
+  if (!local_storage_area) {
     return nullptr;
   }
   if (window->GetSecurityOrigin()->IsLocal()) {
     window->CountUse(WebFeature::kFileAccessedLocalStorage);
   }
-  if (!local_storage_->CanAccessStorage()) {
+  if (!local_storage_area->CanAccessStorage()) {
     exception_state.ThrowSecurityError(StorageArea::kAccessDeniedMessage);
     return nullptr;
   }
-  return local_storage_;
+  return local_storage_area;
 }
 
 IDBFactory* StorageAccessHandle::indexedDB(
@@ -283,7 +277,7 @@
   GetSupplementable()->CountUse(
       WebFeature::
           kStorageAccessAPI_requestStorageAccess_BeyondCookies_indexedDB_Use);
-  return indexed_db_;
+  return GlobalStorageAccessHandle::From(*GetSupplementable()).GetIDBFactory();
 }
 
 LockManager* StorageAccessHandle::locks(ExceptionState& exception_state) const {
@@ -294,7 +288,7 @@
   GetSupplementable()->CountUse(
       WebFeature::
           kStorageAccessAPI_requestStorageAccess_BeyondCookies_locks_Use);
-  return locks_;
+  return GlobalStorageAccessHandle::From(*GetSupplementable()).GetLockManager();
 }
 
 CacheStorage* StorageAccessHandle::caches(
@@ -306,7 +300,8 @@
   GetSupplementable()->CountUse(
       WebFeature::
           kStorageAccessAPI_requestStorageAccess_BeyondCookies_caches_Use);
-  return caches_;
+  return GlobalStorageAccessHandle::From(*GetSupplementable())
+      .GetCacheStorage();
 }
 
 ScriptPromise<FileSystemDirectoryHandle> StorageAccessHandle::getDirectory(
@@ -332,12 +327,14 @@
 
 void StorageAccessHandle::GetDirectoryImpl(
     ScriptPromiseResolver<FileSystemDirectoryHandle>* resolver) const {
-  if (!remote_) {
+  HeapMojoRemote<mojom::blink::StorageAccessHandle>& remote =
+      GlobalStorageAccessHandle::From(*GetSupplementable()).GetRemote();
+  if (!remote) {
     resolver->Reject(MakeGarbageCollected<DOMException>(
         DOMExceptionCode::kInvalidStateError));
     return;
   }
-  remote_->GetDirectory(
+  remote->GetDirectory(
       WTF::BindOnce(&StorageManagerFileSystemAccess::DidGetSandboxedFileSystem,
                     WrapPersistent(resolver)));
 }
@@ -356,13 +353,15 @@
   GetSupplementable()->CountUse(
       WebFeature::
           kStorageAccessAPI_requestStorageAccess_BeyondCookies_estimate_Use);
-  if (!remote_) {
+  HeapMojoRemote<mojom::blink::StorageAccessHandle>& remote =
+      GlobalStorageAccessHandle::From(*GetSupplementable()).GetRemote();
+  if (!remote) {
     resolver->Reject(MakeGarbageCollected<DOMException>(
         DOMExceptionCode::kInvalidStateError));
     return promise;
   }
-  remote_->Estimate(WTF::BindOnce(&EstimateImplAfterRemoteEstimate,
-                                  WrapPersistent(resolver)));
+  remote->Estimate(WTF::BindOnce(&EstimateImplAfterRemoteEstimate,
+                                 WrapPersistent(resolver)));
   return promise;
 }
 
@@ -374,12 +373,18 @@
     exception_state.ThrowSecurityError(kCreateObjectURLNotRequested);
     return "";
   }
+  PublicURLManager* public_url_manager =
+      GlobalStorageAccessHandle::From(*GetSupplementable())
+          .GetPublicURLManager();
+  if (!public_url_manager) {
+    return "";
+  }
   GetSupplementable()->CountUse(
       WebFeature::
           kStorageAccessAPI_requestStorageAccess_BeyondCookies_createObjectURL_Use);
   GetSupplementable()->CountUse(WebFeature::kCreateObjectURLBlob);
   CHECK(blob);
-  return blob_storage_->RegisterURL(blob);
+  return public_url_manager->RegisterURL(blob);
 }
 
 void StorageAccessHandle::revokeObjectURL(
@@ -390,13 +395,19 @@
     exception_state.ThrowSecurityError(kRevokeObjectURLNotRequested);
     return;
   }
+  PublicURLManager* public_url_manager =
+      GlobalStorageAccessHandle::From(*GetSupplementable())
+          .GetPublicURLManager();
+  if (!public_url_manager) {
+    return;
+  }
   GetSupplementable()->CountUse(
       WebFeature::
           kStorageAccessAPI_requestStorageAccess_BeyondCookies_revokeObjectURL_Use);
   KURL resolved_url(NullURL(), url);
   GetSupplementable()->GetExecutionContext()->RemoveURLFromMemoryCache(
       resolved_url);
-  blob_storage_->Revoke(resolved_url);
+  public_url_manager->Revoke(resolved_url);
 }
 
 BroadcastChannel* StorageAccessHandle::BroadcastChannel(
@@ -408,11 +419,18 @@
     exception_state.ThrowSecurityError(kBroadcastChannelNotRequested);
     return nullptr;
   }
+  HeapMojoAssociatedRemote<mojom::blink::BroadcastChannelProvider>&
+      broadcast_channel_provider =
+          GlobalStorageAccessHandle::From(*GetSupplementable())
+              .GetBroadcastChannelProvider();
+  if (!broadcast_channel_provider) {
+    return nullptr;
+  }
   GetSupplementable()->CountUse(
       WebFeature::
           kStorageAccessAPI_requestStorageAccess_BeyondCookies_BroadcastChannel_Use);
   return MakeGarbageCollected<blink::BroadcastChannel>(
-      PassKey(), execution_context, name, broadcast_channel_.get());
+      PassKey(), execution_context, name, broadcast_channel_provider.get());
 }
 
 blink::SharedWorker* StorageAccessHandle::SharedWorker(
@@ -424,161 +442,24 @@
     exception_state.ThrowSecurityError(kSharedWorkerNotRequested);
     return nullptr;
   }
+  HeapMojoRemote<mojom::blink::SharedWorkerConnector>& shared_worker_connector =
+      GlobalStorageAccessHandle::From(*GetSupplementable())
+          .GetSharedWorkerConnector();
+  if (!shared_worker_connector) {
+    return nullptr;
+  }
+  PublicURLManager* public_url_manager =
+      GlobalStorageAccessHandle::From(*GetSupplementable())
+          .GetPublicURLManager();
+  if (!public_url_manager) {
+    return nullptr;
+  }
   GetSupplementable()->CountUse(
       WebFeature::
           kStorageAccessAPI_requestStorageAccess_BeyondCookies_SharedWorker_Use);
   return SharedWorker::Create(PassKey(), context, url, name_or_options,
-                              exception_state, blob_storage_, &shared_worker_);
-}
-
-void StorageAccessHandle::InitSessionStorage() {
-  LocalDOMWindow* window = GetSupplementable();
-  if (!window->GetSecurityOrigin()->CanAccessSessionStorage()) {
-    return;
-  }
-  if (!window->GetFrame()) {
-    return;
-  }
-  StorageNamespace* storage_namespace =
-      StorageNamespace::From(window->GetFrame()->GetPage());
-  if (!storage_namespace) {
-    return;
-  }
-  session_storage_ = StorageArea::Create(
-      window,
-      storage_namespace->GetCachedArea(
-          window, {}, StorageNamespace::StorageContext::kStorageAccessAPI),
-      StorageArea::StorageType::kSessionStorage);
-}
-
-void StorageAccessHandle::InitLocalStorage() {
-  LocalDOMWindow* window = GetSupplementable();
-  if (!window->GetSecurityOrigin()->CanAccessLocalStorage()) {
-    return;
-  }
-  if (!window->GetFrame()) {
-    return;
-  }
-  if (!window->GetFrame()->GetSettings()->GetLocalStorageEnabled()) {
-    return;
-  }
-  auto storage_area = StorageController::GetInstance()->GetLocalStorageArea(
-      window, {}, StorageNamespace::StorageContext::kStorageAccessAPI);
-  local_storage_ = StorageArea::Create(window, std::move(storage_area),
-                                       StorageArea::StorageType::kLocalStorage);
-}
-
-HeapMojoRemote<mojom::blink::StorageAccessHandle>&
-StorageAccessHandle::InitRemote() {
-  if (!remote_) {
-    mojo::PendingRemote<mojom::blink::StorageAccessHandle> remote;
-    GetSupplementable()
-        ->GetExecutionContext()
-        ->GetBrowserInterfaceBroker()
-        .GetInterface(remote.InitWithNewPipeAndPassReceiver());
-    remote_.Bind(std::move(remote),
-                 GetSupplementable()->GetExecutionContext()->GetTaskRunner(
-                     TaskType::kMiscPlatformAPI));
-  }
-  return remote_;
-}
-
-void StorageAccessHandle::InitIndexedDB() {
-  if (!GetSupplementable()->GetSecurityOrigin()->CanAccessDatabase()) {
-    return;
-  }
-  if (!InitRemote()) {
-    return;
-  }
-  mojo::PendingRemote<mojom::blink::IDBFactory> indexed_db_remote;
-  remote_->BindIndexedDB(indexed_db_remote.InitWithNewPipeAndPassReceiver());
-  indexed_db_ = MakeGarbageCollected<IDBFactory>(GetSupplementable());
-  indexed_db_->SetRemote(std::move(indexed_db_remote));
-}
-
-void StorageAccessHandle::InitLocks() {
-  if (!GetSupplementable()->GetSecurityOrigin()->CanAccessLocks()) {
-    return;
-  }
-  if (!InitRemote()) {
-    return;
-  }
-  mojo::PendingRemote<mojom::blink::LockManager> locks_remote;
-  remote_->BindLocks(locks_remote.InitWithNewPipeAndPassReceiver());
-  locks_ = MakeGarbageCollected<LockManager>(*GetSupplementable()->navigator());
-  locks_->SetManager(std::move(locks_remote),
-                     GetSupplementable()->GetExecutionContext());
-}
-
-void StorageAccessHandle::InitCaches() {
-  if (!GetSupplementable()->GetSecurityOrigin()->CanAccessCacheStorage()) {
-    return;
-  }
-  if (!InitRemote()) {
-    return;
-  }
-  mojo::PendingRemote<mojom::blink::CacheStorage> cache_remote;
-  remote_->BindCaches(cache_remote.InitWithNewPipeAndPassReceiver());
-  caches_ = MakeGarbageCollected<CacheStorage>(
-      GetSupplementable()->GetExecutionContext(),
-      GlobalFetch::ScopedFetcher::From(*GetSupplementable()),
-      std::move(cache_remote));
-}
-
-void StorageAccessHandle::InitGetDirectory() {
-  if (!GetSupplementable()->GetSecurityOrigin()->CanAccessFileSystem()) {
-    return;
-  }
-  InitRemote();
-  // Nothing else to init as getDirectory is an async function not a handle.
-}
-
-void StorageAccessHandle::InitQuota() {
-  if (GetSupplementable()->GetSecurityOrigin()->IsOpaque()) {
-    return;
-  }
-  InitRemote();
-  // Nothing else to init as all Quota usage is via async functions.
-}
-
-void StorageAccessHandle::InitBlobStorage() {
-  if (GetSupplementable()->GetSecurityOrigin()->IsOpaque()) {
-    return;
-  }
-  if (!InitRemote()) {
-    return;
-  }
-  mojo::PendingAssociatedRemote<mojom::blink::BlobURLStore> blob_storage_remote;
-  remote_->BindBlobStorage(
-      blob_storage_remote.InitWithNewEndpointAndPassReceiver());
-  blob_storage_ = MakeGarbageCollected<PublicURLManager>(
-      PassKey(), GetSupplementable()->GetExecutionContext(),
-      std::move(blob_storage_remote));
-}
-
-void StorageAccessHandle::InitBroadcastChannel() {
-  if (GetSupplementable()->GetSecurityOrigin()->IsOpaque()) {
-    return;
-  }
-  if (!InitRemote()) {
-    return;
-  }
-  remote_->BindBroadcastChannel(
-      broadcast_channel_.BindNewEndpointAndPassReceiver(
-          GetSupplementable()->GetExecutionContext()->GetTaskRunner(
-              TaskType::kInternalDefault)));
-}
-
-void StorageAccessHandle::InitSharedWorker() {
-  if (!GetSupplementable()->GetSecurityOrigin()->CanAccessSharedWorkers()) {
-    return;
-  }
-  if (!InitRemote()) {
-    return;
-  }
-  remote_->BindSharedWorker(shared_worker_.BindNewPipeAndPassReceiver(
-      GetSupplementable()->GetExecutionContext()->GetTaskRunner(
-          TaskType::kDOMManipulation)));
+                              exception_state, public_url_manager,
+                              &shared_worker_connector);
 }
 
 namespace bindings {
--- a/third_party/blink/renderer/modules/storage_access/storage_access_handle.h
+++ b/third_party/blink/renderer/modules/storage_access/storage_access_handle.h
@@ -5,19 +5,10 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_STORAGE_ACCESS_STORAGE_ACCESS_HANDLE_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_STORAGE_ACCESS_STORAGE_ACCESS_HANDLE_H_
 
-#include "mojo/public/cpp/bindings/pending_remote.h"
-#include "third_party/blink/public/mojom/broadcastchannel/broadcast_channel.mojom-blink.h"
-#include "third_party/blink/public/mojom/storage_access/storage_access_handle.mojom-blink.h"
-#include "third_party/blink/public/mojom/worker/shared_worker_connector.mojom-blink.h"
 #include "third_party/blink/renderer/bindings/core/v8/script_promise.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_storage_access_types.h"
-#include "third_party/blink/renderer/core/fileapi/public_url_manager.h"
 #include "third_party/blink/renderer/core/frame/local_dom_window.h"
-#include "third_party/blink/renderer/modules/cache_storage/cache_storage.h"
-#include "third_party/blink/renderer/modules/indexeddb/idb_factory.h"
-#include "third_party/blink/renderer/modules/locks/lock_manager.h"
 #include "third_party/blink/renderer/modules/modules_export.h"
-#include "third_party/blink/renderer/modules/storage/storage_area.h"
 #include "third_party/blink/renderer/platform/bindings/script_wrappable.h"
 #include "third_party/blink/renderer/platform/heap/garbage_collected.h"
 #include "third_party/blink/renderer/platform/heap/member.h"
@@ -27,9 +18,13 @@
 
 class Blob;
 class BroadcastChannel;
+class CacheStorage;
 class ExceptionState;
 class FileSystemDirectoryHandle;
+class IDBFactory;
+class LockManager;
 class SharedWorker;
+class StorageArea;
 class StorageEstimate;
 class V8UnionSharedWorkerOptionsOrString;
 
@@ -81,32 +76,10 @@
       ExceptionState& exception_state) const;
 
  private:
-  void InitSessionStorage();
-  void InitLocalStorage();
-  HeapMojoRemote<mojom::blink::StorageAccessHandle>& InitRemote();
-  void InitIndexedDB();
-  void InitLocks();
-  void InitCaches();
-  void InitGetDirectory();
-  void InitQuota();
-  void InitBlobStorage();
-  void InitBroadcastChannel();
-  void InitSharedWorker();
-
   void GetDirectoryImpl(
       ScriptPromiseResolver<FileSystemDirectoryHandle>* resolver) const;
 
   Member<const StorageAccessTypes> storage_access_types_;
-  Member<StorageArea> session_storage_;
-  Member<StorageArea> local_storage_;
-  HeapMojoRemote<mojom::blink::StorageAccessHandle> remote_;
-  Member<IDBFactory> indexed_db_;
-  Member<LockManager> locks_;
-  Member<CacheStorage> caches_;
-  Member<PublicURLManager> blob_storage_;
-  HeapMojoAssociatedRemote<mojom::blink::BroadcastChannelProvider>
-      broadcast_channel_;
-  HeapMojoRemote<mojom::blink::SharedWorkerConnector> shared_worker_;
 };
 
 namespace bindings {
--- a/third_party/blink/renderer/modules/storage_access/storage_access_handle_test.cc
+++ b/third_party/blink/renderer/modules/storage_access/storage_access_handle_test.cc
@@ -5,12 +5,15 @@
 #include "third_party/blink/renderer/modules/storage_access/storage_access_handle.h"
 
 #include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/public/web/web_heap.h"
 #include "third_party/blink/renderer/bindings/core/v8/script_promise_tester.h"
 #include "third_party/blink/renderer/bindings/core/v8/v8_binding_for_testing.h"
 #include "third_party/blink/renderer/bindings/core/v8/v8_dom_exception.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_storage_access_types.h"
 #include "third_party/blink/renderer/core/frame/frame_test_helpers.h"
 #include "third_party/blink/renderer/core/frame/local_dom_window.h"
+#include "third_party/blink/renderer/core/testing/dummy_page_holder.h"
+#include "third_party/blink/renderer/modules/broadcastchannel/broadcast_channel.h"
 #include "third_party/blink/renderer/platform/testing/scoped_mocked_url.h"
 #include "third_party/blink/renderer/platform/testing/task_environment.h"
 #include "third_party/blink/renderer/platform/testing/unit_test_helpers.h"
@@ -417,4 +420,24 @@
         MakeParamsWithSetBit<12>(),
     }));
 
+TEST(StorageAccessHandleRetentionTest, Lifespan) {
+  test::TaskEnvironment task_environment;
+  std::unique_ptr<DummyPageHolder> holder =
+      DummyPageHolder::CreateAndCommitNavigation(
+          KURL("https://www.example.com"));
+  LocalDOMWindow* window = holder->GetFrame().DomWindow();
+  StorageAccessTypes* storage_access_types =
+      MakeGarbageCollected<StorageAccessTypes>();
+  storage_access_types->setBroadcastChannel(true);
+  StorageAccessHandle* storage_access_handle =
+      MakeGarbageCollected<StorageAccessHandle>(*window, storage_access_types);
+  V8TestingScope scope;
+  class BroadcastChannel* channel = storage_access_handle->BroadcastChannel(
+      scope.GetExecutionContext(), "foo", scope.GetExceptionState());
+  EXPECT_TRUE(channel->IsRemoteClientConnectedForTesting());
+  storage_access_handle = nullptr;
+  WebHeap::CollectGarbageForTesting();
+  EXPECT_TRUE(channel->IsRemoteClientConnectedForTesting());
+}
+
 }  // namespace blink
