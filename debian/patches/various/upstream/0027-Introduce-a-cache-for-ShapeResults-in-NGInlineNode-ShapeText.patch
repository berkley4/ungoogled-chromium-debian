From fabe74044d9e7465012d2290943b483ad5e7d585 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fr=C3=A9d=C3=A9ric=20Wang?= <fwang@igalia.com>
Date: Wed, 8 Mar 2023 12:19:00 +0000
Subject: [PATCH] Introduce a cache for ShapeResults in NGInlineNode::ShapeText
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This CL introduces a new runtime flag LayoutNGShapeCache and a new
NGShapeCache class in order to make possible for NGInlineNode::ShapeText
to cache and reuse ShapeResults, similar to what was done for legacy
layout.

In order to avoid any possible impact on execution speed and memory
consumption, new branches from NGInlineNode::ShapeText are skipped
quickly when the flag LayoutNGShapeCache is turned off and
FontCache::fallback_list_ng_shaper_cache_ is only instantiated on
first use.

Additionally, using cache is only allowed in very specific inline
formatting contexts. They must contain text of at most 15 characters,
be made of a single text item, must be fully selected by start/end
offsets and must not require to apply spacing to the ShapeResult.
These conditions should work well for the targeted use cases (large
tables of many repeated short strings), allow some optimizations
compared to the legacy ShapeCache and avoid the risk of introducing
new caching bugs.

Currently, NGShapeCache uses the hash calculation that was optimized
for ShapeCache in crbug.com/902789. Additionally, the following are
done to obtain a trade off between memory consumption and
performance improvement on the tested use case [1]:

1. Reduce the maximum cache size NGShapeCache::kMaxSize.
  For ShapeCache a maximum cache size of 10000 was chosen based on
  word-caching for typical Wikipedia pages, but on the tested use case,
  3000 is enough to get similar performance improvement (around 6 or
  7%). For 2000 or below, that improvement drops down below 2%.

2. When reaching NGShapeCache::kMaxSize, perform a cleanup keeping
   at most NGShapeCache::kMaxSizeAfterCleanup items among those
   having a reference counter above 1 (i.e. referenced outside the hash
   table). For kMaxSize = 2000, and kMaxSizeAfterCleanup = 1500, the
   performance improvement remains around 4% similar to the result of
   downstream experiments from November 2022.

Other approaches have been investigated but discarded so far. Partial
clearing of the cache based on how many times / whether an entry was hit
(instead of testing the reference count) did not bring interesting
performance improvement. Experiments on a dynamic max size for the cache
(version #39) shows performance improvements similar to a large
NGShapeCache::kMaxSize, but the appropriate heuristic to decide when to
grow the max size is not obvious.

Landing this CL will allow to test upstream whether this approach is not
causing any new issue and will enable downstream maintainers to
experiment and provide feedback. It can be refined in follow-up CLs.

[1] https://docs.google.com/spreadsheets/d/1kxmxSK5IToTOprCtqIFnra11Lo5isKUXKBwwMjASCbQ

Bug: 1408058
Change-Id: I7550f9153e54db008608b1055800df53ea51af8c
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4166865
Commit-Queue: Frédéric Wang <fwang@igalia.com>
Reviewed-by: Koji Ishii <kojii@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1114480}
---
 .../blink/renderer/core/css/style_engine.cc   |   1 +
 .../core/layout/ng/inline/ng_inline_node.cc   |  73 +++++++-
 third_party/blink/renderer/platform/BUILD.gn  |   3 +
 .../blink/renderer/platform/fonts/font.cc     |   4 +
 .../blink/renderer/platform/fonts/font.h      |   5 +
 .../renderer/platform/fonts/font_cache.cc     |  30 ++++
 .../renderer/platform/fonts/font_cache.h      |  16 ++
 .../platform/fonts/font_fallback_list.cc      |   1 +
 .../platform/fonts/font_fallback_list.h       |  14 ++
 .../platform/fonts/shaping/ng_shape_cache.cc  |  78 +++++++++
 .../platform/fonts/shaping/ng_shape_cache.h   | 164 ++++++++++++++++++
 .../fonts/shaping/ng_shape_cache_test.cc      |  46 +++++
 .../platform/runtime_enabled_features.json5   |   5 +
 13 files changed, 431 insertions(+), 9 deletions(-)
 create mode 100644 third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache.cc
 create mode 100644 third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache.h
 create mode 100644 third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache_test.cc

--- a/third_party/blink/renderer/core/css/style_engine.cc
+++ b/third_party/blink/renderer/core/css/style_engine.cc
@@ -824,6 +824,7 @@
   if (resolver_) {
     resolver_->InvalidateMatchedPropertiesCache();
   }
+  FontCache::Get().InvalidateNGShapeCache();
   FontCache::Get().InvalidateShapeCache();
 }
 
--- a/third_party/blink/renderer/core/layout/ng/inline/ng_inline_node.cc
+++ b/third_party/blink/renderer/core/layout/ng/inline/ng_inline_node.cc
@@ -46,10 +46,12 @@
 #include "third_party/blink/renderer/core/style/computed_style_base_constants.h"
 #include "third_party/blink/renderer/platform/fonts/font_performance.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/run_segmenter.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_spacing.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
 #include "third_party/blink/renderer/platform/heap/collection_support/clear_collection_scope.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_buffer.h"
 
@@ -99,14 +101,37 @@
 
  public:
   ReusingTextShaper(NGInlineItemsData* data,
-                    const HeapVector<NGInlineItem>* reusable_items)
+                    const HeapVector<NGInlineItem>* reusable_items,
+                    const bool allow_shape_cache)
       : data_(*data),
         reusable_items_(reusable_items),
-        shaper_(data->text_content) {}
+        shaper_(data->text_content),
+        allow_shape_cache_(allow_shape_cache) {}
 
-  scoped_refptr<ShapeResult> Shape(const NGInlineItem& start_item,
-                                   const Font& font,
-                                   unsigned end_offset) {
+  scoped_refptr<const ShapeResult> Shape(const NGInlineItem& start_item,
+                                         const Font& font,
+                                         unsigned end_offset) {
+    ShapeCacheEntry* entry = nullptr;
+    if (allow_shape_cache_) {
+      DCHECK(RuntimeEnabledFeatures::LayoutNGShapeCacheEnabled());
+      NGShapeCache* cache = font.GetNGShapeCache();
+      const TextDirection direction = start_item.Direction();
+      entry = cache->Add(shaper_.GetText(), direction);
+      if (entry && *entry) {
+        return *entry;
+      }
+    }
+    scoped_refptr<const ShapeResult> result =
+        ShapeWithoutCache(start_item, font, end_offset);
+    if (entry) {
+      *entry = result;
+    }
+    return result;
+  }
+
+  scoped_refptr<ShapeResult> ShapeWithoutCache(const NGInlineItem& start_item,
+                                               const Font& font,
+                                               unsigned end_offset) {
     const unsigned start_offset = start_item.StartOffset();
     DCHECK_LT(start_offset, end_offset);
 
@@ -212,6 +237,7 @@
   NGInlineItemsData& data_;
   const HeapVector<NGInlineItem>* const reusable_items_;
   HarfBuzzShaper shaper_;
+  const bool allow_shape_cache_;
 };
 
 // The function is templated to indicate the purpose of collected inlines:
@@ -1224,10 +1250,36 @@
   const String& text_content = data->text_content;
   HeapVector<NGInlineItem>* items = &data->items;
 
-  // Provide full context of the entire node to the shaper.
-  ReusingTextShaper shaper(data, previous_items);
   ShapeResultSpacing<String> spacing(text_content, IsSvgText());
 
+  // For consistency with similar usages of ShapeCache (e.g. canvas) and in
+  // order to avoid caching bugs (e.g. with scripts having Arabic joining)
+  // NGShapeCache is only enabled when the IFC is made of a single text item. To
+  // be efficient, NGShapeCache only stores entries for short strings and
+  // without memory copy, so don't allow it if the text item is too long or if
+  // the start/end offsets match a substring. Don't allow it either if a call to
+  // ApplySpacing is needed to avoid a costly copy of the ShapeResult in the
+  // loop below.
+  auto ShapeCacheAllowedFor = [&override_font, &spacing,
+                               &text_content](const NGInlineItem& single_item) {
+    if (!(single_item.Type() == NGInlineItem::kText &&
+          single_item.StartOffset() == 0 &&
+          single_item.EndOffset() == text_content.length())) {
+      return false;
+    }
+    const Font& font =
+        override_font ? *override_font : single_item.FontWithSvgScaling();
+    return !spacing.SetSpacing(font.GetFontDescription());
+  };
+
+  const bool allow_shape_cache =
+      RuntimeEnabledFeatures::LayoutNGShapeCacheEnabled() &&
+      text_content.length() <= NGShapeCache::MaxTextLengthOfEntries() &&
+      items->size() == 1 && ShapeCacheAllowedFor((*items)[0]);
+
+  // Provide full context of the entire node to the shaper.
+  ReusingTextShaper shaper(data, previous_items, allow_shape_cache);
+
   DCHECK(!data->segments ||
          data->segments->EndOffset() == text_content.length());
 
@@ -1352,12 +1404,15 @@
     }
 
     // Shape each item with the full context of the entire node.
-    scoped_refptr<ShapeResult> shape_result =
+    scoped_refptr<const ShapeResult> shape_result =
         shaper.Shape(start_item, font, end_offset);
 
     if (UNLIKELY(spacing.SetSpacing(font.GetFontDescription()))) {
       DCHECK(!IsTextCombine()) << GetLayoutBlockFlow();
-      shape_result->ApplySpacing(spacing);
+      DCHECK(!allow_shape_cache);
+      // The ShapeResult is actually not a reusable entry of NGShapeCache,
+      // so it is safe to mutate it.
+      const_cast<ShapeResult*>(shape_result.get())->ApplySpacing(spacing);
     }
 
     // If the text is from one item, use the ShapeResult as is.
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -702,6 +702,8 @@
     "fonts/shaping/harfbuzz_font_data.h",
     "fonts/shaping/harfbuzz_shaper.cc",
     "fonts/shaping/harfbuzz_shaper.h",
+    "fonts/shaping/ng_shape_cache.cc",
+    "fonts/shaping/ng_shape_cache.h",
     "fonts/shaping/run_segmenter.cc",
     "fonts/shaping/run_segmenter.h",
     "fonts/shaping/shape_cache.h",
@@ -2063,6 +2065,7 @@
     "fonts/shaping/caching_word_shaper_test.cc",
     "fonts/shaping/font_features_test.cc",
     "fonts/shaping/harfbuzz_shaper_test.cc",
+    "fonts/shaping/ng_shape_cache_test.cc",
     "fonts/shaping/run_segmenter_test.cc",
     "fonts/shaping/shape_result_bloberizer_test.cc",
     "fonts/shaping/shape_result_run_info_test.cc",
--- a/third_party/blink/renderer/platform/fonts/font.cc
+++ b/third_party/blink/renderer/platform/fonts/font.cc
@@ -495,6 +495,10 @@
   return shaper.OffsetForPosition(run, x_float, partial_glyphs, break_glyphs);
 }
 
+NGShapeCache* Font::GetNGShapeCache() const {
+  return EnsureFontFallbackList()->GetNGShapeCache(font_description_);
+}
+
 ShapeCache* Font::GetShapeCache() const {
   return EnsureFontFallbackList()->GetShapeCache(font_description_);
 }
--- a/third_party/blink/renderer/platform/fonts/font.h
+++ b/third_party/blink/renderer/platform/fonts/font.h
@@ -53,6 +53,7 @@
 
 namespace blink {
 
+class NGShapeCache;
 struct CharacterRange;
 class FontSelector;
 class ShapeCache;
@@ -196,6 +197,10 @@
   // when, for whatever reason, the last resort font cannot be loaded.
   const SimpleFontData* PrimaryFont() const;
 
+  // Access the NG shape cache associated with this particular font object.
+  // Should *not* be retained across layout calls as it may become invalid.
+  NGShapeCache* GetNGShapeCache() const;
+
   // Access the shape cache associated with this particular font object.
   // Should *not* be retained across layout calls as it may become invalid.
   ShapeCache* GetShapeCache() const;
--- a/third_party/blink/renderer/platform/fonts/font_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_cache.cc
@@ -166,6 +166,24 @@
 #endif
 }
 
+NGShapeCache* FontCache::GetNGShapeCache(const FallbackListCompositeKey& key) {
+  if (!fallback_list_ng_shaper_cache_) {
+    fallback_list_ng_shaper_cache_.emplace();
+  }
+  FallbackListNGShaperCache::iterator it =
+      fallback_list_ng_shaper_cache_->find(key);
+  NGShapeCache* result = nullptr;
+  if (it == fallback_list_ng_shaper_cache_->end()) {
+    result = new NGShapeCache();
+    fallback_list_ng_shaper_cache_->Set(key, base::WrapUnique(result));
+  } else {
+    result = it->value.get();
+  }
+
+  DCHECK(result);
+  return result;
+}
+
 ShapeCache* FontCache::GetShapeCache(const FallbackListCompositeKey& key) {
   FallbackListShaperCache::iterator it = fallback_list_shaper_cache_.find(key);
   ShapeCache* result = nullptr;
@@ -286,11 +304,22 @@
   font_platform_data_cache_->Purge(*font_data_cache_);
 }
 
+void FontCache::PurgeFallbackListNGShaperCache() {
+  TRACE_EVENT0("fonts,ui", "FontCache::PurgeFallbackListNGShaperCache");
+  if (UNLIKELY(fallback_list_ng_shaper_cache_)) {
+    fallback_list_ng_shaper_cache_->clear();
+  }
+}
+
 void FontCache::PurgeFallbackListShaperCache() {
   TRACE_EVENT0("fonts,ui", "FontCache::PurgeFallbackListShaperCache");
   fallback_list_shaper_cache_.clear();
 }
 
+void FontCache::InvalidateNGShapeCache() {
+  PurgeFallbackListNGShaperCache();
+}
+
 void FontCache::InvalidateShapeCache() {
   PurgeFallbackListShaperCache();
 }
@@ -306,6 +335,7 @@
     return;
 
   PurgePlatformFontDataCache();
+  PurgeFallbackListNGShaperCache();
   PurgeFallbackListShaperCache();
 }
 
--- a/third_party/blink/renderer/platform/fonts/font_cache.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache.h
@@ -44,6 +44,7 @@
 #include "third_party/blink/renderer/platform/fonts/font_data_cache.h"
 #include "third_party/blink/renderer/platform/fonts/font_face_creation_params.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_cache.h"
 #include "third_party/blink/renderer/platform/heap/collection_support/heap_hash_set.h"
 #include "third_party/blink/renderer/platform/heap/persistent.h"
@@ -94,6 +95,11 @@
 };
 
 typedef HashMap<FallbackListCompositeKey,
+                std::unique_ptr<NGShapeCache>,
+                FallbackListCompositeKeyTraits>
+    FallbackListNGShaperCache;
+
+typedef HashMap<FallbackListCompositeKey,
                 std::unique_ptr<ShapeCache>,
                 FallbackListCompositeKeyTraits>
     FallbackListShaperCache;
@@ -155,6 +161,13 @@
 
   static String FirstAvailableOrFirst(const String&);
 
+  // Returns the NGShapeCache instance associated with the given cache key.
+  // Creates a new instance as needed and as such is guaranteed not to return
+  // a nullptr. Instances are managed by FontCache and are only guaranteed to
+  // be valid for the duration of the current session, as controlled by
+  // disable/enablePurging.
+  NGShapeCache* GetNGShapeCache(const FallbackListCompositeKey&);
+
   // Returns the ShapeCache instance associated with the given cache key.
   // Creates a new instance as needed and as such is guaranteed not to return
   // a nullptr. Instances are managed by FontCache and are only guaranteed to
@@ -275,6 +288,7 @@
       ShouldRetain = kRetain,
       bool subpixel_ascent_descent = false);
 
+  void InvalidateNGShapeCache();
   void InvalidateShapeCache();
 
   static void CrashWithFontInfo(const FontDescription*);
@@ -395,6 +409,7 @@
   bool platform_init_ = false;
   Persistent<HeapHashSet<WeakMember<FontCacheClient>>> font_cache_clients_;
   std::unique_ptr<FontPlatformDataCache> font_platform_data_cache_;
+  absl::optional<FallbackListNGShaperCache> fallback_list_ng_shaper_cache_;
   FallbackListShaperCache fallback_list_shaper_cache_;
 
   std::unique_ptr<FontDataCache> font_data_cache_;
@@ -402,6 +417,7 @@
   Persistent<FontFallbackMap> font_fallback_map_;
 
   void PurgePlatformFontDataCache();
+  void PurgeFallbackListNGShaperCache();
   void PurgeFallbackListShaperCache();
 
   friend class SimpleFontData;  // For fontDataFromFontPlatformData
--- a/third_party/blink/renderer/platform/fonts/font_fallback_list.cc
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_list.cc
@@ -72,6 +72,7 @@
       FontCache::Get().ReleaseFontData(To<SimpleFontData>(font_list_[i].get()));
     }
   }
+  ng_shape_cache_.reset();  // Clear the weak pointer to the cache instance.
   shape_cache_.reset();  // Clear the weak pointer to the cache instance.
 }
 
--- a/third_party/blink/renderer/platform/fonts/font_fallback_list.h
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_list.h
@@ -25,6 +25,7 @@
 #include "third_party/blink/renderer/platform/fonts/fallback_list_composite_key.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/font_selector.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache.h"
 #include "third_party/blink/renderer/platform/fonts/shaping/shape_cache.h"
 #include "third_party/blink/renderer/platform/fonts/simple_font_data.h"
 #include "third_party/blink/renderer/platform/heap/persistent.h"
@@ -76,6 +77,18 @@
   FontSelector* GetFontSelector() const;
   uint16_t Generation() const { return generation_; }
 
+  NGShapeCache* GetNGShapeCache(const FontDescription& font_description) {
+    if (!ng_shape_cache_) {
+      FallbackListCompositeKey key = CompositeKey(font_description);
+      ng_shape_cache_ = FontCache::Get().GetNGShapeCache(key)->GetWeakPtr();
+    }
+    DCHECK(ng_shape_cache_);
+    if (GetFontSelector()) {
+      ng_shape_cache_->ClearIfVersionChanged(GetFontSelector()->Version());
+    }
+    return ng_shape_cache_.get();
+  }
+
   ShapeCache* GetShapeCache(const FontDescription& font_description) {
     if (!shape_cache_) {
       FallbackListCompositeKey key = CompositeKey(font_description);
@@ -133,6 +146,7 @@
   bool can_shape_word_by_word_computed_ : 1;
   bool is_invalid_ : 1;
 
+  base::WeakPtr<NGShapeCache> ng_shape_cache_;
   base::WeakPtr<ShapeCache> shape_cache_;
 };
 
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache.cc
@@ -0,0 +1,78 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache.h"
+
+namespace blink {
+
+// Hard limit to guard against pathological growth. This number is chosen small
+// enough to mitigate risks of memory regression while still making caching
+// efficient. It is smaller than the legacy ShapeCache::kMaxSize.
+static constexpr unsigned kMaxSize = 2000;
+
+// Maximum number of entries after a cleanup. The value must not be too large
+// so that cleanup is fast and not too frequent ; but must also not be too small
+// so that we retain enough cached entries for future reuses.
+// A value of 0 is interpreted as in the legacy ShapeCache: the hash table is
+// just cleared and NGShapeCache::AddSlowCase returns a nullptr.
+static constexpr unsigned kMaxSizeAfterCleanup = 3 * kMaxSize / 4;
+
+ShapeCacheEntry* NGShapeCache::AddSlowCase(const String& text,
+                                           TextDirection direction) {
+  SmallStringKey key(text, direction);
+  bool is_new_entry;
+  ShapeCacheEntry* new_value;
+  {
+    SmallStringMap::AddResult add_result =
+        small_string_map_.insert(key, ShapeCacheEntry());
+    is_new_entry = add_result.is_new_entry;
+    new_value = &add_result.stored_value->value;
+  }
+
+  if (is_new_entry && small_string_map_.size() > kMaxSize) {
+    // Adding this new entry made the table exceed the maximum size so rebuild
+    // the cache, respecting the kMaxSizeAfterCleanup constraint.
+    if (kMaxSizeAfterCleanup > 0) {
+      DCHECK_LE(kMaxSizeAfterCleanup, kMaxSize);
+      // First add a slot for the ShapeCacheEntry that is about to be used.
+      SmallStringMap preserved_map;
+      preserved_map.insert(key, ShapeCacheEntry());
+      if (kMaxSizeAfterCleanup > 1) {
+        // Next, keep other entries that are still referenced from outside that
+        // hash table, with the assumption that such entries are likely to be
+        // used again.
+        auto end = small_string_map_.end();
+        for (auto it = small_string_map_.begin(); it != end; ++it) {
+          if (!it->key.IsHashTableDeletedValue() &&
+              !it->key.IsHashTableEmptyValue() && it->value) {
+            DCHECK(it->value->HasAtLeastOneRef());
+            if (!it->value->HasOneRef()) {
+              preserved_map.insert(it->key, it->value);
+              if (preserved_map.size() == kMaxSizeAfterCleanup) {
+                break;
+              }
+            }
+          }
+        }
+      }
+      small_string_map_.swap(preserved_map);
+
+      // Now calculate the pointer to the added value again.
+      {
+        SmallStringMap::AddResult add_result =
+            small_string_map_.insert(key, ShapeCacheEntry());
+        DCHECK(!add_result.is_new_entry);
+        new_value = &add_result.stored_value->value;
+      }
+    } else {
+      // No need to be fancy: we're just trying to avoid pathological growth.
+      small_string_map_.clear();
+      return nullptr;
+    }
+  }
+
+  return new_value;
+}
+
+}  // namespace blink
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache.h
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2012 Apple Inc. All rights reserved.
+ * Copyright (C) 2015 Google Inc. All rights reserved.
+ * Copyright (C) 2023 Igalia S.L. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_NG_SHAPE_CACHE_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_NG_SHAPE_CACHE_H_
+
+#include "base/containers/span.h"
+#include "base/hash/hash.h"
+#include "base/memory/weak_ptr.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/blink/renderer/platform/text/text_direction.h"
+#include "third_party/blink/renderer/platform/wtf/forward.h"
+#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
+#include "third_party/blink/renderer/platform/wtf/hash_table_deleted_value_type.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+
+namespace blink {
+
+using ShapeCacheEntry = scoped_refptr<const ShapeResult>;
+
+class NGShapeCache {
+  USING_FAST_MALLOC(NGShapeCache);
+  // Used to represent hash table keys as "small string with direction".
+  class SmallStringKey {
+    DISALLOW_NEW();
+
+   public:
+    static unsigned Capacity() { return kCapacity; }
+
+    SmallStringKey()
+        : text_(g_empty_string),
+          direction_(static_cast<unsigned>(TextDirection::kLtr)) {}
+
+    explicit SmallStringKey(WTF::HashTableDeletedValueType)
+        : direction_(static_cast<unsigned>(TextDirection::kLtr)) {}
+
+    SmallStringKey(const String& text, TextDirection direction)
+        : text_(text), direction_(static_cast<unsigned>(direction)) {
+      DCHECK(text_.length() <= kCapacity);
+      // In order to get the most optimal algorithm, use base::FastHash instead
+      // of the one provided by StringHasher. See http://crbug.com/735674.
+      // TODO(crbug.com/1408058, crbug.com/902789): Investigate hash performance
+      // improvement for NGShapeCache:
+      // - Should we rely on HashTraits<String>::GetHash(text_) and avoid
+      //   storing the hash_ on the class? That would still rely on the slower
+      //   StringHasher but would avoid that calculation when the hash result is
+      //   already stored on the String object.
+      // - Should we use base::HashInts to take direction_ into account in the
+      //   hash value to avoid some colisions?
+      hash_ = static_cast<unsigned>(
+          base::FastHash(text_.Is8Bit() ? base::as_bytes(text_.Span8())
+                                        : base::as_bytes(text_.Span16())));
+    }
+
+    const String& Text() const { return text_; }
+    TextDirection Direction() const {
+      return static_cast<TextDirection>(direction_);
+    }
+    unsigned GetHash() const { return hash_; }
+
+    bool IsHashTableDeletedValue() const { return text_.IsNull(); }
+    bool IsHashTableEmptyValue() const { return text_.empty(); }
+
+   private:
+    static constexpr unsigned kCapacity = 15;
+
+    unsigned hash_;
+    String text_;
+    unsigned direction_ : 1;
+  };
+
+ public:
+  static unsigned MaxTextLengthOfEntries() {
+    return SmallStringKey::Capacity();
+  }
+
+  NGShapeCache() {
+    DCHECK(RuntimeEnabledFeatures::LayoutNGShapeCacheEnabled());
+  }
+  NGShapeCache(const NGShapeCache&) = delete;
+  NGShapeCache& operator=(const NGShapeCache&) = delete;
+
+  ShapeCacheEntry* Add(const String& text, TextDirection direction) {
+    if (text.length() > SmallStringKey::Capacity()) {
+      return nullptr;
+    }
+    return AddSlowCase(text, direction);
+  }
+
+  void ClearIfVersionChanged(unsigned version) {
+    if (version != version_) {
+      small_string_map_.clear();
+      version_ = version;
+    }
+  }
+
+  size_t ByteSize() const {
+    size_t self_byte_size = 0;
+    for (auto cache_entry : small_string_map_) {
+      self_byte_size += cache_entry.value->ByteSize();
+    }
+    return self_byte_size;
+  }
+
+  base::WeakPtr<NGShapeCache> GetWeakPtr() {
+    return weak_factory_.GetWeakPtr();
+  }
+
+ private:
+  PLATFORM_EXPORT ShapeCacheEntry* AddSlowCase(const String& text,
+                                               TextDirection direction);
+  struct SmallStringKeyHashTraits : WTF::SimpleClassHashTraits<SmallStringKey> {
+    STATIC_ONLY(SmallStringKeyHashTraits);
+    static unsigned GetHash(const SmallStringKey& key) { return key.GetHash(); }
+    static const bool kEmptyValueIsZero = false;
+    static bool IsEmptyValue(const SmallStringKey& key) {
+      return key.IsHashTableEmptyValue();
+    }
+    static const unsigned kMinimumTableSize = 16;
+  };
+
+  friend bool operator==(const SmallStringKey&, const SmallStringKey&);
+
+  typedef HashMap<SmallStringKey, ShapeCacheEntry, SmallStringKeyHashTraits>
+      SmallStringMap;
+
+  SmallStringMap small_string_map_;
+  unsigned version_ = 0;
+  base::WeakPtrFactory<NGShapeCache> weak_factory_{this};
+};
+
+inline bool operator==(const NGShapeCache::SmallStringKey& a,
+                       const NGShapeCache::SmallStringKey& b) {
+  return a.Direction() == b.Direction() && a.Text() == b.Text();
+}
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_NG_SHAPE_CACHE_H_
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache_test.cc
@@ -0,0 +1,46 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/ng_shape_cache.h"
+
+#include "base/test/task_environment.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/testing/font_test_base.h"
+#include "third_party/blink/renderer/platform/text/text_direction.h"
+
+namespace blink {
+
+class NGShapeCacheTest : public FontTestBase {
+ protected:
+  void SetUp() override { cache = std::make_unique<NGShapeCache>(); }
+  std::unique_ptr<NGShapeCache> cache;
+};
+
+TEST_F(NGShapeCacheTest, AddEntriesAndCacheHits) {
+  // Adding an entry is successful.
+  ShapeCacheEntry* entry_A_LTR = cache->Add("A", TextDirection::kLtr);
+  ASSERT_TRUE(entry_A_LTR);
+
+  // Adding the same entry again hits cache.
+  EXPECT_EQ(cache->Add("A", TextDirection::kLtr), entry_A_LTR);
+
+  // Adding the an entry with different text does not hit cache.
+  ShapeCacheEntry* entry_B_LTR = cache->Add("B", TextDirection::kLtr);
+  ASSERT_TRUE(entry_B_LTR);
+  EXPECT_NE(entry_B_LTR, entry_A_LTR);
+
+  // Adding the same entry again hits cache.
+  EXPECT_EQ(cache->Add("B", TextDirection::kLtr), entry_B_LTR);
+
+  // Adding the an entry with different direction does not hit cache.
+  ShapeCacheEntry* entry_A_RTL = cache->Add("A", TextDirection::kRtl);
+  ASSERT_TRUE(entry_A_RTL);
+  EXPECT_NE(entry_A_RTL, entry_A_LTR);
+  EXPECT_NE(entry_A_RTL, entry_B_LTR);
+
+  // Adding the same entry again hits cache.
+  EXPECT_EQ(cache->Add("A", TextDirection::kRtl), entry_A_RTL);
+}
+
+}  // namespace blink
--- a/third_party/blink/renderer/platform/runtime_enabled_features.json5
+++ b/third_party/blink/renderer/platform/runtime_enabled_features.json5
@@ -2201,6 +2201,11 @@
       base_feature: "none",
     },
     {
+      name: "LayoutNGShapeCache",
+      status: "test",
+      base_feature: "LayoutNGShapeCache",
+    },
+    {
       name: "NotificationTriggers",
       origin_trial_feature_name: "NotificationTriggers",
       status: "experimental",
