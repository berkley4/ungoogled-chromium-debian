From 19af54eea9d7a6bf0c01f82c2cfd98f320f8d917 Mon Sep 17 00:00:00 2001
From: Nathan Memmott <memmott@chromium.org>
Date: Thu, 22 Aug 2024 22:28:07 +0000
Subject: [PATCH] Change Observer: Fix Get*PermissionGrant crash

Now that FileSystemAccessObserverObservation observes permission status
changes, there is the potential to destroy itself on the status change
in the Get*PermissionGrant functions which would cause the grant to be
destroyed before a new scoped_refptr to it can be returned.

This fixes it by holding a scoped_refptr to it before calling SetStatus
so there is no potential for it to be destroyed.

Bug: 360401213
Change-Id: Ibf2c6534fe13f3d9912450969f8cc0ac27b7c340
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5794141
Commit-Queue: Nathan Memmott <memmott@chromium.org>
Reviewed-by: Daseul Lee <dslee@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1345697}
---

--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
@@ -1169,7 +1169,7 @@
   // but that is exactly what we want.
   auto& origin_state = active_permissions_map_[origin];
   auto*& existing_grant = origin_state.read_grants[path];
-  scoped_refptr<PermissionGrantImpl> new_grant;
+  scoped_refptr<PermissionGrantImpl> grant;
 
   if (existing_grant && existing_grant->handle_type() != handle_type) {
     // |path| changed from being a directory to being a file or vice versa,
@@ -1181,27 +1181,30 @@
     existing_grant = nullptr;
   }
 
-  if (!existing_grant) {
-    new_grant = base::MakeRefCounted<PermissionGrantImpl>(
+  bool creating_new_grant = !existing_grant;
+  if (creating_new_grant) {
+    grant = base::MakeRefCounted<PermissionGrantImpl>(
         weak_factory_.GetWeakPtr(), origin, path, handle_type, GrantType::kRead,
         user_action);
-    existing_grant = new_grant.get();
+    existing_grant = grant.get();
+  } else {
+    grant = existing_grant;
   }
 
   const ContentSetting content_setting = GetReadGuardContentSetting(origin);
   switch (content_setting) {
     case CONTENT_SETTING_ALLOW:
       // Don't persist permissions when the origin is allowlisted.
-      existing_grant->SetStatus(
+      grant->SetStatus(
           PermissionStatus::GRANTED,
           PersistedPermissionOptions::kDoNotUpdatePersistedPermission);
       break;
     case CONTENT_SETTING_ASK:
       // If a parent directory is already readable this new grant should also be
       // readable.
-      if (new_grant &&
+      if (creating_new_grant &&
           AncestorHasActivePermission(origin, path, GrantType::kRead)) {
-        existing_grant->SetStatus(
+        grant->SetStatus(
             PermissionStatus::GRANTED,
             PersistedPermissionOptions::kUpdatePersistedPermission);
         break;
@@ -1216,7 +1219,7 @@
           [[fallthrough]];
         case UserAction::kDragAndDrop:
           // Drag&drop grants read access for all handles.
-          existing_grant->SetStatus(
+          grant->SetStatus(
               PermissionStatus::GRANTED,
               PersistedPermissionOptions::kUpdatePersistedPermission);
           break;
@@ -1229,8 +1232,8 @@
       // Don't bother revoking persisted permissions. If the permissions have
       // not yet expired when the ContentSettingValue is changed, they will
       // effectively be reinstated.
-      if (new_grant) {
-        existing_grant->SetStatus(
+      if (creating_new_grant) {
+        grant->SetStatus(
             PermissionStatus::DENIED,
             PersistedPermissionOptions::kDoNotUpdatePersistedPermission);
       } else {
@@ -1242,11 +1245,11 @@
       break;
   }
 
-  if (HasGrantedActivePermissionStatus(existing_grant)) {
+  if (HasGrantedActivePermissionStatus(grant.get())) {
     ScheduleUsageIconUpdate();
   }
 
-  return existing_grant;
+  return grant;
 }
 
 scoped_refptr<content::FileSystemAccessPermissionGrant>
@@ -1260,7 +1263,7 @@
   // but that is exactly what we want.
   auto& origin_state = active_permissions_map_[origin];
   auto*& existing_grant = origin_state.write_grants[path];
-  scoped_refptr<PermissionGrantImpl> new_grant;
+  scoped_refptr<PermissionGrantImpl> grant;
 
   if (existing_grant && existing_grant->handle_type() != handle_type) {
     // |path| changed from being a directory to being a file or vice versa,
@@ -1272,27 +1275,30 @@
     existing_grant = nullptr;
   }
 
-  if (!existing_grant) {
-    new_grant = base::MakeRefCounted<PermissionGrantImpl>(
+  bool creating_new_grant = !existing_grant;
+  if (creating_new_grant) {
+    grant = base::MakeRefCounted<PermissionGrantImpl>(
         weak_factory_.GetWeakPtr(), origin, path, handle_type,
         GrantType::kWrite, user_action);
-    existing_grant = new_grant.get();
+    existing_grant = grant.get();
+  } else {
+    grant = existing_grant;
   }
 
   const ContentSetting content_setting = GetWriteGuardContentSetting(origin);
   switch (content_setting) {
     case CONTENT_SETTING_ALLOW:
       // Don't persist permissions when the origin is allowlisted.
-      existing_grant->SetStatus(
+      grant->SetStatus(
           PermissionStatus::GRANTED,
           PersistedPermissionOptions::kDoNotUpdatePersistedPermission);
       break;
     case CONTENT_SETTING_ASK:
       // If a parent directory is already writable this new grant should also be
       // writable.
-      if (new_grant &&
+      if (creating_new_grant &&
           AncestorHasActivePermission(origin, path, GrantType::kWrite)) {
-        existing_grant->SetStatus(
+        grant->SetStatus(
             PermissionStatus::GRANTED,
             PersistedPermissionOptions::kUpdatePersistedPermission);
         break;
@@ -1300,7 +1306,7 @@
       switch (user_action) {
         case UserAction::kSave:
           // Only automatically grant write access for save dialogs.
-          existing_grant->SetStatus(
+          grant->SetStatus(
               PermissionStatus::GRANTED,
               PersistedPermissionOptions::kUpdatePersistedPermission);
           break;
@@ -1315,8 +1321,8 @@
       // Don't bother revoking persisted permissions. If the permissions have
       // not yet expired when the ContentSettingValue is changed, they will
       // effectively be reinstated.
-      if (new_grant) {
-        existing_grant->SetStatus(
+      if (creating_new_grant) {
+        grant->SetStatus(
             PermissionStatus::DENIED,
             PersistedPermissionOptions::kDoNotUpdatePersistedPermission);
       } else {
@@ -1328,11 +1334,11 @@
       break;
   }
 
-  if (HasGrantedActivePermissionStatus(existing_grant)) {
+  if (HasGrantedActivePermissionStatus(grant.get())) {
     ScheduleUsageIconUpdate();
   }
 
-  return existing_grant;
+  return grant;
 }
 
 // Return extended permission grants for an origin.
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context_unittest.cc
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context_unittest.cc
@@ -2915,9 +2915,9 @@
   auto observer =
       SelfDestructingPermissionGrantObserver::Create(std::move(grant));
 
-  // `observer` destroys itself when the permission gets revoked. `observer` is
-  // the only holder of `grant`, so `grant` is destroyed as well. This should
-  // work without crashing.
+  // `observer` destroys itself when the permission status is changed.
+  // `observer` is the only holder of `grant`, so `grant` is destroyed as well.
+  // This should work without crashing.
   permission_context()->RevokeActiveGrantsForTesting(kTestOrigin, kTestPath);
   EXPECT_FALSE(observer);
 }
@@ -2931,9 +2931,9 @@
   auto observer =
       SelfDestructingPermissionGrantObserver::Create(std::move(grant));
 
-  // `observer` destroys itself when the permission gets revoked. `observer` is
-  // the only holder of `grant`, so `grant` is destroyed as well. This should
-  // work without crashing.
+  // `observer` destroys itself when the permission status is changed.
+  // `observer` is the only holder of `grant`, so `grant` is destroyed as well.
+  // This should work without crashing.
   permission_context()->RevokeActiveGrantsForTesting(kTestOrigin, kTestPath);
   EXPECT_FALSE(observer);
 }
@@ -2947,9 +2947,9 @@
   auto observer =
       SelfDestructingPermissionGrantObserver::Create(std::move(grant));
 
-  // `observer` destroys itself when the permission gets revoked. `observer` is
-  // the only holder of `grant`, so `grant` is destroyed as well. This should
-  // work without crashing.
+  // `observer` destroys itself when the permission status is changed.
+  // `observer` is the only holder of `grant`, so `grant` is destroyed as well.
+  // This should work without crashing.
   permission_context()->RevokeAllActiveGrants();
   EXPECT_FALSE(observer);
 }
@@ -2963,9 +2963,9 @@
   auto observer =
       SelfDestructingPermissionGrantObserver::Create(std::move(grant));
 
-  // `observer` destroys itself when the permission gets revoked. `observer` is
-  // the only holder of `grant`, so `grant` is destroyed as well. This should
-  // work without crashing.
+  // `observer` destroys itself when the permission status is changed.
+  // `observer` is the only holder of `grant`, so `grant` is destroyed as well.
+  // This should work without crashing.
   permission_context()->RevokeAllActiveGrants();
   EXPECT_FALSE(observer);
 }
@@ -2982,9 +2982,9 @@
   auto observer =
       SelfDestructingPermissionGrantObserver::Create(std::move(grant));
 
-  // `observer` destroys itself when the permission gets revoked. `observer` is
-  // the only holder of `grant`, so `grant` is destroyed as well. This should
-  // work without crashing.
+  // `observer` destroys itself when the permission status is changed.
+  // `observer` is the only holder of `grant`, so `grant` is destroyed as well.
+  // This should work without crashing.
   base::test::TestFuture<PermissionRequestOutcome> future;
   observer->grant()->RequestPermission(
       frame_id(), UserActivationState::kNotRequired, future.GetCallback());
@@ -2992,6 +2992,44 @@
   EXPECT_FALSE(observer);
 }
 
+TEST_F(ChromeFileSystemAccessPermissionContextTest,
+       WriteGrantDestroyedOnGrantingSecondWriteGrant) {
+  auto grant1 = permission_context()->GetWritePermissionGrant(
+      kTestOrigin, kTestPath, HandleType::kFile, UserAction::kNone);
+  EXPECT_EQ(grant1->GetStatus(), PermissionStatus::ASK);
+
+  auto observer =
+      SelfDestructingPermissionGrantObserver::Create(std::move(grant1));
+
+  // `observer` destroys itself when the permission status is changed.
+  // `observer` is the only holder of `grant`, so `grant` is destroyed as well.
+  // This should work without crashing.
+  auto grant2 = permission_context()->GetWritePermissionGrant(
+      kTestOrigin, kTestPath, HandleType::kFile, UserAction::kSave);
+  EXPECT_EQ(grant2->GetStatus(), PermissionStatus::GRANTED);
+
+  EXPECT_FALSE(observer);
+}
+
+TEST_F(ChromeFileSystemAccessPermissionContextTest,
+       ReadGrantDestroyedOnGrantingSecondReadGrant) {
+  auto grant1 = permission_context()->GetReadPermissionGrant(
+      kTestOrigin, kTestPath, HandleType::kFile, UserAction::kNone);
+  EXPECT_EQ(grant1->GetStatus(), PermissionStatus::ASK);
+
+  auto observer =
+      SelfDestructingPermissionGrantObserver::Create(std::move(grant1));
+
+  // `observer` destroys itself when the permission status is changed.
+  // `observer` is the only holder of `grant`, so `grant` is destroyed as well.
+  // This should work without crashing.
+  auto grant2 = permission_context()->GetReadPermissionGrant(
+      kTestOrigin, kTestPath, HandleType::kFile, UserAction::kSave);
+  EXPECT_EQ(grant2->GetStatus(), PermissionStatus::GRANTED);
+
+  EXPECT_FALSE(observer);
+}
+
 #if BUILDFLAG(ENTERPRISE_CLOUD_CONTENT_ANALYSIS)
 
 TEST_F(ChromeFileSystemAccessPermissionContextTest,
