From b68b42dd6831889a799903bef83655e393e76f1c Mon Sep 17 00:00:00 2001
From: W. James MacLean <wjmaclean@chromium.org>
Date: Wed, 05 Jun 2024 20:35:43 +0000
Subject: [PATCH] [RELAND] Propagate initiator origin for about:blank in ShouldSwapBrowsingInstancesForNavigation

Currently, when ShouldSwapBrowsingInstancesForNavigation creates a
UrlInfo in order to create a SiteInfo, it fails to propagate the
origin in the case where the url is about:blank. Further, when
SiteInfo::CreateInternal subsequently checks the origin isolation
status via a call to DetermineOriginAgentClusterIsolation, it fails
to use the origin, instead passing an opaque origin.

The net effect of this is that, when OriginKeyedProcessesByDefault is
enabled, an isolated frame that performs a renderer-initiated navigation
to about:blank will crash on a ProcessLock mismatch (via a CHECK when
GetOriginForURLLoaderFactoryAfterResponseWithDebugInfo calls
CanAccessDataForOrigin to see if it can commit).

This CL fixes it so the origin is propagated in both places, and it
adds a test.

This is a reland of
https://chromium-review.googlesource.com/c/chromium/src/+/5570508 which
fails on
https://ci.chromium.org/ui/p/chromium/builders/ci/linux-bfcache-rel/60356/overview
since bfcache is forced-off on that bot.

Bug: 40259221
Change-Id: Ia51c5155a9eb104212ea910df655647de65dce91
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5597439
Reviewed-by: Alex Moshchuk <alexmos@chromium.org>
Reviewed-by: Charlie Reis <creis@chromium.org>
Commit-Queue: James Maclean <wjmaclean@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1310858}
---

--- a/content/browser/isolated_origin_browsertest.cc
+++ b/content/browser/isolated_origin_browsertest.cc
@@ -880,6 +880,90 @@
       site_instance->GetSiteInfo().requires_origin_keyed_process_by_default());
 }
 
+// A test to make sure that a renderer-initiated navigation from a default-
+// isolated frame to about:blank doesn't crash on a ProcessLock mismatch.
+IN_PROC_BROWSER_TEST_F(OriginKeyedProcessByDefaultTest,
+                       RendererInitiatedNavigationToAboutBlankSucceeds) {
+  GURL test_url(https_server()->GetURL("foo.com", "/title1.html"));
+  EXPECT_TRUE(NavigateToURL(shell(), test_url));
+
+  // Verify the main frame got an origin-keyed process by default.
+  FrameTreeNode* root = web_contents()->GetPrimaryFrameTree().root();
+  scoped_refptr<SiteInstanceImpl> site_instance =
+      root->current_frame_host()->GetSiteInstance();
+  EXPECT_TRUE(site_instance->GetSiteInfo().requires_origin_keyed_process());
+  EXPECT_TRUE(
+      site_instance->GetSiteInfo().requires_origin_keyed_process_by_default());
+
+  // Record the origin of the isolated frame.
+  std::string initial_origin = EvalJs(shell(), "origin").ExtractString();
+  EXPECT_EQ(url::Origin::Create(test_url).GetURL(), GURL(initial_origin));
+
+  // Renderer-initiated navigation to about:blank.
+  TestNavigationObserver navigation_observer(shell()->web_contents(), 1);
+  EXPECT_TRUE(ExecJs(shell(), "location.href = 'about:blank';"));
+  navigation_observer.Wait();
+
+  // Expect that the about:blank frame inherits the origin of the initiator.
+  // Also, this gives us additional verification that the navigation succeeded
+  // without hitting the ProcessLock check.
+  EXPECT_EQ(initial_origin, EvalJs(shell(), "origin").ExtractString());
+  scoped_refptr<SiteInstanceImpl> new_site_instance =
+      root->current_frame_host()->GetSiteInstance();
+  // Note: the site_instance has changed, due to the proactive BrowsingInstance
+  // swap done to make the previous page eligible for back-forward cache.
+  // Note: some bots may run this test with BFCache disabled, so we need to
+  // handle both cases here.
+  if (base::FeatureList::IsEnabled(features::kBackForwardCache)) {
+    EXPECT_NE(site_instance, new_site_instance);
+  } else {
+    EXPECT_EQ(site_instance, new_site_instance);
+  }
+  EXPECT_EQ(site_instance->GetSiteInfo(), site_instance->GetSiteInfo());
+  EXPECT_TRUE(new_site_instance->GetSiteInfo().requires_origin_keyed_process());
+}
+
+// A test to make sure that a renderer-initiated navigation from a default-
+// isolated frame to about:blank doesn't crash on a ProcessLock mismatch.
+// This test is similar to RendererInitiatedNavigationToAboutBlankSucceeds
+// but with BFCache disabled.
+IN_PROC_BROWSER_TEST_F(
+    OriginKeyedProcessByDefaultTest,
+    RendererInitiatedNavigationToAboutBlankSucceeds_BFCacheDisabled) {
+  DisableBackForwardCacheForTesting(
+      web_contents(), BackForwardCacheImpl::TEST_REQUIRES_NO_CACHING);
+  GURL test_url(https_server()->GetURL("foo.com", "/title1.html"));
+  EXPECT_TRUE(NavigateToURL(shell(), test_url));
+
+  // Verify the main frame got an origin-keyed process by default.
+  FrameTreeNode* root = web_contents()->GetPrimaryFrameTree().root();
+  scoped_refptr<SiteInstanceImpl> site_instance =
+      root->current_frame_host()->GetSiteInstance();
+  EXPECT_TRUE(site_instance->GetSiteInfo().requires_origin_keyed_process());
+  EXPECT_TRUE(
+      site_instance->GetSiteInfo().requires_origin_keyed_process_by_default());
+
+  // Record the origin of the isolated frame.
+  std::string initial_origin = EvalJs(shell(), "origin").ExtractString();
+  EXPECT_EQ(url::Origin::Create(test_url).GetURL(), GURL(initial_origin));
+
+  // Renderer-initiated navigation to about:blank.
+  TestNavigationObserver navigation_observer(shell()->web_contents(), 1);
+  EXPECT_TRUE(ExecJs(shell(), "location.href = 'about:blank';"));
+  navigation_observer.Wait();
+
+  // Expect that the about:blank frame inherits the origin of the initiator.
+  // Also, this gives us additional verification that the navigation succeeded
+  // without hitting the ProcessLock check.
+  EXPECT_EQ(initial_origin, EvalJs(shell(), "origin").ExtractString());
+  scoped_refptr<SiteInstanceImpl> new_site_instance =
+      root->current_frame_host()->GetSiteInstance();
+  // Note: with BFCache disabled, the site_instance does not change.
+  EXPECT_EQ(site_instance, new_site_instance);
+  EXPECT_EQ(site_instance->GetSiteInfo(), site_instance->GetSiteInfo());
+  EXPECT_TRUE(new_site_instance->GetSiteInfo().requires_origin_keyed_process());
+}
+
 // The same as for DefaultOptInIsIsolated, but testing on a subframe.
 IN_PROC_BROWSER_TEST_F(OriginKeyedProcessByDefaultTest,
                        SubframeDefaultIsOriginKeyedProcess) {
--- a/content/browser/renderer_host/render_frame_host_manager.cc
+++ b/content/browser/renderer_host/render_frame_host_manager.cc
@@ -2446,15 +2446,10 @@
   // isolation, ensuring that the next navigation (e.g., a form submission
   // after user has typed in a password) can utilize a dedicated process when
   // possible (e.g., when there are no existing script references).
-  if (ShouldSwapBrowsingInstancesForDynamicIsolation(
-          render_frame_host_.get(),
-          UrlInfo(UrlInfoInit(destination_effective_url)
-                      .WithOriginIsolationRequest(
-                          destination_url_info.origin_isolation_request)
-                      .WithCOOPSiteIsolation(
-                          destination_url_info.requests_coop_isolation())
-                      .WithWebExposedIsolationInfo(
-                          destination_url_info.web_exposed_isolation_info)))) {
+  UrlInfo url_info_to_test = destination_url_info;
+  url_info_to_test.url = destination_effective_url;
+  if (ShouldSwapBrowsingInstancesForDynamicIsolation(render_frame_host_.get(),
+                                                     url_info_to_test)) {
     return BrowsingContextGroupSwap::CreateSecuritySwap();
   }
 
--- a/content/browser/site_info.cc
+++ b/content/browser/site_info.cc
@@ -282,11 +282,12 @@
   bool requires_origin_keyed_process = false;
   if (SiteIsolationPolicy::IsProcessIsolationForOriginAgentClusterEnabled()) {
     auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
+    url::Origin origin =
+        GetPossiblyOverriddenOriginFromUrl(url_info.url, url_info.origin);
     requires_origin_keyed_process =
         policy
-            ->DetermineOriginAgentClusterIsolation(
-                isolation_context, url::Origin::Create(url_info.url),
-                requested_isolation_state)
+            ->DetermineOriginAgentClusterIsolation(isolation_context, origin,
+                                                   requested_isolation_state)
             .requires_origin_keyed_process();
   }
   // If after the call to `DetermineOriginAgentClusterIsolation` the returned
