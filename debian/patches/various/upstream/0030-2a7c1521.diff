From 2a7c1521b992af17412b17782aec0e2c6dafa1b9 Mon Sep 17 00:00:00 2001
From: Gastón Rodríguez <gastonr@microsoft.com>
Date: Tue, 06 Aug 2024 17:26:22 +0000
Subject: [PATCH] Fix CHECK in DelegatedInkPointRendererGpu::StoreDelegatedInkPoint

The mentioned check was commented out because it was being hit and a
root cause had to be found.

When the pointer leaves the viewport a kMouseExited event is created.
The first pointer move event right after that exit event sometimes has
more than one calculated target down the pipeline in
EventProcessor::OnEventFromSource. From here, this event makes it down
to RenderWidgetHostImpl::ForwardDelegatedInkPoint, where we receive
two duplicate points. These points are forwarded to the GPU DelInk
renderer, and the second one causes a crash by hitting the CHECK
because the second point's timestamp is equal to the existing point,
instead of being larger.

This CL avoids hitting the CHECK and the unnecessary IPC call by
caching the last point sent and not making the call if the new point
is equal to the previous one.

Bug: 40784171
Change-Id: I214a7f831b2c0207a7f7d93642ba548b339b78bf
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5742013
Reviewed-by: Ken Buchanan <kenrb@chromium.org>
Reviewed-by: Sahir Vellani <sahir.vellani@microsoft.com>
Reviewed-by: Nico Weber <thakis@chromium.org>
Commit-Queue: Gaston Rodriguez <gastonr@microsoft.com>
Cr-Commit-Position: refs/heads/main@{#1337963}
---

--- a/content/browser/renderer_host/render_widget_host_impl.cc
+++ b/content/browser/renderer_host/render_widget_host_impl.cc
@@ -2513,6 +2513,13 @@
     return;
   }
 
+  // If being given the same point twice, return early and avoid an unnecessary
+  // call to the GPU process.
+  if (last_delegated_ink_point_sent_ == delegated_ink_point) {
+    return;
+  }
+  last_delegated_ink_point_sent_ = delegated_ink_point;
+
   auto* delegated_ink_point_renderer =
       delegate_->GetDelegatedInkRenderer(view_->GetCompositor());
   if (!delegated_ink_point_renderer) {
--- a/content/browser/renderer_host/render_widget_host_impl.h
+++ b/content/browser/renderer_host/render_widget_host_impl.h
@@ -1503,6 +1503,10 @@
 
   const viz::FrameSinkId frame_sink_id_;
 
+  // Used to avoid unnecessary IPC calls when ForwardDelegatedInkPoint receives
+  // the same point twice.
+  std::optional<gfx::DelegatedInkPoint> last_delegated_ink_point_sent_;
+
   bool sent_autoscroll_scroll_begin_ = false;
   gfx::PointF autoscroll_start_position_;
 
--- a/ui/gfx/delegated_ink_point.h
+++ b/ui/gfx/delegated_ink_point.h
@@ -33,6 +33,7 @@
 class GFX_EXPORT DelegatedInkPoint {
  public:
   DelegatedInkPoint() = default;
+  bool operator==(const DelegatedInkPoint& o) const = default;
   DelegatedInkPoint(const PointF& pt,
                     base::TimeTicks timestamp,
                     int32_t pointer_id = std::numeric_limits<int32_t>::min())
--- a/ui/gl/delegated_ink_point_renderer_gpu.cc
+++ b/ui/gl/delegated_ink_point_renderer_gpu.cc
@@ -207,14 +207,10 @@
 
   const int32_t pointer_id = point.pointer_id();
 
-  // TODO(crbug.com/40784171): Understand why we are being sent points from
-  // browser process that break this assertion so frequently and prevent it from
-  // happening.
-  // DCHECK(delegated_ink_points_.find(pointer_id) ==
-  //            delegated_ink_points_.end() ||
-  //        point.timestamp() >
-  //            delegated_ink_points_[pointer_id].rbegin()->
-  //                first.timestamp());
+  DCHECK(delegated_ink_points_.find(pointer_id) ==
+             delegated_ink_points_.end() ||
+         point.timestamp() >
+             delegated_ink_points_[pointer_id].rbegin()->first.timestamp());
 
   if (metadata_ && point.timestamp() < metadata_->timestamp()) {
     return;
