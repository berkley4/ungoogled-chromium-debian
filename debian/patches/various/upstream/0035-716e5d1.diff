From 716e5d1c26b459d2a4166c498668f50c38292609 Mon Sep 17 00:00:00 2001
From: Mason Freed <masonf@chromium.org>
Date: Fri, 09 Aug 2024 22:58:50 +0000
Subject: [PATCH] Allow anchor attribute to be used on Element, not just HTMLElement

When [1] landed, most of the anchor attribute handling was
moved from HTMLElement to Element. However, the code to watch
anchor references (in AnchorElementObserver) was not similarly
updated. That led to crashes.

This moves the rest of the anchor element stuff to Element,
and adds a test.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/5229437

Fixed: 353865123
Bug: 342579983
Change-Id: I1151c82dfcb39e7ca2db85e7374903e07b113a9f
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5777660
Reviewed-by: Joey Arhar <jarhar@chromium.org>
Commit-Queue: Mason Freed <masonf@chromium.org>
Auto-Submit: Mason Freed <masonf@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1339932}
---

--- a/third_party/blink/renderer/core/dom/element.cc
+++ b/third_party/blink/renderer/core/dom/element.cc
@@ -1254,10 +1254,9 @@
 
 void Element::setAnchorElement(Element* new_element) {
   CHECK(RuntimeEnabledFeatures::HTMLAnchorAttributeEnabled());
+  CHECK(RuntimeEnabledFeatures::CSSAnchorPositioningEnabled());
   SetElementAttribute(html_names::kAnchorAttr, new_element);
-  if (RuntimeEnabledFeatures::CSSAnchorPositioningEnabled()) {
-    EnsureAnchorElementObserver().Notify();
-  }
+  EnsureAnchorElementObserver().Notify();
 }
 
 inline void Element::SynchronizeAttribute(const QualifiedName& name) const {
@@ -2757,8 +2756,7 @@
       }
     }
   } else if (params.name == html_names::kAnchorAttr) {
-    if (IsA<HTMLElement>(this) &&
-        RuntimeEnabledFeatures::CSSAnchorPositioningEnabled()) {
+    if (RuntimeEnabledFeatures::HTMLAnchorAttributeEnabled()) {
       EnsureAnchorElementObserver().Notify();
       return;
     }
@@ -10145,21 +10143,19 @@
 }
 
 AnchorElementObserver& Element::EnsureAnchorElementObserver() {
-  DCHECK(IsHTMLElement());
-  DCHECK(RuntimeEnabledFeatures::CSSAnchorPositioningEnabled());
-  return EnsureElementRareData().EnsureAnchorElementObserver(
-      To<HTMLElement>(this));
+  DCHECK(RuntimeEnabledFeatures::HTMLAnchorAttributeEnabled());
+  return EnsureElementRareData().EnsureAnchorElementObserver(this);
 }
 
 Element* Element::ImplicitAnchorElement() const {
   if (!RuntimeEnabledFeatures::CSSAnchorPositioningEnabled()) {
     return nullptr;
   }
+  if (Element* anchor = anchorElement()) {
+    DCHECK(RuntimeEnabledFeatures::HTMLAnchorAttributeEnabled());
+    return anchor;
+  }
   if (const HTMLElement* html_element = DynamicTo<HTMLElement>(this)) {
-    if (Element* anchor = html_element->anchorElement()) {
-      DCHECK(RuntimeEnabledFeatures::HTMLAnchorAttributeEnabled());
-      return anchor;
-    }
     if (Element* select_list = html_element->popoverOwnerSelectListElement()) {
       return select_list;
     }
@@ -10169,8 +10165,8 @@
         return select;
       }
     }
-  } else if (const PseudoElement* pseudo_element =
-                 DynamicTo<PseudoElement>(this)) {
+  }
+  if (const PseudoElement* pseudo_element = DynamicTo<PseudoElement>(this)) {
     switch (pseudo_element->GetPseudoId()) {
       case kPseudoIdBefore:
       case kPseudoIdAfter:
--- a/third_party/blink/renderer/core/dom/element_rare_data_vector.cc
+++ b/third_party/blink/renderer/core/dom/element_rare_data_vector.cc
@@ -419,11 +419,13 @@
 }
 
 AnchorElementObserver& ElementRareDataVector::EnsureAnchorElementObserver(
-    HTMLElement* element) {
+    Element* new_source_element) {
   DCHECK(!GetAnchorElementObserver() ||
-         GetAnchorElementObserver()->GetElement() == element);
+         GetAnchorElementObserver()->GetSourceElement() == new_source_element);
+  CHECK(RuntimeEnabledFeatures::HTMLAnchorAttributeEnabled());
+  CHECK(RuntimeEnabledFeatures::CSSAnchorPositioningEnabled());
   return EnsureField<AnchorElementObserver>(FieldId::kAnchorElementObserver,
-                                            element);
+                                            new_source_element);
 }
 
 AnchorElementObserver* ElementRareDataVector::GetAnchorElementObserver() const {
--- a/third_party/blink/renderer/core/dom/element_rare_data_vector.h
+++ b/third_party/blink/renderer/core/dom/element_rare_data_vector.h
@@ -316,7 +316,7 @@
   void RemoveAnchorPositionScrollData();
   AnchorPositionScrollData& EnsureAnchorPositionScrollData(Element*);
 
-  AnchorElementObserver& EnsureAnchorElementObserver(HTMLElement*);
+  AnchorElementObserver& EnsureAnchorElementObserver(Element*);
   AnchorElementObserver* GetAnchorElementObserver() const;
 
   void IncrementImplicitlyAnchoredElementCount();
--- a/third_party/blink/renderer/core/html/anchor_element_observer.cc
+++ b/third_party/blink/renderer/core/html/anchor_element_observer.cc
@@ -16,7 +16,7 @@
  public:
   AnchorIdTargetObserver(const AtomicString& id,
                          AnchorElementObserver* anchor_element_observer)
-      : IdTargetObserver(anchor_element_observer->GetElement()
+      : IdTargetObserver(anchor_element_observer->GetSourceElement()
                              .GetTreeScope()
                              .GetIdTargetObserverRegistry(),
                          id),
@@ -35,7 +35,7 @@
   Member<AnchorElementObserver> anchor_element_observer_;
 };
 
-bool NeedsIdTargetObserver(HTMLElement& element) {
+bool NeedsIdTargetObserver(Element& element) {
   return element.IsInTreeScope() &&
          !element.HasExplicitlySetAttrAssociatedElements(
              html_names::kAnchorAttr) &&
@@ -45,32 +45,33 @@
 }  // namespace
 
 void AnchorElementObserver::Trace(Visitor* visitor) const {
-  visitor->Trace(element_);
-  visitor->Trace(anchor_);
+  visitor->Trace(source_element_);
+  visitor->Trace(current_anchor_);
   visitor->Trace(id_target_observer_);
   ElementRareDataField::Trace(visitor);
 }
 
 void AnchorElementObserver::Notify() {
-  Element* new_anchor = element_->anchorElement();
-  if (anchor_ != new_anchor) {
-    if (anchor_) {
-      anchor_->DecrementImplicitlyAnchoredElementCount();
+  Element* new_anchor = source_element_->anchorElement();
+  if (current_anchor_ != new_anchor) {
+    if (current_anchor_) {
+      current_anchor_->DecrementImplicitlyAnchoredElementCount();
     }
     if (new_anchor) {
       new_anchor->IncrementImplicitlyAnchoredElementCount();
     }
-    anchor_ = new_anchor;
-    if (element_->GetLayoutObject()) {
-      element_->GetLayoutObject()->SetNeedsLayoutAndFullPaintInvalidation(
-          layout_invalidation_reason::kAnchorPositioning);
+    current_anchor_ = new_anchor;
+    if (source_element_->GetLayoutObject()) {
+      source_element_->GetLayoutObject()
+          ->SetNeedsLayoutAndFullPaintInvalidation(
+              layout_invalidation_reason::kAnchorPositioning);
     }
   }
   ResetIdTargetObserverIfNeeded();
 }
 
 void AnchorElementObserver::ResetIdTargetObserverIfNeeded() {
-  if (!NeedsIdTargetObserver(*element_)) {
+  if (!NeedsIdTargetObserver(*source_element_)) {
     if (id_target_observer_) {
       id_target_observer_->Unregister();
       id_target_observer_ = nullptr;
@@ -78,7 +79,7 @@
     return;
   }
   const AtomicString& anchor_id =
-      element_->FastGetAttribute(html_names::kAnchorAttr);
+      source_element_->FastGetAttribute(html_names::kAnchorAttr);
   if (id_target_observer_) {
     if (static_cast<AnchorIdTargetObserver*>(id_target_observer_.Get())
             ->SameId(anchor_id)) {
--- a/third_party/blink/renderer/core/html/anchor_element_observer.h
+++ b/third_party/blink/renderer/core/html/anchor_element_observer.h
@@ -11,20 +11,23 @@
 
 namespace blink {
 
-class HTMLElement;
 class Element;
 class IdTargetObserver;
 
-// Tracks the value of HTMLElement::anchorElement() to help other elements know
+// Tracks the value of Element::anchorElement() to help other elements know
 // whether they are used as implicit anchor elements.
 // NOTE: this class is unrelated to the <a> element.
 class AnchorElementObserver : public GarbageCollected<AnchorElementObserver>,
                               public ElementRareDataField {
  public:
-  explicit AnchorElementObserver(HTMLElement* element) : element_(element) {
-    DCHECK(element_);
+  // This observer is placed on an element (the "source" element) that wears
+  // the anchor attribute. The observer maintains the
+  // "ImplicitlyAnchoredElementCount" on the target element.
+  explicit AnchorElementObserver(Element* source_element)
+      : source_element_(source_element) {
+    DCHECK(source_element_);
   }
-  const HTMLElement& GetElement() const { return *element_; }
+  const Element& GetSourceElement() const { return *source_element_; }
 
   void Notify();
 
@@ -33,8 +36,8 @@
  private:
   void ResetIdTargetObserverIfNeeded();
 
-  Member<HTMLElement> element_;
-  Member<Element> anchor_;
+  Member<Element> source_element_;
+  Member<Element> current_anchor_;
   Member<IdTargetObserver> id_target_observer_;
 };
 
--- a/third_party/blink/renderer/platform/runtime_enabled_features.json5
+++ b/third_party/blink/renderer/platform/runtime_enabled_features.json5
@@ -2032,6 +2032,7 @@
     // popover API.
     {
       name: "HTMLAnchorAttribute",
+      depends_on: ["CSSAnchorPositioning"],
       status: "experimental",
     },
     // Adds support for the experimental `interesttarget`
--- /dev/null
+++ b/third_party/blink/web_tests/external/wpt/html/dom/elements/global-attributes/the-anchor-attribute-004.tentative.html
@@ -0,0 +1,17 @@
+<!DOCTYPE html>
+<link rel=author href="mailto:masonf@chromium.org">
+<link rel="help" href="https://github.com/whatwg/html/pull/9144">
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+
+<div id=anchor1>Anchor 1</div>
+<div id=anchor2>Anchor 2</div>
+<svg id=foo anchor=anchor1></svg>
+
+<script>
+test(() => {
+  assert_equals(foo.anchorElement,anchor1,'Non-HTML elements can use the anchor attribute');
+  foo.anchorElement = anchor2;
+  assert_equals(foo.anchorElement,anchor2,'The anchorElement IDL also works for non-HTML elements');
+});
+</script>
--- a/third_party/blink/web_tests/external/wpt/html/dom/elements/global-attributes/the-anchor-attribute-xml.tentative-expected.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-This is a testharness.js-based test.
-[FAIL] the-anchor-attribute-xml
-  assert_equals: Setting the anchor attribute in XML should not set the anchorElement IDL. expected null but got Element node <div id="target">target</div>
-Harness: the test ran to completion.
-
--- a/third_party/blink/web_tests/external/wpt/html/dom/elements/global-attributes/the-anchor-attribute-xml.tentative.html
+++ b/third_party/blink/web_tests/external/wpt/html/dom/elements/global-attributes/the-anchor-attribute-xml.tentative.html
@@ -9,17 +9,16 @@
 test(() => {
   const xmlDoc = document.implementation.createDocument(null, 'root', null);
   assert_equals(xmlDoc.contentType, 'application/xml');
-  xmlDoc.documentElement.innerHTML = '<div id="target">target</div><div anchor="target">anchored</div>';
-  assert_equals(xmlDoc.documentElement.innerHTML,
-    '<div id="target">target</div><div anchor="target">anchored</div>');
-  const target = xmlDoc.documentElement.children[0];
-  const anchored = xmlDoc.documentElement.children[1];
+  const innerDoc = xmlDoc.documentElement;
+  const html = '<div id="target">target</div><div anchor="target">anchored</div>';
+  innerDoc.innerHTML = html;
+  assert_equals(innerDoc.innerHTML, html);
+  const target = innerDoc.children[0];
+  const anchored = innerDoc.children[1];
 
-  assert_equals(xmlDoc.documentElement.children[1].anchorElement, null,
-    'Setting the anchor attribute in XML should not set the anchorElement IDL.');
+  assert_equals(anchored.anchorElement, target, 'Setting the anchor attribute in XML should work.');
 
   anchored.anchorElement = target;
-  assert_equals(xmlDoc.documentElement.children[1].anchorElement, null,
-    'Setting element.anchorElement in an XML document should not set the anchorElement IDL.');
+  assert_equals(anchored.anchorElement, target, 'Setting element.anchorElement in an XML document should work.');
 });
 </script>
