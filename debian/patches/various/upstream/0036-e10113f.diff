From e10113fea5ba36d85560ea42e72bb81eee247cab Mon Sep 17 00:00:00 2001
From: Evan Stade <estade@chromium.org>
Date: Mon, 08 Jul 2024 16:49:26 +0000
Subject: [PATCH] IDB: prospective fix for crash in IndexedDBTransaction::Abort()

See bug for description. This also contains a cleanup of an unused
member var.

Bug: 350196532
Change-Id: Ie3def2c80cb8a3a8a10b0885934435e3876d075d
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5677097
Reviewed-by: Brad Triebwasser <btriebw@chromium.org>
Commit-Queue: Evan Stade <estade@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1324300}
---

--- a/components/services/storage/indexed_db/scopes/leveldb_scope.cc
+++ b/components/services/storage/indexed_db/scopes/leveldb_scope.cc
@@ -105,21 +105,18 @@
   leveldb::Status error_ = leveldb::Status::OK();
 };
 
-LevelDBScope::LevelDBScope(
-    int64_t scope_id,
-    std::vector<uint8_t> prefix,
-    size_t write_batch_size,
-    scoped_refptr<LevelDBState> level_db,
-    std::vector<PartitionedLock> locks,
-    RollbackCallback rollback_callback,
-    TearDownCallback tear_down_callback)
+LevelDBScope::LevelDBScope(int64_t scope_id,
+                           std::vector<uint8_t> prefix,
+                           size_t write_batch_size,
+                           scoped_refptr<LevelDBState> level_db,
+                           std::vector<PartitionedLock> locks,
+                           RollbackCallback rollback_callback)
     : scope_id_(scope_id),
       prefix_(std::move(prefix)),
       write_batch_size_(write_batch_size),
       level_db_(std::move(level_db)),
       locks_(std::move(locks)),
-      rollback_callback_(std::move(rollback_callback)),
-      tear_down_callback_(std::move(tear_down_callback)) {
+      rollback_callback_(std::move(rollback_callback)) {
   DCHECK(!locks_.empty());
 }
 
--- a/components/services/storage/indexed_db/scopes/leveldb_scope.h
+++ b/components/services/storage/indexed_db/scopes/leveldb_scope.h
@@ -120,8 +120,7 @@
                size_t write_batch_size,
                scoped_refptr<LevelDBState> level_db,
                std::vector<PartitionedLock> locks,
-               RollbackCallback rollback_callback,
-               TearDownCallback tear_down_callback);
+               RollbackCallback rollback_callback);
 
   // Called by LevelDBScopes. Saves all data, release all locks, and returns the
   // status & the mode of this scope. The caller (LevelDBScopes) is expected to
@@ -180,8 +179,6 @@
   const scoped_refptr<LevelDBState> level_db_;
   std::vector<PartitionedLock> locks_;
   RollbackCallback rollback_callback_;
-  // Warning: Calling this callback can destroy this scope.
-  TearDownCallback tear_down_callback_;
 
   leveldb::WriteBatch buffer_batch_;
   bool buffer_batch_empty_ = true;
--- a/components/services/storage/indexed_db/scopes/leveldb_scope_unittest.cc
+++ b/components/services/storage/indexed_db/scopes/leveldb_scope_unittest.cc
@@ -555,6 +555,9 @@
   scopes.CleanupRunnerForTesting()->PostTask(FROM_HERE, loop.QuitClosure());
   loop.Run();
 
+  // Wait until revert task reports failure.
+  task_env_.RunUntilIdle();
+
   EXPECT_FALSE(failure_status.ok());
   EXPECT_EQ(failure_status.ToString(), error.ToString());
 }
--- a/components/services/storage/indexed_db/scopes/leveldb_scopes.cc
+++ b/components/services/storage/indexed_db/scopes/leveldb_scopes.cc
@@ -242,7 +242,7 @@
       weak_factory_.GetWeakPtr());
   return base::WrapUnique(new LevelDBScope(
       scope_id, metadata_key_prefix_, max_write_batch_size_bytes_, level_db_,
-      std::move(locks), std::move(rollback_callback), tear_down_callback_));
+      std::move(locks), std::move(rollback_callback)));
 }
 
 leveldb::Status LevelDBScopes::Commit(std::unique_ptr<LevelDBScope> scope,
@@ -296,7 +296,10 @@
                                        leveldb::Status result) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   if (UNLIKELY(!result.ok())) {
-    tear_down_callback_.Run(result);
+    // Prospective fix for crbug.com/350196532: synchronous teardown seems to
+    // cause issues.
+    base::SequencedTaskRunner::GetCurrentDefault()->PostTask(
+        FROM_HERE, base::BindOnce(tear_down_callback_, result));
     return;
   }
   auto task = std::make_unique<CleanupScopeTask>(
