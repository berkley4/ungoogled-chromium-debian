From ae639da286e6b99393d03f87baa6badbdc63730a Mon Sep 17 00:00:00 2001
From: Dale Curtis <dalecurtis@chromium.org>
Date: Tue, 13 Aug 2024 21:49:29 +0000
Subject: [PATCH] Allocate H.274 film grain metadata dynamically. Saves ~779kb.

Film grain support adds a huge amount of overhead to the H264Context
structure for a feature that is rarely used. On low end devices or
pages that have lots of media this bloats memory usage rapidly.

This changes the static film grain metadata allocations to be dynamic
which reduces the H264Context size from 851808 bytes to 53444 bytes.

This is slightly different than the version upstreamed in that it
doesn't apply the hevc changes, but we don't need those in Chrome.

R=tguilbert

Bug: https://crbug.com/359358875
Change-Id: I0269324edc2d58ef5a645c4585d903c1d01a1a00
Signed-off-by: Dale Curtis <dalecurtis@chromium.org>
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/third_party/ffmpeg/+/5786487
Reviewed-by: Thomas Guilbert <tguilbert@chromium.org>
---

--- a/third_party/ffmpeg/libavcodec/h2645_sei.c
+++ b/third_party/ffmpeg/libavcodec/h2645_sei.c
@@ -223,7 +223,12 @@
 
         provider_oriented_code = bytestream2_get_byteu(gb);
         if (provider_oriented_code == aom_grain_provider_oriented_code) {
-            return ff_aom_parse_film_grain_sets(&h->aom_film_grain,
+            if (!h->aom_film_grain) {
+                h->aom_film_grain = av_mallocz(sizeof(*h->aom_film_grain));
+                if (!h->aom_film_grain)
+                    return AVERROR(ENOMEM);
+            }
+            return ff_aom_parse_film_grain_sets(h->aom_film_grain,
                                                 gb->buffer,
                                                 bytestream2_get_bytes_left(gb));
         }
@@ -472,7 +477,12 @@
     case SEI_TYPE_DISPLAY_ORIENTATION:
         return decode_display_orientation(&h->display_orientation, gb);
     case SEI_TYPE_FILM_GRAIN_CHARACTERISTICS:
-        return decode_film_grain_characteristics(&h->film_grain_characteristics, codec_id, gb);
+        if (!h->film_grain_characteristics) {
+            h->film_grain_characteristics = av_mallocz(sizeof(*h->film_grain_characteristics));
+            if (!h->film_grain_characteristics)
+                return AVERROR(ENOMEM);
+        }
+        return decode_film_grain_characteristics(h->film_grain_characteristics, codec_id, gb);
     case SEI_TYPE_FRAME_PACKING_ARRANGEMENT:
         return decode_frame_packing_arrangement(&h->frame_packing, gb, codec_id);
     case SEI_TYPE_ALTERNATIVE_TRANSFER_CHARACTERISTICS:
@@ -774,8 +784,8 @@
         }
     }
 
-    if (sei->film_grain_characteristics.present) {
-        H2645SEIFilmGrainCharacteristics *fgc = &sei->film_grain_characteristics;
+    if (sei->film_grain_characteristics && sei->film_grain_characteristics->present) {
+        H2645SEIFilmGrainCharacteristics *fgc = sei->film_grain_characteristics;
         AVFilmGrainParams *fgp = av_film_grain_params_create_side_data(frame);
         AVFilmGrainH274Params *h274;
 
@@ -847,9 +857,11 @@
     }
 
 #if CONFIG_HEVC_SEI
-    ret = ff_aom_attach_film_grain_sets(&sei->aom_film_grain, frame);
-    if (ret < 0)
-        return ret;
+    if (sei->aom_film_grain) {
+        ret = ff_aom_attach_film_grain_sets(sei->aom_film_grain, frame);
+        if (ret < 0)
+            return ret;
+    }
 #endif
 
     return 0;
@@ -875,5 +887,7 @@
     s->ambient_viewing_environment.present = 0;
     s->mastering_display.present = 0;
     s->content_light.present = 0;
-    s->aom_film_grain.enable = 0;
+
+    av_freep(&s->film_grain_characteristics);
+    av_freep(&s->aom_film_grain);
 }
--- a/third_party/ffmpeg/libavcodec/h2645_sei.h
+++ b/third_party/ffmpeg/libavcodec/h2645_sei.h
@@ -130,11 +130,13 @@
     H2645SEIFramePacking frame_packing;
     H2645SEIDisplayOrientation display_orientation;
     H2645SEIAlternativeTransfer alternative_transfer;
-    H2645SEIFilmGrainCharacteristics film_grain_characteristics;
     H2645SEIAmbientViewingEnvironment ambient_viewing_environment;
     H2645SEIMasteringDisplay mastering_display;
     H2645SEIContentLight content_light;
-    AVFilmGrainAFGS1Params aom_film_grain;
+
+    // Dynamic allocations due to large size.
+    H2645SEIFilmGrainCharacteristics* film_grain_characteristics;
+    AVFilmGrainAFGS1Params* aom_film_grain;
 } H2645SEI;
 
 enum {
--- a/third_party/ffmpeg/libavcodec/h264_picture.c
+++ b/third_party/ffmpeg/libavcodec/h264_picture.c
@@ -27,6 +27,7 @@
 
 #include "libavutil/avassert.h"
 #include "libavutil/emms.h"
+#include "libavutil/mem.h"
 #include "error_resilience.h"
 #include "avcodec.h"
 #include "h264dec.h"
@@ -212,9 +213,15 @@
         const AVFrameSideData *sd = av_frame_get_side_data(cur->f, AV_FRAME_DATA_FILM_GRAIN_PARAMS);
 
         err = AVERROR_INVALIDDATA;
-        if (sd) // a decoding error may have happened before the side data could be allocated
-            err = ff_h274_apply_film_grain(cur->f_grain, cur->f, &h->h274db,
+        if (sd) { // a decoding error may have happened before the side data could be allocated
+            if (!h->h274db) {
+                h->h274db = av_mallocz(sizeof(*h->h274db));
+                if (!h->h274db)
+                    return AVERROR(ENOMEM);
+            }
+            err = ff_h274_apply_film_grain(cur->f_grain, cur->f, h->h274db,
                                            (AVFilmGrainParams *) sd->data);
+        }
         if (err < 0) {
             av_log(h->avctx, AV_LOG_WARNING, "Failed synthesizing film "
                    "grain, ignoring: %s\n", av_err2str(err));
--- a/third_party/ffmpeg/libavcodec/h264_sei.c
+++ b/third_party/ffmpeg/libavcodec/h264_sei.c
@@ -55,7 +55,6 @@
     h->picture_timing.present      = 0;
     h->buffering_period.present    = 0;
     h->common.frame_packing.present       = 0;
-    h->common.film_grain_characteristics.present = 0;
     h->common.display_orientation.present = 0;
     h->common.afd.present                 =  0;
 
--- a/third_party/ffmpeg/libavcodec/h264_slice.c
+++ b/third_party/ffmpeg/libavcodec/h264_slice.c
@@ -516,7 +516,10 @@
     pic->f->crop_top    = h->crop_top;
     pic->f->crop_bottom = h->crop_bottom;
 
-    pic->needs_fg = h->sei.common.film_grain_characteristics.present && !h->avctx->hwaccel &&
+    pic->needs_fg =
+        h->sei.common.film_grain_characteristics &&
+        h->sei.common.film_grain_characteristics->present &&
+        !h->avctx->hwaccel &&
         !(h->avctx->export_side_data & AV_CODEC_EXPORT_DATA_FILM_GRAIN);
 
     if ((ret = alloc_picture(h, pic)) < 0)
--- a/third_party/ffmpeg/libavcodec/h264dec.c
+++ b/third_party/ffmpeg/libavcodec/h264dec.c
@@ -156,6 +156,8 @@
     av_freep(&h->mb2b_xy);
     av_freep(&h->mb2br_xy);
 
+    av_freep(&h->h274db);
+
     ff_refstruct_pool_uninit(&h->qscale_table_pool);
     ff_refstruct_pool_uninit(&h->mb_type_pool);
     ff_refstruct_pool_uninit(&h->motion_val_pool);
--- a/third_party/ffmpeg/libavcodec/h264dec.h
+++ b/third_party/ffmpeg/libavcodec/h264dec.h
@@ -336,7 +336,7 @@
     H264DSPContext h264dsp;
     H264ChromaContext h264chroma;
     H264QpelContext h264qpel;
-    H274FilmGrainDatabase h274db;
+    H274FilmGrainDatabase* h274db;  // Dynamic allocation due to large size.
 
     H264Picture DPB[H264_MAX_PICTURE_COUNT];
     H264Picture *cur_pic_ptr;
