From d724878be53a2f7b25854c6c0976b6dfaaf5bad2 Mon Sep 17 00:00:00 2001
From: Shunya Shishido <sisidovski@chromium.org>
Date: Thu, 30 May 2024 05:03:36 +0000
Subject: [PATCH] Add the fix for the issue SW startup going through the main thread

This CL adds the fix to the issue that the ServiceWorker startup goes
through the main thread via the initial IPC.

Currently the initial ServiceWorker startup partially work on the
renderer main thread. This is because we need `cors_exempt_header_list`
to start the ServiceWorker, and the list is passed to the renderer
process at the process initialization. However, the ServiceWorker thread
could try to access `cors_exempt_headers` before its set on the main
thread.

This CL tries to avoid the main thread by passing
`cors_exempt_header_list` directly from the browser process to
ServiceWorker in `EmbeddedWorkerInstance::Start()`. By doing this, the
ServiceWorker startup doesn't have to run on the main thread.

To ensure this fix works, this CL adds UMA to count the length of
`cors_exempt_header_list`. Assuming the length is always same.

This fix is implemented behind the flag. This doesn't change the default
behavior.

Bug: 40753993
Change-Id: I2704644a183d53114eb407a404a7dc898b2a01e6
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5568543
Reviewed-by: Takashi Toyoshima <toyoshim@chromium.org>
Commit-Queue: Shunya Shishido <sisidovski@chromium.org>
Reviewed-by: Rakina Zata Amni <rakina@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1307863}
---

--- a/content/browser/service_worker/embedded_worker_instance.cc
+++ b/content/browser/service_worker/embedded_worker_instance.cc
@@ -304,6 +304,10 @@
   {
     auto* storage_partition =
         static_cast<StoragePartitionImpl*>(rph->GetStoragePartition());
+
+    params->cors_exempt_header_list =
+        storage_partition->cors_exempt_header_list();
+
     // Create COEP reporter if COEP value is already available (= this worker is
     // not a worker which is going to be newly registered). The Mojo remote
     // `coep_reporter_` has the onwership of the instance. The `coep_reporter`
--- a/content/browser/service_worker/embedded_worker_test_helper.cc
+++ b/content/browser/service_worker/embedded_worker_test_helper.cc
@@ -315,6 +315,11 @@
   params->installed_scripts_info = GetInstalledScriptsInfoPtr();
   params->provider_info = CreateProviderInfo(std::move(version));
   params->policy_container = CreateStubPolicyContainer();
+  // Set a fake cors_exempt_header_list here instead of taking from the browser
+  // because the current ServiceWorkerContextWrapper doesn't have
+  // storage_partition. It's possible to set the storage partition but prefer
+  // this simple list for testing.
+  params->cors_exempt_header_list = std::vector<std::string>{"X-Exempt-Test"};
   return params;
 }
 
--- a/content/common/features.cc
+++ b/content/common/features.cc
@@ -444,6 +444,10 @@
              "ServiceWorkerAutoPreload",
              base::FEATURE_DISABLED_BY_DEFAULT);
 
+BASE_FEATURE(kServiceWorkerAvoidMainThreadForInitialization,
+             "ServiceWorkerAvoidMainThreadForInitialization",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+
 // (crbug.com/1371756): When enabled, the static routing API starts
 // ServiceWorker when the routing result of a main resource request was network
 // fallback.
--- a/content/common/features.h
+++ b/content/common/features.h
@@ -103,6 +103,8 @@
 CONTENT_EXPORT BASE_DECLARE_FEATURE(kSendBeaconThrowForBlobWithNonSimpleType);
 CONTENT_EXPORT BASE_DECLARE_FEATURE(kServiceWorkerAutoPreload);
 CONTENT_EXPORT BASE_DECLARE_FEATURE(
+    kServiceWorkerAvoidMainThreadForInitialization);
+CONTENT_EXPORT BASE_DECLARE_FEATURE(
     kServiceWorkerStaticRouterStartServiceWorker);
 CONTENT_EXPORT BASE_DECLARE_FEATURE(kServiceWorkerStaticRouterRaceRequestFix);
 CONTENT_EXPORT BASE_DECLARE_FEATURE(
--- a/content/renderer/browser_exposed_renderer_interfaces.cc
+++ b/content/renderer/browser_exposed_renderer_interfaces.cc
@@ -17,7 +17,9 @@
 #include "base/task/task_runner.h"
 #include "base/task/thread_pool.h"
 #include "base/time/time.h"
+#include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
+#include "content/common/features.h"
 #include "content/common/frame.mojom.h"
 #include "content/public/common/content_client.h"
 #include "content/public/common/resource_usage_reporter.mojom.h"
@@ -145,11 +147,12 @@
       std::move(receiver));
 }
 
-void CreateEmbeddedWorker(
+void CreateEmbeddedWorkerWithRenderMainThread(
     scoped_refptr<base::SingleThreadTaskRunner> initiator_task_runner,
     base::WeakPtr<RenderThreadImpl> render_thread,
     mojo::PendingReceiver<blink::mojom::EmbeddedWorkerInstanceClient>
         receiver) {
+  TRACE_EVENT0("ServiceWorker", "CreateEmbeddedWorkerWithRenderMainThread");
   initiator_task_runner->PostTask(
       FROM_HERE, base::BindOnce(&EmbeddedWorkerInstanceClientImpl::Create,
                                 initiator_task_runner,
@@ -157,6 +160,25 @@
                                 std::move(receiver)));
 }
 
+void CreateEmbeddedWorker(
+    scoped_refptr<base::SingleThreadTaskRunner> initiator_task_runner,
+    mojo::PendingReceiver<blink::mojom::EmbeddedWorkerInstanceClient>
+        receiver) {
+  TRACE_EVENT0("ServiceWorker", "CreateEmbeddedWorker");
+  // An empty fake list is passed to
+  // `EmbeddedWorkerInstanceClientImpl::Create()`. That will be overridden by
+  // the actual cors exempt header list in
+  // `EmbeddedWorkerInstanceClientImpl::StartWorker()`.
+  //
+  // TODO(crbug.com/40753993): Remove this fake empty list once we confirmed
+  // this approach is fine.
+  const std::vector<std::string> fake_cors_exempt_header_list;
+  initiator_task_runner->PostTask(
+      FROM_HERE,
+      base::BindOnce(&EmbeddedWorkerInstanceClientImpl::Create,
+                     initiator_task_runner, fake_cors_exempt_header_list,
+                     std::move(receiver)));
+}
 }  // namespace
 
 void ExposeRendererInterfacesToBrowser(
@@ -181,15 +203,30 @@
       base::ThreadPool::CreateSingleThreadTaskRunner(
           {base::MayBlock(), base::TaskPriority::USER_BLOCKING,
            base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN});
-  // TODO(crbug.com/40753993): Bind on `task_runner_for_service_worker_startup`
-  // instead of the main thread, so startup isn't blocked on the main thread.
-  // Currently it's on the main thread as CreateEmbeddedWorker accesses
-  // `cors_exempt_header_list` from `render_thread`.
-  binders->Add<blink::mojom::EmbeddedWorkerInstanceClient>(
-      base::BindRepeating(&CreateEmbeddedWorker,
-                          task_runner_for_service_worker_startup,
-                          render_thread),
-      base::SingleThreadTaskRunner::GetCurrentDefault());
+  // TODO(crbug.com/40753993): Remove the feature flag and
+  // `CreateEmbeddedWorkerWithRenderMainThread()` once we confirmed this
+  // approach is fine.
+  //
+  // The kServiceWorkerAvoidMainThreadForInitialization feature flag is the
+  // experimental flag to avoid the additional thread hop over the main thread
+  // for the ServiceWorker initialization. Currently it's on the main thread as
+  // CreateEmbeddedWorker accesses `cors_exempt_header_list` from
+  // `render_thread`. When this feature flag is enabled, binds on
+  // `task_runner_for_service_worker_startup` instead of the main thread, so
+  // startup isn't blocked on the main thread.
+  if (base::FeatureList::IsEnabled(
+          features::kServiceWorkerAvoidMainThreadForInitialization)) {
+    binders->Add<blink::mojom::EmbeddedWorkerInstanceClient>(
+        base::BindRepeating(&CreateEmbeddedWorker,
+                            task_runner_for_service_worker_startup),
+        task_runner_for_service_worker_startup);
+  } else {
+    binders->Add<blink::mojom::EmbeddedWorkerInstanceClient>(
+        base::BindRepeating(&CreateEmbeddedWorkerWithRenderMainThread,
+                            task_runner_for_service_worker_startup,
+                            render_thread),
+        base::SingleThreadTaskRunner::GetCurrentDefault());
+  }
 
   GetContentClient()->renderer()->ExposeInterfacesToBrowser(binders);
 }
--- a/content/renderer/service_worker/embedded_worker_instance_client_impl.cc
+++ b/content/renderer/service_worker/embedded_worker_instance_client_impl.cc
@@ -6,6 +6,8 @@
 
 #include <memory>
 
+#include "base/debug/crash_logging.h"
+#include "base/debug/dump_without_crashing.h"
 #include "base/functional/bind.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/utf_string_conversions.h"
@@ -13,6 +15,7 @@
 #include "base/trace_event/trace_event.h"
 #include "content/child/child_thread_impl.h"
 #include "content/child/scoped_child_process_reference.h"
+#include "content/common/features.h"
 #include "content/public/common/content_client.h"
 #include "content/renderer/policy_container_util.h"
 #include "content/renderer/service_worker/service_worker_context_client.h"
@@ -62,6 +65,28 @@
   auto start_timing = blink::mojom::EmbeddedWorkerStartTiming::New();
   start_timing->start_worker_received_time = base::TimeTicks::Now();
 
+  if (base::FeatureList::IsEnabled(
+          features::kServiceWorkerAvoidMainThreadForInitialization)) {
+    // If ServiceWorkerAvoidMainThreadForInitialization feature is enabled, the
+    // fake empty list is set to `cors_exempt_header_list_` here, so override it
+    // with the actual list which is from mojom::EmbeddedWorkerStartParams.
+    cors_exempt_header_list_ = std::move(params->cors_exempt_header_list);
+  } else {
+    // When the feature is not enabled, `cors_exempt_header_list_` and
+    // `params->cors_exempt_header_list` should have same list of headers.
+    if (cors_exempt_header_list_ != params->cors_exempt_header_list) {
+      static bool has_dumped_without_crashing = false;
+      if (!has_dumped_without_crashing) {
+        has_dumped_without_crashing = true;
+        SCOPED_CRASH_KEY_NUMBER("SWInit", "header_list_size",
+                                cors_exempt_header_list_.size());
+        SCOPED_CRASH_KEY_NUMBER("SWInit", "header_list_size_via_mojo",
+                                params->cors_exempt_header_list.size());
+        base::debug::DumpWithoutCrashing();
+      }
+    }
+  }
+
   std::unique_ptr<blink::WebEmbeddedWorkerStartData> start_data =
       BuildStartData(*params);
   if (params->main_script_load_params) {
--- a/third_party/blink/public/mojom/service_worker/embedded_worker.mojom
+++ b/third_party/blink/public/mojom/service_worker/embedded_worker.mojom
@@ -154,6 +154,11 @@
 
   // The StorageKey of the scope where the service worker is created.
   blink.mojom.StorageKey storage_key;
+
+  // The cors exempt header list to start ServiceWorker in the renderer. As the
+  // service worker thread could try to access cors_exempt_headers before its
+  // set on the main thread, directly pass the list from the browser process.
+  array<string> cors_exempt_header_list;
 };
 
 // Holds timing information about the start worker sequence for UMA.
--- a/third_party/blink/renderer/modules/service_worker/web_service_worker_fetch_context_impl.cc
+++ b/third_party/blink/renderer/modules/service_worker/web_service_worker_fetch_context_impl.cc
@@ -4,6 +4,8 @@
 
 #include "third_party/blink/renderer/modules/service_worker/web_service_worker_fetch_context_impl.h"
 
+#include "base/metrics/histogram_functions.h"
+#include "base/numerics/safe_conversions.h"
 #include "base/ranges/algorithm.h"
 #include "base/synchronization/waitable_event.h"
 #include "base/task/single_thread_task_runner.h"
@@ -44,6 +46,10 @@
         pending_subresource_loader_updater,
     const WebVector<WebString>& web_cors_exempt_header_list,
     const bool is_third_party_context) {
+  base::UmaHistogramCounts100(
+      "ServiceWorker.CorsExemptHeaderListSize",
+      base::saturated_cast<int>(web_cors_exempt_header_list.size()));
+
   Vector<String> cors_exempt_header_list(
       base::checked_cast<wtf_size_t>(web_cors_exempt_header_list.size()));
   base::ranges::transform(web_cors_exempt_header_list,
--- a/tools/metrics/histograms/metadata/service/histograms.xml
+++ b/tools/metrics/histograms/metadata/service/histograms.xml
@@ -250,6 +250,20 @@
   </summary>
 </histogram>
 
+<histogram name="ServiceWorker.CorsExemptHeaderListSize" units="count"
+    expires_after="2024-08-28">
+  <owner>sisidovski@chromium.org</owner>
+  <owner>chrome-loading@google.com</owner>
+  <summary>
+    The size of `cors_exempt_header_list` passed from the browser in the
+    ServiceWorker startup.
+
+    This is recorded in `WebServiceWorkerFetchContext::Create()`, in order to
+    ensure the fix for crbug.com/40753993 doesn't introduce any changes to the
+    given `cors_exempt_header_list` used in the ServiceWorker.
+  </summary>
+</histogram>
+
 <histogram name="ServiceWorker.CountUse.CallerInterface"
     enum="WorkerOrWorkletInterfaceNameType" expires_after="2024-10-01">
   <owner>yyanagisawa@chromium.org</owner>
